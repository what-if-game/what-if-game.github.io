{"version":3,"file":"ink.js","sources":["../src/engine/Path.ts","../src/engine/Debug.ts","../src/engine/TypeAssertion.ts","../src/engine/NullException.ts","../src/engine/Object.ts","../src/engine/StringBuilder.ts","../src/engine/InkList.ts","../src/engine/StoryException.ts","../src/engine/TryGetResult.ts","../src/engine/Value.ts","../src/engine/SearchResult.ts","../src/engine/Container.ts","../src/engine/Glue.ts","../src/engine/PushPop.ts","../src/engine/ControlCommand.ts","../src/engine/Pointer.ts","../src/engine/Divert.ts","../src/engine/ChoicePoint.ts","../src/engine/VariableReference.ts","../src/engine/VariableAssignment.ts","../src/engine/Void.ts","../src/engine/NativeFunctionCall.ts","../src/engine/Tag.ts","../src/engine/Choice.ts","../src/engine/ListDefinition.ts","../src/engine/ListDefinitionsOrigin.ts","../src/engine/JsonSerialisation.ts","../src/engine/CallStack.ts","../src/engine/VariablesState.ts","../src/engine/PRNG.ts","../src/engine/StatePatch.ts","../src/engine/SimpleJson.ts","../src/engine/Flow.ts","../src/engine/Error.ts","../src/engine/Story.ts","../src/engine/StoryState.ts","../src/engine/StopWatch.ts"],"sourcesContent":["export class Path {\n  public static parentId = \"^\";\n\n  public _isRelative: boolean;\n  public _components: Path.Component[];\n  public _componentsString: string | null;\n\n  constructor();\n  constructor(componentsString: string);\n  constructor(head: Path.Component, tail: Path);\n  constructor(head: Path.Component[], relative?: boolean);\n  constructor() {\n    this._components = [];\n    this._componentsString = null;\n    this._isRelative = false;\n\n    if (typeof arguments[0] == \"string\") {\n      let componentsString = arguments[0] as string;\n      this.componentsString = componentsString;\n    } else if (\n      arguments[0] instanceof Path.Component &&\n      arguments[1] instanceof Path\n    ) {\n      let head = arguments[0] as Path.Component;\n      let tail = arguments[1] as Path;\n      this._components.push(head);\n      this._components = this._components.concat(tail._components);\n    } else if (arguments[0] instanceof Array) {\n      let head = arguments[0] as Path.Component[];\n      let relative = !!arguments[1] as boolean;\n      this._components = this._components.concat(head);\n      this._isRelative = relative;\n    }\n  }\n  get isRelative() {\n    return this._isRelative;\n  }\n  get componentCount(): number {\n    return this._components.length;\n  }\n  get head(): Path.Component | null {\n    if (this._components.length > 0) {\n      return this._components[0];\n    } else {\n      return null;\n    }\n  }\n  get tail(): Path {\n    if (this._components.length >= 2) {\n      // careful, the original code uses length-1 here. This is because the second argument of\n      // List.GetRange is a number of elements to extract, wherease Array.slice uses an index\n      let tailComps = this._components.slice(1, this._components.length);\n      return new Path(tailComps);\n    } else {\n      return Path.self;\n    }\n  }\n  get length(): number {\n    return this._components.length;\n  }\n  get lastComponent(): Path.Component | null {\n    let lastComponentIdx = this._components.length - 1;\n    if (lastComponentIdx >= 0) {\n      return this._components[lastComponentIdx];\n    } else {\n      return null;\n    }\n  }\n  get containsNamedComponent(): boolean {\n    for (let i = 0, l = this._components.length; i < l; i++) {\n      if (!this._components[i].isIndex) {\n        return true;\n      }\n    }\n    return false;\n  }\n  static get self(): Path {\n    let path = new Path();\n    path._isRelative = true;\n    return path;\n  }\n\n  public GetComponent(index: number): Path.Component {\n    return this._components[index];\n  }\n  public PathByAppendingPath(pathToAppend: Path): Path {\n    let p = new Path();\n\n    let upwardMoves = 0;\n    for (let i = 0; i < pathToAppend._components.length; ++i) {\n      if (pathToAppend._components[i].isParent) {\n        upwardMoves++;\n      } else {\n        break;\n      }\n    }\n\n    for (let i = 0; i < this._components.length - upwardMoves; ++i) {\n      p._components.push(this._components[i]);\n    }\n\n    for (let i = upwardMoves; i < pathToAppend._components.length; ++i) {\n      p._components.push(pathToAppend._components[i]);\n    }\n\n    return p;\n  }\n  get componentsString(): string {\n    if (this._componentsString == null) {\n      this._componentsString = this._components.join(\".\");\n      if (this.isRelative)\n        this._componentsString = \".\" + this._componentsString;\n    }\n\n    return this._componentsString;\n  }\n  set componentsString(value: string) {\n    this._components.length = 0;\n\n    this._componentsString = value;\n\n    if (this._componentsString == null || this._componentsString == \"\") return;\n\n    if (this._componentsString[0] == \".\") {\n      this._isRelative = true;\n      this._componentsString = this._componentsString.substring(1);\n    }\n\n    let componentStrings = this._componentsString.split(\".\");\n    for (let str of componentStrings) {\n      // we need to distinguish between named components that start with a number, eg \"42somewhere\", and indexed components\n      // the normal parseInt won't do for the detection because it's too relaxed.\n      // see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/parseInt\n      if (/^(\\-|\\+)?([0-9]+|Infinity)$/.test(str)) {\n        this._components.push(new Path.Component(parseInt(str)));\n      } else {\n        this._components.push(new Path.Component(str));\n      }\n    }\n  }\n  public toString(): string {\n    return this.componentsString;\n  }\n  public Equals(otherPath: Path | null): boolean {\n    if (otherPath == null) return false;\n\n    if (otherPath._components.length != this._components.length) return false;\n\n    if (otherPath.isRelative != this.isRelative) return false;\n\n    // the original code uses SequenceEqual here, so we need to iterate over the components manually.\n    for (let i = 0, l = otherPath._components.length; i < l; i++) {\n      // it's not quite clear whether this test should use Equals or a simple == operator,\n      // see https://github.com/y-lohse/inkjs/issues/22\n      if (!otherPath._components[i].Equals(this._components[i])) return false;\n    }\n\n    return true;\n  }\n  public PathByAppendingComponent(c: Path.Component): Path {\n    let p = new Path();\n    p._components.push(...this._components);\n    p._components.push(c);\n    return p;\n  }\n}\n\nexport namespace Path {\n  export class Component {\n    public readonly index: number;\n    public readonly name: string | null;\n\n    constructor(indexOrName: string | number) {\n      this.index = -1;\n      this.name = null;\n      if (typeof indexOrName == \"string\") {\n        this.name = indexOrName;\n      } else {\n        this.index = indexOrName;\n      }\n    }\n    get isIndex(): boolean {\n      return this.index >= 0;\n    }\n    get isParent(): boolean {\n      return this.name == Path.parentId;\n    }\n\n    public static ToParent(): Component {\n      return new Component(Path.parentId);\n    }\n    public toString(): string | null {\n      if (this.isIndex) {\n        return this.index.toString();\n      } else {\n        return this.name;\n      }\n    }\n    public Equals(otherComp: Component): boolean {\n      if (otherComp != null && otherComp.isIndex == this.isIndex) {\n        if (this.isIndex) {\n          return this.index == otherComp.index;\n        } else {\n          return this.name == otherComp.name;\n        }\n      }\n\n      return false;\n    }\n  }\n}\n","export namespace Debug {\n  export function AssertType<T>(\n    variable: any,\n    type: new () => T,\n    message: string\n  ): void | never {\n    Assert(variable instanceof type, message);\n  }\n\n  export function Assert(condition: boolean, message?: string): void | never {\n    if (!condition) {\n      if (typeof message !== \"undefined\") {\n        console.warn(message);\n      }\n\n      if (console.trace) {\n        console.trace();\n      }\n\n      throw new Error(\"\");\n    }\n  }\n}\n","import { INamedContent } from \"./INamedContent\";\n\nexport function asOrNull<T>(\n  obj: any,\n  type: (new (...arg: any[]) => T) | (Function & { prototype: T })\n): T | null {\n  if (obj instanceof type) {\n    return unsafeTypeAssertion(obj, type);\n  } else {\n    return null;\n  }\n}\n\nexport function asOrThrows<T>(\n  obj: any,\n  type: (new (...arg: any[]) => T) | (Function & { prototype: T })\n): T | never {\n  if (obj instanceof type) {\n    return unsafeTypeAssertion(obj, type);\n  } else {\n    throw new Error(`${obj} is not of type ${type}`);\n  }\n}\n\nexport function asNumberOrThrows(obj: any) {\n  if (typeof obj === \"number\") {\n    return obj as number;\n  } else {\n    throw new Error(`${obj} is not a number`);\n  }\n}\n\nexport function asBooleanOrThrows(obj: any) {\n  if (typeof obj === \"boolean\") {\n    return obj as boolean;\n  } else {\n    throw new Error(`${obj} is not a boolean`);\n  }\n}\n\n// So here, in the reference implementation, contentObj is casted to an INamedContent\n// but here we use js-style duck typing: if it implements the same props as the interface,\n// we treat it as valid.\nexport function asINamedContentOrNull(obj: any): INamedContent | null {\n  if (obj.hasValidName && obj.name) {\n    return obj as INamedContent;\n  }\n\n  return null;\n}\n\nexport function nullIfUndefined<T>(obj: T | undefined): T | null {\n  if (typeof obj === \"undefined\") {\n    return null;\n  }\n\n  return obj;\n}\n\nexport function isEquatable(type: any) {\n  return typeof type === \"object\" && typeof type.Equals === \"function\";\n}\n\nfunction unsafeTypeAssertion<T>(\n  obj: any,\n  type: (new () => T) | (Function & { prototype: T })\n) {\n  return obj as T;\n}\n\nexport function filterUndef<T>(element: T | undefined): element is T {\n  return element != undefined;\n}\n","/**\n * In the original C# code, a SystemException would be thrown when passing\n * null to methods expected a valid instance. Javascript has no such\n * concept, but TypeScript will not allow `null` to be passed to methods\n * explicitely requiring a valid type.\n *\n * Whenever TypeScript complain about the possibility of a `null` value,\n * check the offending value and it it's null, throw this exception using\n * `throwNullException(name: string)`.\n */\nexport class NullException extends Error {}\n\n/**\n * Throw a NullException.\n *\n * @param name a short description of the offending value (often its name within the code).\n */\nexport function throwNullException(name: string): never {\n  throw new NullException(`${name} is null or undefined`);\n}\n","import { Path } from \"./Path\";\nimport { Container } from \"./Container\";\nimport { Debug } from \"./Debug\";\nimport { asOrNull, asINamedContentOrNull } from \"./TypeAssertion\";\nimport { throwNullException } from \"./NullException\";\nimport { SearchResult } from \"./SearchResult\";\nimport { DebugMetadata } from \"./DebugMetadata\";\n\nexport class InkObject {\n  public parent: InkObject | null = null;\n\n  get debugMetadata(): DebugMetadata | null {\n    if (this._debugMetadata === null) {\n      if (this.parent) {\n        return this.parent.debugMetadata;\n      }\n    }\n\n    return this._debugMetadata;\n  }\n\n  set debugMetadata(value) {\n    this._debugMetadata = value;\n  }\n\n  get ownDebugMetadata() {\n    return this._debugMetadata;\n  }\n\n  private _debugMetadata: DebugMetadata | null = null;\n\n  public DebugLineNumberOfPath(path: Path) {\n    if (path === null) return null;\n\n    // Try to get a line number from debug metadata\n    let root = this.rootContentContainer;\n    if (root) {\n      let targetContent = root.ContentAtPath(path).obj;\n      if (targetContent) {\n        let dm = targetContent.debugMetadata;\n        if (dm !== null) {\n          return dm.startLineNumber;\n        }\n      }\n    }\n\n    return null;\n  }\n\n  get path() {\n    if (this._path == null) {\n      if (this.parent == null) {\n        this._path = new Path();\n      } else {\n        let comps: Path.Component[] = [];\n\n        let child: InkObject = this;\n        let container = asOrNull(child.parent, Container);\n\n        while (container !== null) {\n          let namedChild = asINamedContentOrNull(child);\n          if (namedChild != null && namedChild.hasValidName) {\n            if (namedChild.name === null)\n              return throwNullException(\"namedChild.name\");\n            comps.unshift(new Path.Component(namedChild.name!));\n          } else {\n            comps.unshift(new Path.Component(container.content.indexOf(child)));\n          }\n\n          child = container;\n          container = asOrNull(container.parent, Container);\n        }\n\n        this._path = new Path(comps);\n      }\n    }\n\n    return this._path;\n  }\n  private _path: Path | null = null;\n\n  public ResolvePath(path: Path | null): SearchResult {\n    if (path === null) return throwNullException(\"path\");\n    if (path.isRelative) {\n      let nearestContainer = asOrNull(this, Container);\n\n      if (nearestContainer === null) {\n        Debug.Assert(\n          this.parent !== null,\n          \"Can't resolve relative path because we don't have a parent\"\n        );\n        nearestContainer = asOrNull(this.parent, Container);\n        Debug.Assert(\n          nearestContainer !== null,\n          \"Expected parent to be a container\"\n        );\n        Debug.Assert(path.GetComponent(0).isParent);\n        path = path.tail;\n      }\n\n      if (nearestContainer === null) {\n        return throwNullException(\"nearestContainer\");\n      }\n      return nearestContainer.ContentAtPath(path);\n    } else {\n      let contentContainer = this.rootContentContainer;\n      if (contentContainer === null) {\n        return throwNullException(\"contentContainer\");\n      }\n      return contentContainer.ContentAtPath(path);\n    }\n  }\n\n  public ConvertPathToRelative(globalPath: Path) {\n    let ownPath = this.path;\n\n    let minPathLength = Math.min(globalPath.length, ownPath.length);\n    let lastSharedPathCompIndex = -1;\n\n    for (let i = 0; i < minPathLength; ++i) {\n      let ownComp = ownPath.GetComponent(i);\n      let otherComp = globalPath.GetComponent(i);\n\n      if (ownComp.Equals(otherComp)) {\n        lastSharedPathCompIndex = i;\n      } else {\n        break;\n      }\n    }\n\n    // No shared path components, so just use global path\n    if (lastSharedPathCompIndex == -1) return globalPath;\n\n    let numUpwardsMoves = ownPath.componentCount - 1 - lastSharedPathCompIndex;\n\n    let newPathComps: Path.Component[] = [];\n\n    for (let up = 0; up < numUpwardsMoves; ++up)\n      newPathComps.push(Path.Component.ToParent());\n\n    for (\n      let down = lastSharedPathCompIndex + 1;\n      down < globalPath.componentCount;\n      ++down\n    )\n      newPathComps.push(globalPath.GetComponent(down));\n\n    let relativePath = new Path(newPathComps, true);\n    return relativePath;\n  }\n\n  public CompactPathString(otherPath: Path) {\n    let globalPathStr = null;\n    let relativePathStr = null;\n\n    if (otherPath.isRelative) {\n      relativePathStr = otherPath.componentsString;\n      globalPathStr = this.path.PathByAppendingPath(otherPath).componentsString;\n    } else {\n      let relativePath = this.ConvertPathToRelative(otherPath);\n      relativePathStr = relativePath.componentsString;\n      globalPathStr = otherPath.componentsString;\n    }\n\n    if (relativePathStr.length < globalPathStr.length) return relativePathStr;\n    else return globalPathStr;\n  }\n\n  get rootContentContainer() {\n    let ancestor: InkObject = this;\n    while (ancestor.parent) {\n      ancestor = ancestor.parent;\n    }\n    return asOrNull(ancestor, Container);\n  }\n\n  public Copy(): InkObject {\n    throw Error(\"Not Implemented: Doesn't support copying\");\n  }\n  // SetChild works slightly diferently in the js implementation.\n  // Since we can't pass an objets property by reference, we instead pass\n  // the object and the property string.\n  // TODO: This method can probably be rewritten with type-safety in mind.\n  public SetChild(obj: any, prop: any, value: any) {\n    if (obj[prop]) obj[prop] = null;\n\n    obj[prop] = value;\n\n    if (obj[prop]) obj[prop].parent = this;\n  }\n\n  public Equals(obj: any) {\n    return obj === this;\n  }\n}\n","export class StringBuilder {\n  private string: string;\n\n  constructor(str?: string) {\n    str = typeof str !== \"undefined\" ? str.toString() : \"\";\n    this.string = str;\n  }\n  get Length(): number {\n    return this.string.length;\n  }\n  public Append(str: string | null) {\n    if (str !== null) {\n      this.string += str;\n    }\n  }\n  public AppendLine(str?: string) {\n    if (typeof str !== \"undefined\") this.Append(str);\n    this.string += \"\\n\";\n  }\n  public AppendFormat(format: string, ...args: any[]) {\n    // taken from http://stackoverflow.com/questions/610406/javascript-equivalent-to-printf-string-format\n    this.string += format.replace(/{(\\d+)}/g, (match: string, num: number) =>\n      typeof args[num] != \"undefined\" ? args[num] : match\n    );\n  }\n  public toString(): string {\n    return this.string;\n  }\n\n  public Clear() {\n    this.string = \"\";\n  }\n}\n","import { throwNullException } from \"./NullException\";\nimport { StringBuilder } from \"./StringBuilder\";\nimport { ListDefinition } from \"./ListDefinition\";\nimport { Story } from \"./Story\";\n\nexport class InkListItem implements IInkListItem {\n  // InkListItem is a struct\n\n  public readonly originName: string | null = null;\n  public readonly itemName: string | null = null;\n\n  constructor(originName: string | null, itemName: string | null);\n  constructor(fullName: string | null);\n  constructor() {\n    if (typeof arguments[1] !== \"undefined\") {\n      let originName = arguments[0] as string | null;\n      let itemName = arguments[1] as string | null;\n\n      this.originName = originName;\n      this.itemName = itemName;\n    } else if (arguments[0]) {\n      let fullName = arguments[0] as string;\n\n      let nameParts = fullName.toString().split(\".\");\n      this.originName = nameParts[0];\n      this.itemName = nameParts[1];\n    }\n  }\n  public static get Null() {\n    return new InkListItem(null, null);\n  }\n  public get isNull() {\n    return this.originName == null && this.itemName == null;\n  }\n  get fullName() {\n    return (\n      (this.originName !== null ? this.originName : \"?\") + \".\" + this.itemName\n    );\n  }\n  public toString(): string {\n    return this.fullName;\n  }\n  public Equals(obj: InkListItem) {\n    if (obj instanceof InkListItem) {\n      let otherItem = obj;\n      return (\n        otherItem.itemName == this.itemName &&\n        otherItem.originName == this.originName\n      );\n    }\n\n    return false;\n  }\n\n  // These methods did not exist in the original C# code. Their purpose is to\n  // make `InkListItem` mimics the value-type semantics of the original\n  // struct. Please refer to the end of this file, for a more in-depth\n  // explanation.\n\n  /**\n   * Returns a shallow clone of the current instance.\n   */\n  public copy() {\n    return new InkListItem(this.originName, this.itemName);\n  }\n  /**\n   * Returns a `SerializedInkListItem` representing the current\n   * instance. The result is intended to be used as a key inside a Map.\n   */\n  public serialized(): SerializedInkListItem {\n    // We are simply using a JSON representation as a value-typed key.\n    return JSON.stringify({\n      originName: this.originName,\n      itemName: this.itemName,\n    });\n  }\n\n  /**\n   * Reconstructs a `InkListItem` from the given SerializedInkListItem.\n   */\n  public static fromSerializedKey(key: SerializedInkListItem): InkListItem {\n    let obj = JSON.parse(key);\n    if (!InkListItem.isLikeInkListItem(obj)) return InkListItem.Null;\n\n    let inkListItem = obj as IInkListItem;\n\n    return new InkListItem(inkListItem.originName, inkListItem.itemName);\n  }\n\n  /**\n   * Determines whether the given item is sufficiently `InkListItem`-like\n   * to be used as a template when reconstructing the InkListItem.\n   */\n  private static isLikeInkListItem(item: any) {\n    if (typeof item !== \"object\") return false;\n    if (!item.hasOwnProperty(\"originName\") || !item.hasOwnProperty(\"itemName\"))\n      return false;\n    if (typeof item.originName !== \"string\" && typeof item.originName !== null)\n      return false;\n    if (typeof item.itemName !== \"string\" && typeof item.itemName !== null)\n      return false;\n\n    return true;\n  }\n}\n\nexport class InkList extends Map<SerializedInkListItem, number> {\n  public origins: ListDefinition[] | null = null;\n  public _originNames: string[] | null = [];\n\n  constructor();\n  constructor(otherList: InkList);\n  constructor(singleOriginListName: string, originStory: Story);\n  constructor(singleElement: KeyValuePair<InkListItem, number>);\n  constructor() {\n    // Trying to be smart here, this emulates the constructor inheritance found\n    // in the original code, but only if otherList is an InkList. IIFE FTW.\n    super(\n      (() => {\n        if (arguments[0] instanceof InkList) {\n          return arguments[0];\n        } else {\n          return [];\n        }\n      })()\n    );\n\n    if (arguments[0] instanceof InkList) {\n      let otherList = arguments[0] as InkList;\n\n      let otherOriginNames = otherList.originNames as string[];\n      if (otherOriginNames !== null)\n        this._originNames = otherOriginNames.slice();\n      if (otherList.origins !== null) {\n        this.origins = otherList.origins.slice();\n      }\n    } else if (typeof arguments[0] === \"string\") {\n      let singleOriginListName = arguments[0] as string;\n      let originStory = arguments[1] as Story;\n      this.SetInitialOriginName(singleOriginListName);\n\n      if (originStory.listDefinitions === null) {\n        return throwNullException(\"originStory.listDefinitions\");\n      }\n      let def = originStory.listDefinitions.TryListGetDefinition(\n        singleOriginListName,\n        null\n      );\n      if (def.exists) {\n        // Throwing now, because if the value is `null` it will\n        // eventually throw down the line.\n        if (def.result === null) {\n          return throwNullException(\"def.result\");\n        }\n        this.origins = [def.result];\n      } else {\n        throw new Error(\n          \"InkList origin could not be found in story when constructing new list: \" +\n            singleOriginListName\n        );\n      }\n    } else if (\n      typeof arguments[0] === \"object\" &&\n      arguments[0].hasOwnProperty(\"Key\") &&\n      arguments[0].hasOwnProperty(\"Value\")\n    ) {\n      let singleElement = arguments[0] as KeyValuePair<InkListItem, number>;\n      this.Add(singleElement.Key, singleElement.Value);\n    }\n  }\n\n  public static FromString(myListItem: string, originStory: Story) {\n    let listValue =\n      originStory.listDefinitions?.FindSingleItemListWithName(myListItem);\n    if (listValue) {\n      if (listValue.value === null) {\n        return throwNullException(\"listValue.value\");\n      }\n      return new InkList(listValue.value);\n    } else {\n      throw new Error(\n        \"Could not find the InkListItem from the string '\" +\n          myListItem +\n          \"' to create an InkList because it doesn't exist in the original list definition in ink.\"\n      );\n    }\n  }\n\n  public AddItem(itemOrItemName: InkListItem | string | null) {\n    if (itemOrItemName instanceof InkListItem) {\n      let item = itemOrItemName;\n\n      if (item.originName == null) {\n        this.AddItem(item.itemName);\n        return;\n      }\n\n      if (this.origins === null) return throwNullException(\"this.origins\");\n\n      for (let origin of this.origins) {\n        if (origin.name == item.originName) {\n          let intVal = origin.TryGetValueForItem(item, 0);\n          if (intVal.exists) {\n            this.Add(item, intVal.result);\n            return;\n          } else {\n            throw new Error(\n              \"Could not add the item \" +\n                item +\n                \" to this list because it doesn't exist in the original list definition in ink.\"\n            );\n          }\n        }\n      }\n\n      throw new Error(\n        \"Failed to add item to list because the item was from a new list definition that wasn't previously known to this list. Only items from previously known lists can be used, so that the int value can be found.\"\n      );\n    } else {\n      let itemName = itemOrItemName as string | null;\n\n      let foundListDef: ListDefinition | null = null;\n\n      if (this.origins === null) return throwNullException(\"this.origins\");\n\n      for (let origin of this.origins) {\n        if (itemName === null) return throwNullException(\"itemName\");\n\n        if (origin.ContainsItemWithName(itemName)) {\n          if (foundListDef != null) {\n            throw new Error(\n              \"Could not add the item \" +\n                itemName +\n                \" to this list because it could come from either \" +\n                origin.name +\n                \" or \" +\n                foundListDef.name\n            );\n          } else {\n            foundListDef = origin;\n          }\n        }\n      }\n\n      if (foundListDef == null)\n        throw new Error(\n          \"Could not add the item \" +\n            itemName +\n            \" to this list because it isn't known to any list definitions previously associated with this list.\"\n        );\n\n      let item = new InkListItem(foundListDef.name, itemName);\n      let itemVal = foundListDef.ValueForItem(item);\n      this.Add(item, itemVal);\n    }\n  }\n  public ContainsItemNamed(itemName: string | null) {\n    for (let [key] of this) {\n      let item = InkListItem.fromSerializedKey(key);\n      if (item.itemName == itemName) return true;\n    }\n\n    return false;\n  }\n  public ContainsKey(key: InkListItem) {\n    return this.has(key.serialized());\n  }\n  public Add(key: InkListItem, value: number) {\n    let serializedKey = key.serialized();\n    if (this.has(serializedKey)) {\n      // Throw an exception to match the C# behavior.\n      throw new Error(`The Map already contains an entry for ${key}`);\n    }\n    this.set(serializedKey, value);\n  }\n  public Remove(key: InkListItem) {\n    return this.delete(key.serialized());\n  }\n  get Count() {\n    return this.size;\n  }\n  get originOfMaxItem(): ListDefinition | null {\n    if (this.origins == null) return null;\n\n    let maxOriginName = this.maxItem.Key.originName;\n    let result = null;\n    this.origins.every((origin) => {\n      if (origin.name == maxOriginName) {\n        result = origin;\n        return false;\n      } else return true;\n    });\n\n    return result;\n  }\n  get originNames(): string[] {\n    if (this.Count > 0) {\n      if (this._originNames == null && this.Count > 0) this._originNames = [];\n      else {\n        if (!this._originNames) this._originNames = [];\n        this._originNames.length = 0;\n      }\n\n      for (let [key] of this) {\n        let item = InkListItem.fromSerializedKey(key);\n        if (item.originName === null)\n          return throwNullException(\"item.originName\");\n        this._originNames.push(item.originName);\n      }\n    }\n\n    return this._originNames as string[];\n  }\n  public SetInitialOriginName(initialOriginName: string) {\n    this._originNames = [initialOriginName];\n  }\n  public SetInitialOriginNames(initialOriginNames: string[]) {\n    if (initialOriginNames == null) this._originNames = null;\n    else this._originNames = initialOriginNames.slice(); // store a copy\n  }\n  get maxItem() {\n    let max: KeyValuePair<InkListItem, number> = {\n      Key: InkListItem.Null,\n      Value: 0,\n    };\n    for (let [key, value] of this) {\n      let item = InkListItem.fromSerializedKey(key);\n      if (max.Key.isNull || value > max.Value)\n        max = { Key: item, Value: value };\n    }\n\n    return max;\n  }\n  get minItem() {\n    let min: KeyValuePair<InkListItem, number> = {\n      Key: InkListItem.Null,\n      Value: 0,\n    };\n    for (let [key, value] of this) {\n      let item = InkListItem.fromSerializedKey(key);\n      if (min.Key.isNull || value < min.Value) {\n        min = { Key: item, Value: value };\n      }\n    }\n    return min;\n  }\n  get inverse() {\n    let list = new InkList();\n    if (this.origins != null) {\n      for (let origin of this.origins) {\n        for (let [key, value] of origin.items) {\n          let item = InkListItem.fromSerializedKey(key);\n          if (!this.ContainsKey(item)) list.Add(item, value);\n        }\n      }\n    }\n    return list;\n  }\n  get all() {\n    let list = new InkList();\n    if (this.origins != null) {\n      for (let origin of this.origins) {\n        for (let [key, value] of origin.items) {\n          let item = InkListItem.fromSerializedKey(key);\n          list.set(item.serialized(), value);\n        }\n      }\n    }\n    return list;\n  }\n  public Union(otherList: InkList) {\n    let union = new InkList(this);\n    for (let [key, value] of otherList) {\n      union.set(key, value);\n    }\n    return union;\n  }\n  public Intersect(otherList: InkList) {\n    let intersection = new InkList();\n    for (let [key, value] of this) {\n      if (otherList.has(key)) intersection.set(key, value);\n    }\n\n    return intersection;\n  }\n  public HasIntersection(otherList: InkList): boolean {\n    for (let [key] of this) {\n      if (otherList.has(key)) return true;\n    }\n    return false;\n  }\n  public Without(listToRemove: InkList) {\n    let result = new InkList(this);\n    for (let [key] of listToRemove) {\n      result.delete(key);\n    }\n\n    return result;\n  }\n\n  public Contains(key: string): boolean;\n  public Contains(otherList: InkList): boolean;\n  public Contains(what: string | InkList): boolean {\n    if (typeof what == \"string\") return this.ContainsItemNamed(what);\n    const otherList = what;\n    if (otherList.size == 0 || this.size == 0) return false;\n    for (let [key] of otherList) {\n      if (!this.has(key)) return false;\n    }\n\n    return true;\n  }\n  public GreaterThan(otherList: InkList) {\n    if (this.Count == 0) return false;\n    if (otherList.Count == 0) return true;\n\n    return this.minItem.Value > otherList.maxItem.Value;\n  }\n  public GreaterThanOrEquals(otherList: InkList) {\n    if (this.Count == 0) return false;\n    if (otherList.Count == 0) return true;\n\n    return (\n      this.minItem.Value >= otherList.minItem.Value &&\n      this.maxItem.Value >= otherList.maxItem.Value\n    );\n  }\n  public LessThan(otherList: InkList) {\n    if (otherList.Count == 0) return false;\n    if (this.Count == 0) return true;\n\n    return this.maxItem.Value < otherList.minItem.Value;\n  }\n  public LessThanOrEquals(otherList: InkList) {\n    if (otherList.Count == 0) return false;\n    if (this.Count == 0) return true;\n\n    return (\n      this.maxItem.Value <= otherList.maxItem.Value &&\n      this.minItem.Value <= otherList.minItem.Value\n    );\n  }\n  public MaxAsList() {\n    if (this.Count > 0) return new InkList(this.maxItem);\n    else return new InkList();\n  }\n  public MinAsList() {\n    if (this.Count > 0) return new InkList(this.minItem);\n    else return new InkList();\n  }\n  public ListWithSubRange(minBound: any, maxBound: any) {\n    if (this.Count == 0) return new InkList();\n\n    let ordered = this.orderedItems;\n\n    let minValue = 0;\n    let maxValue = Number.MAX_SAFE_INTEGER;\n\n    if (Number.isInteger(minBound)) {\n      minValue = minBound;\n    } else {\n      if (minBound instanceof InkList && minBound.Count > 0)\n        minValue = minBound.minItem.Value;\n    }\n\n    if (Number.isInteger(maxBound)) {\n      maxValue = maxBound;\n    } else {\n      if (minBound instanceof InkList && minBound.Count > 0)\n        maxValue = maxBound.maxItem.Value;\n    }\n\n    let subList = new InkList();\n    subList.SetInitialOriginNames(this.originNames);\n    for (let item of ordered) {\n      if (item.Value >= minValue && item.Value <= maxValue) {\n        subList.Add(item.Key, item.Value);\n      }\n    }\n\n    return subList;\n  }\n  public Equals(otherInkList: InkList) {\n    if (otherInkList instanceof InkList === false) return false;\n    if (otherInkList.Count != this.Count) return false;\n\n    for (let [key] of this) {\n      if (!otherInkList.has(key)) return false;\n    }\n\n    return true;\n  }\n  // GetHashCode not implemented\n  get orderedItems() {\n    // List<KeyValuePair<InkListItem, int>>\n    let ordered = new Array<KeyValuePair<InkListItem, number>>();\n\n    for (let [key, value] of this) {\n      let item = InkListItem.fromSerializedKey(key);\n      ordered.push({ Key: item, Value: value });\n    }\n\n    ordered.sort((x, y) => {\n      if (x.Key.originName === null) {\n        return throwNullException(\"x.Key.originName\");\n      }\n      if (y.Key.originName === null) {\n        return throwNullException(\"y.Key.originName\");\n      }\n\n      if (x.Value == y.Value) {\n        return x.Key.originName.localeCompare(y.Key.originName);\n      } else {\n        // TODO: refactor this bit into a numberCompareTo method?\n        if (x.Value < y.Value) return -1;\n        return x.Value > y.Value ? 1 : 0;\n      }\n    });\n\n    return ordered;\n  }\n  public toString() {\n    let ordered = this.orderedItems;\n\n    let sb = new StringBuilder();\n    for (let i = 0; i < ordered.length; i++) {\n      if (i > 0) sb.Append(\", \");\n\n      let item = ordered[i].Key;\n      if (item.itemName === null) return throwNullException(\"item.itemName\");\n      sb.Append(item.itemName);\n    }\n\n    return sb.toString();\n  }\n  // casting a InkList to a Number, for somereason, actually gives a number.\n  // This messes up the type detection when creating a Value from a InkList.\n  // Returning NaN here prevents that.\n  public valueOf() {\n    return NaN;\n  }\n}\n\n/**\n * In the original C# code, `InkListItem` was defined as value type, meaning\n * that two `InkListItem` would be considered equal as long as they held the\n * same values. This doesn't hold true in Javascript, as `InkListItem` is a\n * reference type (Javascript doesn't allow the creation of custom value types).\n *\n * The key equality of Map objects is based on the \"SameValueZero\" algorithm;\n * since `InkListItem` is a value type, two keys will only be considered\n * equal if they are, in fact, the same object. As we are trying to emulate\n * the original behavior as close as possible, this will lead to unforeseen\n * side effects.\n *\n * In order to have a key equality based on value semantics, we'll convert\n * `InkListItem` to a valid string representation and use this representation\n * as a key (strings are value types in Javascript). Rather than using the\n * type `string` directly, we'll alias it to `SerializedInkListItem` and use\n * this type as the key for our Map-based `InkList`.\n *\n * Reducing `InkListItem` to a JSON representation would not be bulletproof\n * in the general case, but for our needs it works well. The major downside of\n * this method is that we will have to to reconstruct the original `InkListItem`\n * every time we'll need to access its properties.\n */\nexport type SerializedInkListItem = string;\n\n/**\n * An interface inherited by `InkListItem`, defining exposed\n * properties. It's mainly used when deserializing a `InkListItem` from its\n * key (`SerializedInkListItem`)\n */\ninterface IInkListItem {\n  readonly originName: string | null;\n  readonly itemName: string | null;\n}\nexport interface KeyValuePair<K, V> {\n  Key: K;\n  Value: V;\n}\n","export class StoryException extends Error {\n  public useEndLineNumber: boolean;\n  public message: string;\n  public name: string;\n\n  constructor(message: string) {\n    super(message);\n    this.useEndLineNumber = false;\n    this.message = message;\n    this.name = \"StoryException\";\n  }\n}\n","/**\n * This interface normalize the `TryGet` behavior found in the original\n * C# project. Any `TryGet` method will return a object conforming to this\n * interface.\n *\n * The original function returns a boolean and has a second parameter called\n * item that is an `out`. Both are needed and we can't just return the item\n * because it'll always be truthy. Instead, we return an object containing\n * whether the result exists (`exists`) and the result itself (`result`).\n *\n * For instance a `TryGet` prototype would look like this:\n```\nTryGetItemWithValue(val: number, item: InkListItem): TryGetResult<InkListItem>{\n```\n *\n * On the other hand, dealing with the result can be done in the following way:\n```\nvar item = item.TryGetItemWithValue(intVal, InkListItem.Null);\nif (item.exists) {\n\tconsole.log(item.result)\n}\n```\n *\n */\nexport interface TryGetResult<T> {\n  result: T;\n  exists: boolean;\n}\n\nexport function tryGetValueFromMap<K, V>(\n  map: Map<K, V> | null,\n  key: K,\n  /* out */ value: V\n): TryGetResult<V> {\n  if (map === null) {\n    return { result: value, exists: false };\n  }\n\n  let val = map.get(key);\n\n  if (typeof val === \"undefined\") {\n    return { result: value, exists: false };\n  } else {\n    return { result: val, exists: true };\n  }\n}\n\nexport function tryParseInt(\n  value: any,\n  /* out */ defaultValue: number = 0\n): TryGetResult<number> {\n  let val = parseInt(value);\n\n  if (!Number.isNaN(val)) {\n    return { result: val, exists: true };\n  } else {\n    return { result: defaultValue, exists: false };\n  }\n}\n\nexport function tryParseFloat(\n  value: any,\n  /* out */ defaultValue: number = 0\n): TryGetResult<number> {\n  let val = parseFloat(value);\n\n  if (!Number.isNaN(val)) {\n    return { result: val, exists: true };\n  } else {\n    return { result: defaultValue, exists: false };\n  }\n}\n","import { InkObject } from \"./Object\";\nimport { Path } from \"./Path\";\nimport { InkList, InkListItem } from \"./InkList\";\nimport { StoryException } from \"./StoryException\";\nimport { asOrNull, asOrThrows } from \"./TypeAssertion\";\nimport { tryParseInt, tryParseFloat } from \"./TryGetResult\";\nimport { throwNullException } from \"./NullException\";\n\nexport abstract class AbstractValue extends InkObject {\n  public abstract get valueType(): ValueType;\n  public abstract get isTruthy(): boolean;\n  public abstract get valueObject(): any;\n\n  public abstract Cast(newType: ValueType): Value<any>;\n\n  public static Create(\n    val: any,\n    preferredNumberType?: ValueType\n  ): Value<any> | null {\n    // This code doesn't exist in upstream and is simply here to enforce\n    // the creation of the proper number value.\n    // If `preferredNumberType` is not provided or if value doesn't match\n    // `preferredNumberType`, this conditional does nothing.\n    if (preferredNumberType) {\n      if (\n        preferredNumberType === (ValueType.Int as ValueType) &&\n        Number.isInteger(Number(val))\n      ) {\n        return new IntValue(Number(val));\n      } else if (\n        preferredNumberType === (ValueType.Float as ValueType) &&\n        !isNaN(val)\n      ) {\n        return new FloatValue(Number(val));\n      }\n    }\n\n    if (typeof val === \"boolean\") {\n      return new BoolValue(Boolean(val));\n    }\n\n    // https://github.com/y-lohse/inkjs/issues/425\n    // Changed condition sequence, because Number('') is\n    // parsed to 0, which made setting string to empty\n    // impossible\n    if (typeof val === \"string\") {\n      return new StringValue(String(val));\n    } else if (Number.isInteger(Number(val))) {\n      return new IntValue(Number(val));\n    } else if (!isNaN(val)) {\n      return new FloatValue(Number(val));\n    } else if (val instanceof Path) {\n      return new DivertTargetValue(asOrThrows(val, Path));\n    } else if (val instanceof InkList) {\n      return new ListValue(asOrThrows(val, InkList));\n    }\n\n    return null;\n  }\n  public Copy() {\n    return asOrThrows(AbstractValue.Create(this.valueObject), InkObject);\n  }\n  public BadCastException(targetType: ValueType) {\n    return new StoryException(\n      \"Can't cast \" +\n        this.valueObject +\n        \" from \" +\n        this.valueType +\n        \" to \" +\n        targetType\n    );\n  }\n}\n\nexport abstract class Value<\n  T extends { toString: () => string }\n> extends AbstractValue {\n  public value: T | null;\n\n  constructor(val: T | null) {\n    super();\n    this.value = val;\n  }\n  public get valueObject() {\n    return this.value;\n  }\n  public toString() {\n    if (this.value === null) return throwNullException(\"Value.value\");\n    return this.value.toString();\n  }\n}\n\nexport class BoolValue extends Value<boolean> {\n  constructor(val: boolean) {\n    super(val || false);\n  }\n  public get isTruthy() {\n    return Boolean(this.value);\n  }\n  public get valueType() {\n    return ValueType.Bool;\n  }\n\n  public Cast(newType: ValueType): Value<any> {\n    if (this.value === null) return throwNullException(\"Value.value\");\n\n    if (newType == this.valueType) {\n      return this;\n    }\n\n    if (newType == ValueType.Int) {\n      return new IntValue(this.value ? 1 : 0);\n    }\n\n    if (newType == ValueType.Float) {\n      return new FloatValue(this.value ? 1.0 : 0.0);\n    }\n\n    if (newType == ValueType.String) {\n      return new StringValue(this.value ? \"true\" : \"false\");\n    }\n\n    throw this.BadCastException(newType);\n  }\n\n  public toString() {\n    return this.value ? \"true\" : \"false\";\n  }\n}\n\nexport class IntValue extends Value<number> {\n  constructor(val: number) {\n    super(val || 0);\n  }\n  public get isTruthy() {\n    return this.value != 0;\n  }\n  public get valueType() {\n    return ValueType.Int;\n  }\n\n  public Cast(newType: ValueType): Value<any> {\n    if (this.value === null) return throwNullException(\"Value.value\");\n\n    if (newType == this.valueType) {\n      return this;\n    }\n\n    if (newType == ValueType.Bool) {\n      return new BoolValue(this.value === 0 ? false : true);\n    }\n\n    if (newType == ValueType.Float) {\n      return new FloatValue(this.value);\n    }\n\n    if (newType == ValueType.String) {\n      return new StringValue(\"\" + this.value);\n    }\n\n    throw this.BadCastException(newType);\n  }\n}\n\nexport class FloatValue extends Value<number> {\n  constructor(val: number) {\n    super(val || 0.0);\n  }\n  public get isTruthy() {\n    return this.value != 0.0;\n  }\n  public get valueType() {\n    return ValueType.Float;\n  }\n\n  public Cast(newType: ValueType): Value<any> {\n    if (this.value === null) return throwNullException(\"Value.value\");\n\n    if (newType == this.valueType) {\n      return this;\n    }\n\n    if (newType == ValueType.Bool) {\n      return new BoolValue(this.value === 0.0 ? false : true);\n    }\n\n    if (newType == ValueType.Int) {\n      return new IntValue(this.value);\n    }\n\n    if (newType == ValueType.String) {\n      return new StringValue(\"\" + this.value);\n    }\n\n    throw this.BadCastException(newType);\n  }\n}\n\nexport class StringValue extends Value<string> {\n  public _isNewline: boolean;\n  public _isInlineWhitespace: boolean;\n\n  constructor(val: string) {\n    super(val || \"\");\n\n    this._isNewline = this.value == \"\\n\";\n    this._isInlineWhitespace = true;\n\n    if (this.value === null) return throwNullException(\"Value.value\");\n\n    if (this.value.length > 0) {\n      this.value.split(\"\").every((c) => {\n        if (c != \" \" && c != \"\\t\") {\n          this._isInlineWhitespace = false;\n          return false;\n        }\n\n        return true;\n      });\n    }\n  }\n  public get valueType() {\n    return ValueType.String;\n  }\n  public get isTruthy() {\n    if (this.value === null) return throwNullException(\"Value.value\");\n    return this.value.length > 0;\n  }\n  public get isNewline() {\n    return this._isNewline;\n  }\n  public get isInlineWhitespace() {\n    return this._isInlineWhitespace;\n  }\n  public get isNonWhitespace() {\n    return !this.isNewline && !this.isInlineWhitespace;\n  }\n\n  public Cast(newType: ValueType): Value<any> {\n    if (newType == this.valueType) {\n      return this;\n    }\n\n    if (newType == ValueType.Int) {\n      let parsedInt = tryParseInt(this.value);\n      if (parsedInt.exists) {\n        return new IntValue(parsedInt.result);\n      } else {\n        throw this.BadCastException(newType);\n      }\n    }\n\n    if (newType == ValueType.Float) {\n      let parsedFloat = tryParseFloat(this.value);\n      if (parsedFloat.exists) {\n        return new FloatValue(parsedFloat.result);\n      } else {\n        throw this.BadCastException(newType);\n      }\n    }\n\n    throw this.BadCastException(newType);\n  }\n}\n\nexport class DivertTargetValue extends Value<Path> {\n  constructor(targetPath: Path | null = null) {\n    super(targetPath);\n  }\n  public get valueType() {\n    return ValueType.DivertTarget;\n  }\n  public get targetPath() {\n    if (this.value === null) return throwNullException(\"Value.value\");\n    return this.value;\n  }\n  public set targetPath(value: Path) {\n    this.value = value;\n  }\n  public get isTruthy(): never {\n    throw new Error(\"Shouldn't be checking the truthiness of a divert target\");\n  }\n\n  public Cast(newType: ValueType): Value<any> {\n    if (newType == this.valueType) return this;\n\n    throw this.BadCastException(newType);\n  }\n  public toString() {\n    return \"DivertTargetValue(\" + this.targetPath + \")\";\n  }\n}\n\nexport class VariablePointerValue extends Value<string> {\n  public _contextIndex: number;\n\n  constructor(variableName: string, contextIndex: number = -1) {\n    super(variableName);\n\n    this._contextIndex = contextIndex;\n  }\n\n  public get contextIndex() {\n    return this._contextIndex;\n  }\n  public set contextIndex(value: number) {\n    this._contextIndex = value;\n  }\n  public get variableName() {\n    if (this.value === null) return throwNullException(\"Value.value\");\n    return this.value;\n  }\n  public set variableName(value: string) {\n    this.value = value;\n  }\n  public get valueType() {\n    return ValueType.VariablePointer;\n  }\n\n  public get isTruthy(): never {\n    throw new Error(\n      \"Shouldn't be checking the truthiness of a variable pointer\"\n    );\n  }\n\n  public Cast(newType: ValueType): Value<any> {\n    if (newType == this.valueType) return this;\n\n    throw this.BadCastException(newType);\n  }\n  public toString() {\n    return \"VariablePointerValue(\" + this.variableName + \")\";\n  }\n  public Copy() {\n    return new VariablePointerValue(this.variableName, this.contextIndex);\n  }\n}\n\nexport class ListValue extends Value<InkList> {\n  public get isTruthy() {\n    if (this.value === null) {\n      return throwNullException(\"this.value\");\n    }\n    return this.value.Count > 0;\n  }\n  public get valueType() {\n    return ValueType.List;\n  }\n  public Cast(newType: ValueType): Value<any> {\n    if (this.value === null) return throwNullException(\"Value.value\");\n\n    if (newType == ValueType.Int) {\n      let max = this.value.maxItem;\n      if (max.Key.isNull) return new IntValue(0);\n      else return new IntValue(max.Value);\n    } else if (newType == ValueType.Float) {\n      let max = this.value.maxItem;\n      if (max.Key.isNull) return new FloatValue(0.0);\n      else return new FloatValue(max.Value);\n    } else if (newType == ValueType.String) {\n      let max = this.value.maxItem;\n      if (max.Key.isNull) return new StringValue(\"\");\n      else {\n        return new StringValue(max.Key.toString());\n      }\n    }\n\n    if (newType == this.valueType) return this;\n\n    throw this.BadCastException(newType);\n  }\n  constructor();\n  constructor(list: InkList);\n  constructor(listOrSingleItem: InkListItem, singleValue: number);\n  constructor(listOrSingleItem?: InkListItem | InkList, singleValue?: number) {\n    super(null);\n\n    if (!listOrSingleItem && !singleValue) {\n      this.value = new InkList();\n    } else if (listOrSingleItem instanceof InkList) {\n      this.value = new InkList(listOrSingleItem);\n    } else if (\n      listOrSingleItem instanceof InkListItem &&\n      typeof singleValue === \"number\"\n    ) {\n      this.value = new InkList({\n        Key: listOrSingleItem,\n        Value: singleValue,\n      });\n    }\n  }\n  public static RetainListOriginsForAssignment(\n    oldValue: InkObject | null,\n    newValue: InkObject\n  ) {\n    let oldList = asOrNull(oldValue, ListValue);\n    let newList = asOrNull(newValue, ListValue);\n\n    if (newList && newList.value === null)\n      return throwNullException(\"newList.value\");\n    if (oldList && oldList.value === null)\n      return throwNullException(\"oldList.value\");\n\n    // When assigning the empty list, try to retain any initial origin names\n    if (oldList && newList && newList.value!.Count == 0)\n      newList.value!.SetInitialOriginNames(oldList.value!.originNames);\n  }\n}\n\nexport enum ValueType {\n  Bool = -1,\n  Int = 0,\n  Float = 1,\n  List = 2,\n  String = 3,\n  DivertTarget = 4,\n  VariablePointer = 5,\n}\n","import { InkObject } from \"./Object\";\nimport { Container } from \"./Container\";\n\nexport class SearchResult {\n  public obj: InkObject | null = null;\n  public approximate: boolean = false;\n\n  get correctObj() {\n    return this.approximate ? null : this.obj;\n  }\n\n  get container() {\n    return this.obj instanceof Container ? this.obj : null;\n  }\n\n  public copy() {\n    let searchResult = new SearchResult();\n    searchResult.obj = this.obj;\n    searchResult.approximate = this.approximate;\n\n    return searchResult;\n  }\n}\n","import { StringValue } from \"./Value\";\nimport { throwNullException } from \"./NullException\";\nimport { StringBuilder } from \"./StringBuilder\";\nimport { INamedContent } from \"./INamedContent\";\nimport { InkObject } from \"./Object\";\nimport { SearchResult } from \"./SearchResult\";\nimport { Path } from \"./Path\";\nimport { Debug } from \"./Debug\";\nimport { tryGetValueFromMap } from \"./TryGetResult\";\nimport { asINamedContentOrNull, asOrNull, asOrThrows } from \"./TypeAssertion\";\n\nexport class Container extends InkObject implements INamedContent {\n  public name: string | null = null;\n\n  public _content: InkObject[] = [];\n  public namedContent: Map<string, INamedContent> = new Map();\n\n  public visitsShouldBeCounted: boolean = false;\n  public turnIndexShouldBeCounted: boolean = false;\n  public countingAtStartOnly: boolean = false;\n\n  public _pathToFirstLeafContent: Path | null = null;\n\n  get hasValidName() {\n    return this.name != null && this.name.length > 0;\n  }\n  get content() {\n    return this._content;\n  }\n  set content(value: InkObject[]) {\n    this.AddContent(value);\n  }\n  get namedOnlyContent() {\n    let namedOnlyContentDict: Map<string, InkObject> | null = new Map();\n\n    for (let [key, value] of this.namedContent) {\n      let inkObject = asOrThrows(value, InkObject);\n      namedOnlyContentDict.set(key, inkObject);\n    }\n\n    for (let c of this.content) {\n      let named = asINamedContentOrNull(c);\n      if (named != null && named.hasValidName) {\n        namedOnlyContentDict.delete(named.name!);\n      }\n    }\n\n    if (namedOnlyContentDict.size == 0) namedOnlyContentDict = null;\n\n    return namedOnlyContentDict;\n  }\n  set namedOnlyContent(value: Map<string, InkObject> | null) {\n    let existingNamedOnly = this.namedOnlyContent;\n    if (existingNamedOnly != null) {\n      for (let [key] of existingNamedOnly) {\n        this.namedContent.delete(key);\n      }\n    }\n\n    if (value == null) return;\n\n    for (let [, val] of value) {\n      let named = asINamedContentOrNull(val);\n      if (named != null) this.AddToNamedContentOnly(named);\n    }\n  }\n  get countFlags(): number {\n    let flags: Container.CountFlags = 0;\n    if (this.visitsShouldBeCounted) flags |= Container.CountFlags.Visits;\n    if (this.turnIndexShouldBeCounted) flags |= Container.CountFlags.Turns;\n    if (this.countingAtStartOnly) flags |= Container.CountFlags.CountStartOnly;\n\n    if (flags == Container.CountFlags.CountStartOnly) {\n      flags = 0;\n    }\n\n    return flags;\n  }\n  set countFlags(value: number) {\n    let flag: Container.CountFlags = value;\n    if ((flag & Container.CountFlags.Visits) > 0)\n      this.visitsShouldBeCounted = true;\n    if ((flag & Container.CountFlags.Turns) > 0)\n      this.turnIndexShouldBeCounted = true;\n    if ((flag & Container.CountFlags.CountStartOnly) > 0)\n      this.countingAtStartOnly = true;\n  }\n  get pathToFirstLeafContent() {\n    if (this._pathToFirstLeafContent == null)\n      this._pathToFirstLeafContent = this.path.PathByAppendingPath(\n        this.internalPathToFirstLeafContent\n      );\n\n    return this._pathToFirstLeafContent;\n  }\n  get internalPathToFirstLeafContent() {\n    let components: Path.Component[] = [];\n    let container: Container = this;\n    while (container instanceof Container) {\n      if (container.content.length > 0) {\n        components.push(new Path.Component(0));\n        container = container.content[0] as Container;\n      }\n    }\n    return new Path(components);\n  }\n\n  public AddContent(contentObjOrList: InkObject | InkObject[]) {\n    if (contentObjOrList instanceof Array) {\n      let contentList = contentObjOrList as InkObject[];\n\n      for (let c of contentList) {\n        this.AddContent(c);\n      }\n    } else {\n      let contentObj = contentObjOrList as InkObject;\n\n      this._content.push(contentObj);\n\n      if (contentObj.parent) {\n        throw new Error(\"content is already in \" + contentObj.parent);\n      }\n\n      contentObj.parent = this;\n\n      this.TryAddNamedContent(contentObj);\n    }\n  }\n  public TryAddNamedContent(contentObj: InkObject) {\n    let namedContentObj = asINamedContentOrNull(contentObj);\n    if (namedContentObj != null && namedContentObj.hasValidName) {\n      this.AddToNamedContentOnly(namedContentObj);\n    }\n  }\n  public AddToNamedContentOnly(namedContentObj: INamedContent) {\n    Debug.AssertType(\n      namedContentObj,\n      InkObject,\n      \"Can only add Runtime.Objects to a Runtime.Container\"\n    );\n    let runtimeObj = asOrThrows(namedContentObj, InkObject);\n    runtimeObj.parent = this;\n\n    if (namedContentObj.name === null)\n      return throwNullException(\"namedContentObj.name\");\n    this.namedContent.set(namedContentObj.name!, namedContentObj);\n  }\n  public ContentAtPath(\n    path: Path,\n    partialPathStart: number = 0,\n    partialPathLength: number = -1\n  ) {\n    if (partialPathLength == -1) partialPathLength = path.length;\n\n    let result = new SearchResult();\n    result.approximate = false;\n\n    let currentContainer: Container | null = this;\n    let currentObj: InkObject = this;\n\n    for (let i = partialPathStart; i < partialPathLength; ++i) {\n      let comp = path.GetComponent(i);\n      if (currentContainer == null) {\n        result.approximate = true;\n        break;\n      }\n\n      let foundObj: InkObject | null =\n        currentContainer.ContentWithPathComponent(comp);\n\n      if (foundObj == null) {\n        result.approximate = true;\n        break;\n      }\n\n      currentObj = foundObj;\n      currentContainer = asOrNull(foundObj, Container);\n    }\n\n    result.obj = currentObj;\n\n    return result;\n  }\n  public InsertContent(contentObj: InkObject, index: number) {\n    this.content.splice(index, 0, contentObj);\n\n    if (contentObj.parent) {\n      throw new Error(\"content is already in \" + contentObj.parent);\n    }\n\n    contentObj.parent = this;\n\n    this.TryAddNamedContent(contentObj);\n  }\n  public AddContentsOfContainer(otherContainer: Container) {\n    this.content.push(...otherContainer.content);\n\n    for (let obj of otherContainer.content) {\n      obj.parent = this;\n      this.TryAddNamedContent(obj);\n    }\n  }\n  public ContentWithPathComponent(component: Path.Component): InkObject | null {\n    if (component.isIndex) {\n      if (component.index >= 0 && component.index < this.content.length) {\n        return this.content[component.index];\n      } else {\n        return null;\n      }\n    } else if (component.isParent) {\n      return this.parent;\n    } else {\n      if (component.name === null) {\n        return throwNullException(\"component.name\");\n      }\n      let foundContent = tryGetValueFromMap(\n        this.namedContent,\n        component.name,\n        null\n      );\n      if (foundContent.exists) {\n        return asOrThrows(foundContent.result, InkObject);\n      } else {\n        return null;\n      }\n    }\n  }\n  public BuildStringOfHierarchy(): string;\n  public BuildStringOfHierarchy(\n    sb: StringBuilder,\n    indentation: number,\n    pointedObj: InkObject | null\n  ): string;\n  public BuildStringOfHierarchy() {\n    let sb: StringBuilder;\n    if (arguments.length == 0) {\n      sb = new StringBuilder();\n      this.BuildStringOfHierarchy(sb, 0, null);\n      return sb.toString();\n    }\n\n    sb = arguments[0] as StringBuilder;\n    let indentation = arguments[1] as number;\n    let pointedObj = arguments[2] as InkObject | null;\n\n    function appendIndentation() {\n      const spacesPerIndent = 4; // Truly const in the original code\n      for (let i = 0; i < spacesPerIndent * indentation; ++i) {\n        sb.Append(\" \");\n      }\n    }\n\n    appendIndentation();\n    sb.Append(\"[\");\n\n    if (this.hasValidName) {\n      sb.AppendFormat(\" ({0})\", this.name);\n    }\n\n    if (this == pointedObj) {\n      sb.Append(\"  <---\");\n    }\n\n    sb.AppendLine();\n\n    indentation++;\n\n    for (let i = 0; i < this.content.length; ++i) {\n      let obj = this.content[i];\n\n      if (obj instanceof Container) {\n        let container = obj as Container;\n\n        container.BuildStringOfHierarchy(sb, indentation, pointedObj);\n      } else {\n        appendIndentation();\n        if (obj instanceof StringValue) {\n          sb.Append('\"');\n          sb.Append(obj.toString().replace(\"\\n\", \"\\\\n\"));\n          sb.Append('\"');\n        } else {\n          sb.Append(obj.toString());\n        }\n      }\n\n      if (i != this.content.length - 1) {\n        sb.Append(\",\");\n      }\n\n      if (!(obj instanceof Container) && obj == pointedObj) {\n        sb.Append(\"  <---\");\n      }\n\n      sb.AppendLine();\n    }\n\n    let onlyNamed: Map<string, INamedContent> = new Map();\n\n    for (let [key, value] of this.namedContent) {\n      if (this.content.indexOf(asOrThrows(value, InkObject)) >= 0) {\n        continue;\n      } else {\n        onlyNamed.set(key, value);\n      }\n    }\n\n    if (onlyNamed.size > 0) {\n      appendIndentation();\n      sb.AppendLine(\"-- named: --\");\n\n      for (let [, value] of onlyNamed) {\n        Debug.AssertType(\n          value,\n          Container,\n          \"Can only print out named Containers\"\n        );\n        let container = value as Container;\n        container.BuildStringOfHierarchy(sb, indentation, pointedObj);\n        sb.AppendLine();\n      }\n    }\n\n    indentation--;\n\n    appendIndentation();\n    sb.Append(\"]\");\n  }\n}\n\nexport namespace Container {\n  export enum CountFlags {\n    Visits = 1,\n    Turns = 2,\n    CountStartOnly = 4,\n  }\n}\n","import { InkObject } from \"./Object\";\n\nexport class Glue extends InkObject {\n  public toString() {\n    return \"Glue\";\n  }\n}\n","export enum PushPopType {\n  Tunnel = 0,\n  Function = 1,\n  FunctionEvaluationFromGame = 2,\n}\n","import { InkObject } from \"./Object\";\n\nexport class ControlCommand extends InkObject {\n  private _commandType: ControlCommand.CommandType;\n\n  get commandType(): ControlCommand.CommandType {\n    return this._commandType;\n  }\n\n  constructor(\n    commandType: ControlCommand.CommandType = ControlCommand.CommandType.NotSet\n  ) {\n    super();\n    this._commandType = commandType;\n  }\n\n  public Copy() {\n    return new ControlCommand(this.commandType);\n  }\n  public static EvalStart() {\n    return new ControlCommand(ControlCommand.CommandType.EvalStart);\n  }\n  public static EvalOutput() {\n    return new ControlCommand(ControlCommand.CommandType.EvalOutput);\n  }\n  public static EvalEnd() {\n    return new ControlCommand(ControlCommand.CommandType.EvalEnd);\n  }\n  public static Duplicate() {\n    return new ControlCommand(ControlCommand.CommandType.Duplicate);\n  }\n  public static PopEvaluatedValue() {\n    return new ControlCommand(ControlCommand.CommandType.PopEvaluatedValue);\n  }\n  public static PopFunction() {\n    return new ControlCommand(ControlCommand.CommandType.PopFunction);\n  }\n  public static PopTunnel() {\n    return new ControlCommand(ControlCommand.CommandType.PopTunnel);\n  }\n  public static BeginString() {\n    return new ControlCommand(ControlCommand.CommandType.BeginString);\n  }\n  public static EndString() {\n    return new ControlCommand(ControlCommand.CommandType.EndString);\n  }\n  public static NoOp() {\n    return new ControlCommand(ControlCommand.CommandType.NoOp);\n  }\n  public static ChoiceCount() {\n    return new ControlCommand(ControlCommand.CommandType.ChoiceCount);\n  }\n  public static Turns() {\n    return new ControlCommand(ControlCommand.CommandType.Turns);\n  }\n  public static TurnsSince() {\n    return new ControlCommand(ControlCommand.CommandType.TurnsSince);\n  }\n  public static ReadCount() {\n    return new ControlCommand(ControlCommand.CommandType.ReadCount);\n  }\n  public static Random() {\n    return new ControlCommand(ControlCommand.CommandType.Random);\n  }\n  public static SeedRandom() {\n    return new ControlCommand(ControlCommand.CommandType.SeedRandom);\n  }\n  public static VisitIndex() {\n    return new ControlCommand(ControlCommand.CommandType.VisitIndex);\n  }\n  public static SequenceShuffleIndex() {\n    return new ControlCommand(ControlCommand.CommandType.SequenceShuffleIndex);\n  }\n  public static StartThread() {\n    return new ControlCommand(ControlCommand.CommandType.StartThread);\n  }\n  public static Done() {\n    return new ControlCommand(ControlCommand.CommandType.Done);\n  }\n  public static End() {\n    return new ControlCommand(ControlCommand.CommandType.End);\n  }\n  public static ListFromInt() {\n    return new ControlCommand(ControlCommand.CommandType.ListFromInt);\n  }\n  public static ListRange() {\n    return new ControlCommand(ControlCommand.CommandType.ListRange);\n  }\n  public static ListRandom() {\n    return new ControlCommand(ControlCommand.CommandType.ListRandom);\n  }\n  public static BeginTag() {\n    return new ControlCommand(ControlCommand.CommandType.BeginTag);\n  }\n  public static EndTag() {\n    return new ControlCommand(ControlCommand.CommandType.EndTag);\n  }\n  public toString() {\n    return this.commandType.toString();\n  }\n}\n\nexport namespace ControlCommand {\n  export enum CommandType {\n    NotSet = -1,\n    EvalStart, // 0\n    EvalOutput, // 1\n    EvalEnd, // 2\n    Duplicate, // 3\n    PopEvaluatedValue, // 4\n    PopFunction, // 5\n    PopTunnel, // 6\n    BeginString, // 7\n    EndString, // 8\n    NoOp, // 9\n    ChoiceCount, // 10\n    Turns, // 11\n    TurnsSince, // 12\n    ReadCount, // 13\n    Random, // 14\n    SeedRandom, // 15\n    VisitIndex, // 16\n    SequenceShuffleIndex, // 17\n    StartThread, // 18\n    Done, // 19\n    End, // 20\n    ListFromInt, // 21\n    ListRange, // 22\n    ListRandom, // 23\n    BeginTag, // 24\n    EndTag, // 25\n\n    TOTAL_VALUES,\n  }\n}\n","import { Path } from \"./Path\";\nimport { Container } from \"./Container\";\nimport { InkObject } from \"./Object\";\n\nexport class Pointer {\n  public container: Container | null = null;\n  public index: number = -1;\n\n  constructor();\n  constructor(container: Container | null, index: number);\n  constructor() {\n    if (arguments.length === 2) {\n      this.container = arguments[0];\n      this.index = arguments[1];\n    }\n  }\n\n  public Resolve(): InkObject | null {\n    if (this.index < 0) return this.container;\n    if (this.container == null) return null;\n    if (this.container.content.length == 0) return this.container;\n    if (this.index >= this.container.content.length) return null;\n\n    return this.container.content[this.index];\n  }\n\n  get isNull(): boolean {\n    return this.container == null;\n  }\n\n  get path(): Path | null {\n    if (this.isNull) return null;\n\n    if (this.index >= 0)\n      return this.container!.path.PathByAppendingComponent(\n        new Path.Component(this.index)\n      );\n    else return this.container!.path;\n  }\n\n  public toString(): string {\n    if (!this.container) return \"Ink Pointer (null)\";\n\n    return (\n      \"Ink Pointer -> \" +\n      this.container.path.toString() +\n      \" -- index \" +\n      this.index\n    );\n  }\n\n  // This method does not exist in the original C# code, but is here to maintain the\n  // value semantics of Pointer.\n  public copy(): Pointer {\n    return new Pointer(this.container, this.index);\n  }\n\n  public static StartOf(container: Container | null): Pointer {\n    return new Pointer(container, 0);\n  }\n\n  public static get Null(): Pointer {\n    return new Pointer(null, -1);\n  }\n}\n","import { Path } from \"./Path\";\nimport { PushPopType } from \"./PushPop\";\nimport { StringBuilder } from \"./StringBuilder\";\nimport { InkObject } from \"./Object\";\nimport { Pointer } from \"./Pointer\";\nimport { Container } from \"./Container\";\nimport { throwNullException } from \"./NullException\";\n\nexport class Divert extends InkObject {\n  get targetPath() {\n    if (this._targetPath != null && this._targetPath.isRelative) {\n      let targetObj = this.targetPointer.Resolve();\n      if (targetObj) {\n        this._targetPath = targetObj.path;\n      }\n    }\n\n    return this._targetPath;\n  }\n  set targetPath(value: Path | null) {\n    this._targetPath = value;\n    this._targetPointer = Pointer.Null;\n  }\n\n  public _targetPath: Path | null = null;\n\n  get targetPointer() {\n    if (this._targetPointer.isNull) {\n      let targetObj = this.ResolvePath(this._targetPath).obj;\n\n      if (this._targetPath === null)\n        return throwNullException(\"this._targetPath\");\n      if (this._targetPath.lastComponent === null)\n        return throwNullException(\"this._targetPath.lastComponent\");\n\n      if (this._targetPath.lastComponent.isIndex) {\n        if (targetObj === null) return throwNullException(\"targetObj\");\n        this._targetPointer.container =\n          targetObj.parent instanceof Container ? targetObj.parent : null;\n        this._targetPointer.index = this._targetPath.lastComponent.index;\n      } else {\n        this._targetPointer = Pointer.StartOf(\n          targetObj instanceof Container ? targetObj : null\n        );\n      }\n    }\n\n    return this._targetPointer.copy();\n  }\n\n  public _targetPointer: Pointer = Pointer.Null;\n\n  get targetPathString() {\n    if (this.targetPath == null) return null;\n\n    return this.CompactPathString(this.targetPath);\n  }\n  set targetPathString(value: string | null) {\n    if (value == null) {\n      this.targetPath = null;\n    } else {\n      this.targetPath = new Path(value);\n    }\n  }\n\n  public variableDivertName: string | null = null;\n  get hasVariableTarget() {\n    return this.variableDivertName != null;\n  }\n\n  public pushesToStack: boolean = false;\n  public stackPushType: PushPopType = 0;\n\n  public isExternal: boolean = false;\n  public externalArgs: number = 0;\n\n  public isConditional: boolean = false;\n\n  constructor(stackPushType?: PushPopType) {\n    super();\n    this.pushesToStack = false;\n\n    if (typeof stackPushType !== \"undefined\") {\n      this.pushesToStack = true;\n      this.stackPushType = stackPushType;\n    }\n  }\n\n  public Equals(obj: Divert | null) {\n    let otherDivert = obj;\n    if (otherDivert instanceof Divert) {\n      if (this.hasVariableTarget == otherDivert.hasVariableTarget) {\n        if (this.hasVariableTarget) {\n          return this.variableDivertName == otherDivert.variableDivertName;\n        } else {\n          if (this.targetPath === null)\n            return throwNullException(\"this.targetPath\");\n          return this.targetPath.Equals(otherDivert.targetPath);\n        }\n      }\n    }\n    return false;\n  }\n\n  public toString() {\n    if (this.hasVariableTarget) {\n      return \"Divert(variable: \" + this.variableDivertName + \")\";\n    } else if (this.targetPath == null) {\n      return \"Divert(null)\";\n    } else {\n      let sb = new StringBuilder();\n\n      let targetStr = this.targetPath.toString();\n      // int? targetLineNum = DebugLineNumberOfPath (targetPath);\n      let targetLineNum = null;\n      if (targetLineNum != null) {\n        targetStr = \"line \" + targetLineNum;\n      }\n\n      sb.Append(\"Divert\");\n\n      if (this.isConditional) sb.Append(\"?\");\n\n      if (this.pushesToStack) {\n        if (this.stackPushType == PushPopType.Function) {\n          sb.Append(\" function\");\n        } else {\n          sb.Append(\" tunnel\");\n        }\n      }\n\n      sb.Append(\" -> \");\n      sb.Append(this.targetPathString);\n\n      sb.Append(\" (\");\n      sb.Append(targetStr);\n      sb.Append(\")\");\n\n      return sb.toString();\n    }\n  }\n}\n","import { InkObject } from \"./Object\";\nimport { Path } from \"./Path\";\nimport { Container } from \"./Container\";\nimport { throwNullException } from \"./NullException\";\n\nexport class ChoicePoint extends InkObject {\n  public _pathOnChoice: Path | null = null;\n  public hasCondition: boolean = false;\n  public hasStartContent: boolean = false;\n  public hasChoiceOnlyContent: boolean = false;\n  public isInvisibleDefault: boolean = false;\n  public onceOnly: boolean = true;\n\n  constructor(onceOnly: boolean = true) {\n    super();\n    this.onceOnly = onceOnly;\n  }\n  get pathOnChoice(): Path | null {\n    if (this._pathOnChoice != null && this._pathOnChoice.isRelative) {\n      let choiceTargetObj = this.choiceTarget;\n      if (choiceTargetObj) {\n        this._pathOnChoice = choiceTargetObj.path;\n      }\n    }\n    return this._pathOnChoice;\n  }\n  set pathOnChoice(value: Path | null) {\n    this._pathOnChoice = value;\n  }\n  get choiceTarget(): Container | null {\n    if (this._pathOnChoice === null)\n      return throwNullException(\"ChoicePoint._pathOnChoice\");\n    return this.ResolvePath(this._pathOnChoice).container;\n  }\n  get pathStringOnChoice(): string {\n    if (this.pathOnChoice === null)\n      return throwNullException(\"ChoicePoint.pathOnChoice\");\n    return this.CompactPathString(this.pathOnChoice);\n  }\n  set pathStringOnChoice(value: string) {\n    this.pathOnChoice = new Path(value);\n  }\n  get flags(): number {\n    let flags = 0;\n    if (this.hasCondition) flags |= 1;\n    if (this.hasStartContent) flags |= 2;\n    if (this.hasChoiceOnlyContent) flags |= 4;\n    if (this.isInvisibleDefault) flags |= 8;\n    if (this.onceOnly) flags |= 16;\n    return flags;\n  }\n  set flags(value: number) {\n    this.hasCondition = (value & 1) > 0;\n    this.hasStartContent = (value & 2) > 0;\n    this.hasChoiceOnlyContent = (value & 4) > 0;\n    this.isInvisibleDefault = (value & 8) > 0;\n    this.onceOnly = (value & 16) > 0;\n  }\n  public toString(): string {\n    if (this.pathOnChoice === null)\n      return throwNullException(\"ChoicePoint.pathOnChoice\");\n    // int? targetLineNum = DebugLineNumberOfPath (pathOnChoice);\n    let targetLineNum = null;\n    let targetString = this.pathOnChoice.toString();\n\n    if (targetLineNum != null) {\n      targetString = \" line \" + targetLineNum + \"(\" + targetString + \")\";\n    }\n\n    return \"Choice: -> \" + targetString;\n  }\n}\n","import { InkObject } from \"./Object\";\nimport { Path } from \"./Path\";\n\nexport class VariableReference extends InkObject {\n  public name: string | null;\n  public pathForCount: Path | null = null;\n\n  get containerForCount() {\n    if (this.pathForCount === null) return null;\n    return this.ResolvePath(this.pathForCount).container;\n  }\n  get pathStringForCount() {\n    if (this.pathForCount === null) return null;\n\n    return this.CompactPathString(this.pathForCount);\n  }\n  set pathStringForCount(value: string | null) {\n    if (value === null) this.pathForCount = null;\n    else this.pathForCount = new Path(value);\n  }\n\n  constructor(name: string | null = null) {\n    super();\n    this.name = name;\n  }\n\n  public toString() {\n    if (this.name != null) {\n      return \"var(\" + this.name + \")\";\n    } else {\n      let pathStr = this.pathStringForCount;\n      return \"read_count(\" + pathStr + \")\";\n    }\n  }\n}\n","import { InkObject } from \"./Object\";\n\nexport class VariableAssignment extends InkObject {\n  public readonly variableName: string | null;\n  public readonly isNewDeclaration: boolean;\n  public isGlobal: boolean;\n\n  constructor(variableName: string | null, isNewDeclaration: boolean) {\n    super();\n    this.variableName = variableName || null;\n    this.isNewDeclaration = !!isNewDeclaration;\n    this.isGlobal = false;\n  }\n\n  public toString(): string {\n    return \"VarAssign to \" + this.variableName;\n  }\n}\n","import { InkObject } from \"./Object\";\n\nexport class Void extends InkObject {}\n","import { Value, ValueType, IntValue, ListValue, BoolValue } from \"./Value\";\nimport { StoryException } from \"./StoryException\";\nimport { Void } from \"./Void\";\nimport { Path } from \"./Path\";\nimport { InkList, InkListItem } from \"./InkList\";\nimport { InkObject } from \"./Object\";\nimport { asOrNull, asOrThrows, asBooleanOrThrows } from \"./TypeAssertion\";\nimport { throwNullException } from \"./NullException\";\n\ntype BinaryOp<T> = (left: T, right: T) => any;\ntype UnaryOp<T> = (val: T) => any;\n\nexport class NativeFunctionCall extends InkObject {\n  public static readonly Add: string = \"+\";\n  public static readonly Subtract: string = \"-\";\n  public static readonly Divide: string = \"/\";\n  public static readonly Multiply: string = \"*\";\n  public static readonly Mod: string = \"%\";\n  public static readonly Negate: string = \"_\";\n  public static readonly Equal: string = \"==\";\n  public static readonly Greater: string = \">\";\n  public static readonly Less: string = \"<\";\n  public static readonly GreaterThanOrEquals: string = \">=\";\n  public static readonly LessThanOrEquals: string = \"<=\";\n  public static readonly NotEquals: string = \"!=\";\n  public static readonly Not: string = \"!\";\n  public static readonly And: string = \"&&\";\n  public static readonly Or: string = \"||\";\n  public static readonly Min: string = \"MIN\";\n  public static readonly Max: string = \"MAX\";\n  public static readonly Pow: string = \"POW\";\n  public static readonly Floor: string = \"FLOOR\";\n  public static readonly Ceiling: string = \"CEILING\";\n  public static readonly Int: string = \"INT\";\n  public static readonly Float: string = \"FLOAT\";\n  public static readonly Has: string = \"?\";\n  public static readonly Hasnt: string = \"!?\";\n  public static readonly Intersect: string = \"^\";\n  public static readonly ListMin: string = \"LIST_MIN\";\n  public static readonly ListMax: string = \"LIST_MAX\";\n  public static readonly All: string = \"LIST_ALL\";\n  public static readonly Count: string = \"LIST_COUNT\";\n  public static readonly ValueOfList: string = \"LIST_VALUE\";\n  public static readonly Invert: string = \"LIST_INVERT\";\n\n  public static CallWithName(functionName: string) {\n    return new NativeFunctionCall(functionName);\n  }\n\n  public static CallExistsWithName(functionName: string) {\n    this.GenerateNativeFunctionsIfNecessary();\n    return this._nativeFunctions!.get(functionName);\n  }\n\n  get name() {\n    if (this._name === null)\n      return throwNullException(\"NativeFunctionCall._name\");\n    return this._name;\n  }\n  set name(value: string) {\n    this._name = value;\n    if (!this._isPrototype) {\n      if (NativeFunctionCall._nativeFunctions === null)\n        throwNullException(\"NativeFunctionCall._nativeFunctions\");\n      else\n        this._prototype =\n          NativeFunctionCall._nativeFunctions.get(this._name) || null;\n    }\n  }\n  public _name: string | null = null;\n\n  get numberOfParameters() {\n    if (this._prototype) {\n      return this._prototype.numberOfParameters;\n    } else {\n      return this._numberOfParameters;\n    }\n  }\n  set numberOfParameters(value: number) {\n    this._numberOfParameters = value;\n  }\n  public _numberOfParameters: number = 0;\n\n  public Call(parameters: InkObject[]): InkObject | null {\n    if (this._prototype) {\n      return this._prototype.Call(parameters);\n    }\n\n    if (this.numberOfParameters != parameters.length) {\n      throw new Error(\"Unexpected number of parameters\");\n    }\n\n    let hasList = false;\n    for (let p of parameters) {\n      if (p instanceof Void)\n        throw new StoryException(\n          'Attempting to perform operation on a void value. Did you forget to \"return\" a value from a function you called here?'\n        );\n      if (p instanceof ListValue) hasList = true;\n    }\n\n    if (parameters.length == 2 && hasList) {\n      return this.CallBinaryListOperation(parameters);\n    }\n\n    let coercedParams = this.CoerceValuesToSingleType(parameters);\n    let coercedType = coercedParams[0].valueType;\n\n    if (coercedType == ValueType.Int) {\n      return this.CallType<number>(coercedParams);\n    } else if (coercedType == ValueType.Float) {\n      return this.CallType<number>(coercedParams);\n    } else if (coercedType == ValueType.String) {\n      return this.CallType<string>(coercedParams);\n    } else if (coercedType == ValueType.DivertTarget) {\n      return this.CallType<Path>(coercedParams);\n    } else if (coercedType == ValueType.List) {\n      return this.CallType<InkList>(coercedParams);\n    }\n\n    return null;\n  }\n\n  public CallType<T extends { toString: () => string; }>(parametersOfSingleType: Array<Value<T>>) {\n    let param1 = asOrThrows(parametersOfSingleType[0], Value);\n    let valType = param1.valueType;\n\n    let val1 = param1 as Value<T>;\n\n    let paramCount = parametersOfSingleType.length;\n\n    if (paramCount == 2 || paramCount == 1) {\n      if (this._operationFuncs === null)\n        return throwNullException(\"NativeFunctionCall._operationFuncs\");\n      let opForTypeObj = this._operationFuncs.get(valType);\n      if (!opForTypeObj) {\n        const key = ValueType[valType];\n        throw new StoryException(\n          \"Cannot perform operation \" + this.name + \" on \" + key\n        );\n      }\n\n      if (paramCount == 2) {\n        let param2 = asOrThrows(parametersOfSingleType[1], Value);\n\n        let val2 = param2 as Value<T>;\n\n        let opForType = opForTypeObj as BinaryOp<T>;\n\n        if (val1.value === null || val2.value === null)\n          return throwNullException(\"NativeFunctionCall.Call BinaryOp values\");\n        let resultVal = opForType(val1.value, val2.value);\n\n        return Value.Create(resultVal);\n      } else {\n        let opForType = opForTypeObj as UnaryOp<T>;\n\n        if (val1.value === null)\n          return throwNullException(\"NativeFunctionCall.Call UnaryOp value\");\n        let resultVal = opForType(val1.value);\n\n        // This code is different from upstream. Since JavaScript treats\n        // integers and floats as the same numbers, it's impossible\n        // to force an number to be either an integer or a float.\n        //\n        // It can be useful to force a specific number type\n        // (especially for divisions), so the result of INT() & FLOAT()\n        // is coerced to the the proper value type.\n        //\n        // Note that we also force all other unary operation to\n        // return the same value type, although this is only\n        // meaningful for numbers. See `Value.Create`.\n        if (this.name === NativeFunctionCall.Int) {\n          return Value.Create(resultVal, ValueType.Int);\n        } else if (this.name === NativeFunctionCall.Float) {\n          return Value.Create(resultVal, ValueType.Float);\n        } else {\n          return Value.Create(resultVal, param1.valueType);\n        }\n      }\n    } else {\n      throw new Error(\n        \"Unexpected number of parameters to NativeFunctionCall: \" +\n          parametersOfSingleType.length\n      );\n    }\n  }\n\n  public CallBinaryListOperation(parameters: InkObject[]) {\n    if (\n      (this.name == \"+\" || this.name == \"-\") &&\n      parameters[0] instanceof ListValue &&\n      parameters[1] instanceof IntValue\n    )\n      return this.CallListIncrementOperation(parameters);\n\n    let v1 = asOrThrows(parameters[0], Value);\n    let v2 = asOrThrows(parameters[1], Value);\n\n    if (\n      (this.name == \"&&\" || this.name == \"||\") &&\n      (v1.valueType != ValueType.List || v2.valueType != ValueType.List)\n    ) {\n      if (this._operationFuncs === null)\n        return throwNullException(\"NativeFunctionCall._operationFuncs\");\n      let op = this._operationFuncs.get(ValueType.Int) as BinaryOp<number>;\n      if (op === null)\n        return throwNullException(\n          \"NativeFunctionCall.CallBinaryListOperation op\"\n        );\n      let result = asBooleanOrThrows(\n        op(v1.isTruthy ? 1 : 0, v2.isTruthy ? 1 : 0)\n      );\n      return new BoolValue(result);\n    }\n\n    if (v1.valueType == ValueType.List && v2.valueType == ValueType.List)\n      return this.CallType<InkList>([v1, v2]);\n\n    throw new StoryException(\n      \"Can not call use \" +\n        this.name +\n        \" operation on \" +\n        ValueType[v1.valueType] +\n        \" and \" +\n        ValueType[v2.valueType]\n    );\n  }\n\n  public CallListIncrementOperation(listIntParams: InkObject[]) {\n    let listVal = asOrThrows(listIntParams[0], ListValue);\n    let intVal = asOrThrows(listIntParams[1], IntValue);\n\n    let resultInkList = new InkList();\n\n    if (listVal.value === null)\n      return throwNullException(\n        \"NativeFunctionCall.CallListIncrementOperation listVal.value\"\n      );\n    for (let [listItemKey, listItemValue] of listVal.value) {\n      let listItem = InkListItem.fromSerializedKey(listItemKey);\n\n      if (this._operationFuncs === null)\n        return throwNullException(\"NativeFunctionCall._operationFuncs\");\n      let intOp = this._operationFuncs.get(ValueType.Int) as BinaryOp<number>;\n\n      if (intVal.value === null)\n        return throwNullException(\n          \"NativeFunctionCall.CallListIncrementOperation intVal.value\"\n        );\n      let targetInt = intOp(listItemValue, intVal.value);\n\n      let itemOrigin = null;\n      if (listVal.value.origins === null)\n        return throwNullException(\n          \"NativeFunctionCall.CallListIncrementOperation listVal.value.origins\"\n        );\n      for (let origin of listVal.value.origins) {\n        if (origin.name == listItem.originName) {\n          itemOrigin = origin;\n          break;\n        }\n      }\n      if (itemOrigin != null) {\n        let incrementedItem = itemOrigin.TryGetItemWithValue(\n          targetInt,\n          InkListItem.Null\n        );\n        if (incrementedItem.exists)\n          resultInkList.Add(incrementedItem.result, targetInt);\n      }\n    }\n\n    return new ListValue(resultInkList);\n  }\n\n  public CoerceValuesToSingleType(parametersIn: InkObject[]) {\n    let valType = ValueType.Int;\n\n    let specialCaseList: null | ListValue = null;\n\n    for (let obj of parametersIn) {\n      let val = asOrThrows(obj, Value);\n      if (val.valueType > valType) {\n        valType = val.valueType;\n      }\n\n      if (val.valueType == ValueType.List) {\n        specialCaseList = asOrNull(val, ListValue);\n      }\n    }\n\n    let parametersOut = [];\n\n    if (ValueType[valType] == ValueType[ValueType.List]) {\n      for (let inkObjectVal of parametersIn) {\n        let val = asOrThrows(inkObjectVal, Value);\n        if (val.valueType == ValueType.List) {\n          parametersOut.push(val);\n        } else if (val.valueType == ValueType.Int) {\n          let intVal = parseInt(val.valueObject);\n\n          specialCaseList = asOrThrows(specialCaseList, ListValue);\n          if (specialCaseList.value === null)\n            return throwNullException(\n              \"NativeFunctionCall.CoerceValuesToSingleType specialCaseList.value\"\n            );\n          let list = specialCaseList.value.originOfMaxItem;\n\n          if (list === null)\n            return throwNullException(\n              \"NativeFunctionCall.CoerceValuesToSingleType list\"\n            );\n          let item = list.TryGetItemWithValue(intVal, InkListItem.Null);\n          if (item.exists) {\n            let castedValue = new ListValue(item.result, intVal);\n            parametersOut.push(castedValue);\n          } else\n            throw new StoryException(\n              \"Could not find List item with the value \" +\n                intVal +\n                \" in \" +\n                list.name\n            );\n        } else {\n          const key = ValueType[val.valueType];\n          throw new StoryException(\n            \"Cannot mix Lists and \" + key + \" values in this operation\"\n          );\n        }\n      }\n    } else {\n      for (let inkObjectVal of parametersIn) {\n        let val = asOrThrows(inkObjectVal, Value);\n        let castedValue = val.Cast(valType);\n        parametersOut.push(castedValue);\n      }\n    }\n\n    return parametersOut;\n  }\n\n  constructor(name: string);\n  constructor(name: string, numberOfParameters: number);\n  constructor();\n  constructor() {\n    super();\n\n    if (arguments.length === 0) {\n      NativeFunctionCall.GenerateNativeFunctionsIfNecessary();\n    } else if (arguments.length === 1) {\n      let name = arguments[0];\n      NativeFunctionCall.GenerateNativeFunctionsIfNecessary();\n      this.name = name;\n    } else if (arguments.length === 2) {\n      let name = arguments[0];\n      let numberOfParameters = arguments[1];\n\n      this._isPrototype = true;\n      this.name = name;\n      this.numberOfParameters = numberOfParameters;\n    }\n  }\n\n  public static Identity<T>(t: T): any {\n    return t;\n  }\n\n  public static GenerateNativeFunctionsIfNecessary() {\n    if (this._nativeFunctions == null) {\n      this._nativeFunctions = new Map();\n\n      // Int operations\n      this.AddIntBinaryOp(this.Add, (x, y) => x + y);\n      this.AddIntBinaryOp(this.Subtract, (x, y) => x - y);\n      this.AddIntBinaryOp(this.Multiply, (x, y) => x * y);\n      this.AddIntBinaryOp(this.Divide, (x, y) => Math.floor(x / y));\n      this.AddIntBinaryOp(this.Mod, (x, y) => x % y);\n      this.AddIntUnaryOp(this.Negate, (x) => -x);\n\n      this.AddIntBinaryOp(this.Equal, (x, y) => x == y);\n      this.AddIntBinaryOp(this.Greater, (x, y) => x > y);\n      this.AddIntBinaryOp(this.Less, (x, y) => x < y);\n      this.AddIntBinaryOp(this.GreaterThanOrEquals, (x, y) => x >= y);\n      this.AddIntBinaryOp(this.LessThanOrEquals, (x, y) => x <= y);\n      this.AddIntBinaryOp(this.NotEquals, (x, y) => x != y);\n      this.AddIntUnaryOp(this.Not, (x) => x == 0);\n\n      this.AddIntBinaryOp(this.And, (x, y) => x != 0 && y != 0);\n      this.AddIntBinaryOp(this.Or, (x, y) => x != 0 || y != 0);\n\n      this.AddIntBinaryOp(this.Max, (x, y) => Math.max(x, y));\n      this.AddIntBinaryOp(this.Min, (x, y) => Math.min(x, y));\n\n      this.AddIntBinaryOp(this.Pow, (x, y) => Math.pow(x, y));\n      this.AddIntUnaryOp(this.Floor, NativeFunctionCall.Identity);\n      this.AddIntUnaryOp(this.Ceiling, NativeFunctionCall.Identity);\n      this.AddIntUnaryOp(this.Int, NativeFunctionCall.Identity);\n      this.AddIntUnaryOp(this.Float, (x) => x);\n\n      // Float operations\n      this.AddFloatBinaryOp(this.Add, (x, y) => x + y);\n      this.AddFloatBinaryOp(this.Subtract, (x, y) => x - y);\n      this.AddFloatBinaryOp(this.Multiply, (x, y) => x * y);\n      this.AddFloatBinaryOp(this.Divide, (x, y) => x / y);\n      this.AddFloatBinaryOp(this.Mod, (x, y) => x % y);\n      this.AddFloatUnaryOp(this.Negate, (x) => -x);\n\n      this.AddFloatBinaryOp(this.Equal, (x, y) => x == y);\n      this.AddFloatBinaryOp(this.Greater, (x, y) => x > y);\n      this.AddFloatBinaryOp(this.Less, (x, y) => x < y);\n      this.AddFloatBinaryOp(this.GreaterThanOrEquals, (x, y) => x >= y);\n      this.AddFloatBinaryOp(this.LessThanOrEquals, (x, y) => x <= y);\n      this.AddFloatBinaryOp(this.NotEquals, (x, y) => x != y);\n      this.AddFloatUnaryOp(this.Not, (x) => x == 0.0);\n\n      this.AddFloatBinaryOp(this.And, (x, y) => x != 0.0 && y != 0.0);\n      this.AddFloatBinaryOp(this.Or, (x, y) => x != 0.0 || y != 0.0);\n\n      this.AddFloatBinaryOp(this.Max, (x, y) => Math.max(x, y));\n      this.AddFloatBinaryOp(this.Min, (x, y) => Math.min(x, y));\n\n      this.AddFloatBinaryOp(this.Pow, (x, y) => Math.pow(x, y));\n      this.AddFloatUnaryOp(this.Floor, (x) => Math.floor(x));\n      this.AddFloatUnaryOp(this.Ceiling, (x) => Math.ceil(x));\n      this.AddFloatUnaryOp(this.Int, (x) => Math.floor(x));\n      this.AddFloatUnaryOp(this.Float, NativeFunctionCall.Identity);\n\n      // String operations\n      this.AddStringBinaryOp(this.Add, (x, y) => x + y); // concat\n      this.AddStringBinaryOp(this.Equal, (x, y) => x === y);\n      this.AddStringBinaryOp(this.NotEquals, (x, y) => !(x === y));\n      this.AddStringBinaryOp(this.Has, (x, y) => x.includes(y));\n      this.AddStringBinaryOp(this.Hasnt, (x, y) => !x.includes(y));\n\n      this.AddListBinaryOp(this.Add, (x, y) => x.Union(y));\n      this.AddListBinaryOp(this.Subtract, (x, y) => x.Without(y));\n      this.AddListBinaryOp(this.Has, (x, y) => x.Contains(y));\n      this.AddListBinaryOp(this.Hasnt, (x, y) => !x.Contains(y));\n      this.AddListBinaryOp(this.Intersect, (x, y) => x.Intersect(y));\n\n      this.AddListBinaryOp(this.Equal, (x, y) => x.Equals(y));\n      this.AddListBinaryOp(this.Greater, (x, y) => x.GreaterThan(y));\n      this.AddListBinaryOp(this.Less, (x, y) => x.LessThan(y));\n      this.AddListBinaryOp(this.GreaterThanOrEquals, (x, y) =>\n        x.GreaterThanOrEquals(y)\n      );\n      this.AddListBinaryOp(this.LessThanOrEquals, (x, y) =>\n        x.LessThanOrEquals(y)\n      );\n      this.AddListBinaryOp(this.NotEquals, (x, y) => !x.Equals(y));\n\n      this.AddListBinaryOp(this.And, (x, y) => x.Count > 0 && y.Count > 0);\n      this.AddListBinaryOp(this.Or, (x, y) => x.Count > 0 || y.Count > 0);\n\n      this.AddListUnaryOp(this.Not, (x) => (x.Count == 0 ? 1 : 0));\n\n      this.AddListUnaryOp(this.Invert, (x) => x.inverse);\n      this.AddListUnaryOp(this.All, (x) => x.all);\n      this.AddListUnaryOp(this.ListMin, (x) => x.MinAsList());\n      this.AddListUnaryOp(this.ListMax, (x) => x.MaxAsList());\n      this.AddListUnaryOp(this.Count, (x) => x.Count);\n      this.AddListUnaryOp(this.ValueOfList, (x) => x.maxItem.Value);\n\n      let divertTargetsEqual = (d1: Path, d2: Path) => d1.Equals(d2);\n      let divertTargetsNotEqual = (d1: Path, d2: Path) => !d1.Equals(d2);\n      this.AddOpToNativeFunc(\n        this.Equal,\n        2,\n        ValueType.DivertTarget,\n        divertTargetsEqual\n      );\n      this.AddOpToNativeFunc(\n        this.NotEquals,\n        2,\n        ValueType.DivertTarget,\n        divertTargetsNotEqual\n      );\n    }\n  }\n\n  public AddOpFuncForType(\n    valType: ValueType,\n    op: UnaryOp<number | InkList> | BinaryOp<number | string | InkList | Path>\n  ): void {\n    if (this._operationFuncs == null) {\n      this._operationFuncs = new Map();\n    }\n\n    this._operationFuncs.set(valType, op);\n  }\n\n  public static AddOpToNativeFunc(\n    name: string,\n    args: number,\n    valType: ValueType,\n    op: UnaryOp<any> | BinaryOp<any>\n  ): void {\n    if (this._nativeFunctions === null)\n      return throwNullException(\"NativeFunctionCall._nativeFunctions\");\n    let nativeFunc = this._nativeFunctions.get(name);\n    if (!nativeFunc) {\n      nativeFunc = new NativeFunctionCall(name, args);\n      this._nativeFunctions.set(name, nativeFunc);\n    }\n\n    nativeFunc.AddOpFuncForType(valType, op);\n  }\n\n  public static AddIntBinaryOp(name: string, op: BinaryOp<number>) {\n    this.AddOpToNativeFunc(name, 2, ValueType.Int, op);\n  }\n  public static AddIntUnaryOp(name: string, op: UnaryOp<number>) {\n    this.AddOpToNativeFunc(name, 1, ValueType.Int, op);\n  }\n\n  public static AddFloatBinaryOp(name: string, op: BinaryOp<number>) {\n    this.AddOpToNativeFunc(name, 2, ValueType.Float, op);\n  }\n  public static AddFloatUnaryOp(name: string, op: UnaryOp<number>) {\n    this.AddOpToNativeFunc(name, 1, ValueType.Float, op);\n  }\n\n  public static AddStringBinaryOp(name: string, op: BinaryOp<string>) {\n    this.AddOpToNativeFunc(name, 2, ValueType.String, op);\n  }\n\n  public static AddListBinaryOp(name: string, op: BinaryOp<InkList>) {\n    this.AddOpToNativeFunc(name, 2, ValueType.List, op);\n  }\n  public static AddListUnaryOp(name: string, op: UnaryOp<InkList>) {\n    this.AddOpToNativeFunc(name, 1, ValueType.List, op);\n  }\n\n  public toString() {\n    return 'Native \"' + this.name + '\"';\n  }\n\n  public _prototype: NativeFunctionCall | null = null;\n  public _isPrototype: boolean = false;\n  public _operationFuncs: Map<ValueType, BinaryOp<any> | UnaryOp<any>> | null =\n    null;\n  public static _nativeFunctions: Map<string, NativeFunctionCall> | null = null;\n}\n","import { InkObject } from \"./Object\";\n\n// New version of tags is dynamic - it constructs the tags\n// at runtime based on BeginTag and EndTag control commands.\n// Plain text that's in the output stream is turned into tags\n// when you do story.currentTags.\n// The only place this is used is when flattening tags down\n// to string in advance, during dynamic string generation if\n// there's a tag embedded in it. See how ControlCommand.EndString\n// is implemented in Story.cs for more details + comment\nexport class Tag extends InkObject {\n  public readonly text: string;\n\n  constructor(tagText: string) {\n    super();\n    this.text = tagText.toString() || \"\";\n  }\n\n  public toString(): string {\n    return \"# \" + this.text;\n  }\n}\n","import { Path } from \"./Path\";\nimport { CallStack } from \"./CallStack\";\nimport { throwNullException } from \"./NullException\";\nimport { InkObject } from \"./Object\";\n\nexport class Choice extends InkObject {\n  public text: string = \"\";\n  public index: number = 0;\n  public threadAtGeneration: CallStack.Thread | null = null;\n  public sourcePath: string = \"\";\n  public targetPath: Path | null = null;\n  public isInvisibleDefault: boolean = false;\n  public tags: string[] | null = null;\n  public originalThreadIndex: number = 0;\n\n  get pathStringOnChoice(): string {\n    if (this.targetPath === null)\n      return throwNullException(\"Choice.targetPath\");\n    return this.targetPath.toString();\n  }\n  set pathStringOnChoice(value: string) {\n    this.targetPath = new Path(value);\n  }\n}\n","import { InkListItem, SerializedInkListItem } from \"./InkList\";\nimport { TryGetResult } from \"./TryGetResult\";\n\nexport class ListDefinition {\n  public _name: string;\n  public _items: Map<SerializedInkListItem, number> | null;\n  public _itemNameToValues: Map<string, number>;\n\n  constructor(name: string, items: Map<string, number> | null) {\n    this._name = name || \"\";\n    this._items = null;\n    this._itemNameToValues = items || new Map();\n  }\n  get name() {\n    return this._name;\n  }\n  get items() {\n    if (this._items == null) {\n      this._items = new Map();\n      for (let [key, value] of this._itemNameToValues) {\n        let item = new InkListItem(this.name, key);\n        this._items.set(item.serialized(), value);\n      }\n    }\n\n    return this._items;\n  }\n\n  public ValueForItem(item: InkListItem) {\n    if (!item.itemName) return 0;\n\n    let intVal = this._itemNameToValues.get(item.itemName);\n    if (typeof intVal !== \"undefined\") return intVal;\n    else return 0;\n  }\n  public ContainsItem(item: InkListItem) {\n    if (!item.itemName) return false;\n    if (item.originName != this.name) return false;\n\n    return this._itemNameToValues.has(item.itemName);\n  }\n  public ContainsItemWithName(itemName: string) {\n    return this._itemNameToValues.has(itemName);\n  }\n  public TryGetItemWithValue(\n    val: number,\n    /* out */ item: InkListItem\n  ): TryGetResult<InkListItem> {\n    for (let [key, value] of this._itemNameToValues) {\n      if (value == val) {\n        item = new InkListItem(this.name, key);\n        return { result: item, exists: true };\n      }\n    }\n\n    item = InkListItem.Null;\n    return { result: item, exists: false };\n  }\n  public TryGetValueForItem(\n    item: InkListItem,\n    /* out */ intVal: number\n  ): TryGetResult<number> {\n    if (!item.itemName) return { result: 0, exists: false };\n    let value = this._itemNameToValues.get(item.itemName);\n\n    if (!value) return { result: 0, exists: false };\n    return { result: value, exists: true };\n  }\n}\n","import { InkListItem } from \"./InkList\";\nimport { ListValue } from \"./Value\";\nimport { ListDefinition } from \"./ListDefinition\";\nimport { TryGetResult } from \"./TryGetResult\";\nimport { throwNullException } from \"./NullException\";\n\nexport class ListDefinitionsOrigin {\n  protected _lists: Map<string, ListDefinition>;\n  protected _allUnambiguousListValueCache: Map<string, ListValue>;\n\n  constructor(lists: ListDefinition[]) {\n    this._lists = new Map();\n    this._allUnambiguousListValueCache = new Map();\n\n    for (let list of lists) {\n      this._lists.set(list.name, list);\n\n      for (let [key, val] of list.items) {\n        let item = InkListItem.fromSerializedKey(key);\n        let listValue = new ListValue(item, val);\n\n        if (!item.itemName) {\n          throw new Error(\"item.itemName is null or undefined.\");\n        }\n\n        this._allUnambiguousListValueCache.set(item.itemName, listValue);\n        this._allUnambiguousListValueCache.set(item.fullName, listValue);\n      }\n    }\n  }\n  get lists(): ListDefinition[] {\n    let listOfLists: ListDefinition[] = [];\n\n    for (let [, value] of this._lists) {\n      listOfLists.push(value);\n    }\n\n    return listOfLists;\n  }\n  public TryListGetDefinition(\n    name: string | null,\n    /* out */ def: ListDefinition | null\n  ): TryGetResult<ListDefinition | null> {\n    if (name === null) {\n      return { result: def, exists: false };\n    }\n    // initially, this function returns a boolean and the second parameter is an out.\n    let definition = this._lists.get(name);\n    if (!definition) return { result: def, exists: false };\n\n    return { result: definition, exists: true };\n  }\n  public FindSingleItemListWithName(name: string | null) {\n    if (name === null) {\n      return throwNullException(\"name\");\n    }\n    let val = this._allUnambiguousListValueCache.get(name);\n\n    if (typeof val !== \"undefined\") {\n      return val;\n    }\n\n    return null;\n  }\n}\n","import { Container } from \"./Container\";\nimport {\n  Value,\n  IntValue,\n  FloatValue,\n  StringValue,\n  DivertTargetValue,\n  VariablePointerValue,\n  ListValue,\n  BoolValue,\n} from \"./Value\";\nimport { Glue } from \"./Glue\";\nimport { ControlCommand } from \"./ControlCommand\";\nimport { PushPopType } from \"./PushPop\";\nimport { Divert } from \"./Divert\";\nimport { ChoicePoint } from \"./ChoicePoint\";\nimport { VariableReference } from \"./VariableReference\";\nimport { VariableAssignment } from \"./VariableAssignment\";\nimport { NativeFunctionCall } from \"./NativeFunctionCall\";\nimport { Void } from \"./Void\";\nimport { Tag } from \"./Tag\";\nimport { Path } from \"./Path\";\nimport { Choice } from \"./Choice\";\nimport { ListDefinition } from \"./ListDefinition\";\nimport { ListDefinitionsOrigin } from \"./ListDefinitionsOrigin\";\nimport { InkListItem, InkList } from \"./InkList\";\nimport { InkObject } from \"./Object\";\nimport { asOrNull } from \"./TypeAssertion\";\nimport { throwNullException } from \"./NullException\";\nimport { SimpleJson } from \"./SimpleJson\";\n\nexport class JsonSerialisation {\n  public static JArrayToRuntimeObjList(\n    jArray: any[],\n    skipLast: boolean = false\n  ) {\n    let count = jArray.length;\n    if (skipLast) count--;\n\n    let list: InkObject[] = [];\n\n    for (let i = 0; i < count; i++) {\n      let jTok = jArray[i];\n      let runtimeObj = this.JTokenToRuntimeObject(jTok);\n      if (runtimeObj === null) {\n        return throwNullException(\"runtimeObj\");\n      }\n      list.push(runtimeObj);\n    }\n\n    return list;\n  }\n\n  public static WriteDictionaryRuntimeObjs(\n    writer: SimpleJson.Writer,\n    dictionary: Map<string, InkObject>\n  ) {\n    writer.WriteObjectStart();\n    for (let [key, value] of dictionary) {\n      writer.WritePropertyStart(key);\n      this.WriteRuntimeObject(writer, value);\n      writer.WritePropertyEnd();\n    }\n    writer.WriteObjectEnd();\n  }\n\n  public static WriteListRuntimeObjs(\n    writer: SimpleJson.Writer,\n    list: InkObject[]\n  ) {\n    writer.WriteArrayStart();\n    for (let value of list) {\n      this.WriteRuntimeObject(writer, value);\n    }\n    writer.WriteArrayEnd();\n  }\n\n  public static WriteIntDictionary(\n    writer: SimpleJson.Writer,\n    dict: Map<string, number>\n  ) {\n    writer.WriteObjectStart();\n    for (let [key, value] of dict) {\n      writer.WriteIntProperty(key, value);\n    }\n    writer.WriteObjectEnd();\n  }\n\n  public static WriteRuntimeObject(\n    writer: SimpleJson.Writer,\n    obj: InkObject\n  ): void {\n    let container = asOrNull(obj, Container);\n    if (container) {\n      this.WriteRuntimeContainer(writer, container);\n      return;\n    }\n\n    let divert = asOrNull(obj, Divert);\n    if (divert) {\n      let divTypeKey = \"->\";\n      if (divert.isExternal) {\n        divTypeKey = \"x()\";\n      } else if (divert.pushesToStack) {\n        if (divert.stackPushType == PushPopType.Function) {\n          divTypeKey = \"f()\";\n        } else if (divert.stackPushType == PushPopType.Tunnel) {\n          divTypeKey = \"->t->\";\n        }\n      }\n\n      let targetStr;\n      if (divert.hasVariableTarget) {\n        targetStr = divert.variableDivertName;\n      } else {\n        targetStr = divert.targetPathString;\n      }\n\n      writer.WriteObjectStart();\n      writer.WriteProperty(divTypeKey, targetStr);\n\n      if (divert.hasVariableTarget) {\n        writer.WriteProperty(\"var\", true);\n      }\n\n      if (divert.isConditional) {\n        writer.WriteProperty(\"c\", true);\n      }\n\n      if (divert.externalArgs > 0) {\n        writer.WriteIntProperty(\"exArgs\", divert.externalArgs);\n      }\n\n      writer.WriteObjectEnd();\n      return;\n    }\n\n    let choicePoint = asOrNull(obj, ChoicePoint);\n    if (choicePoint) {\n      writer.WriteObjectStart();\n      writer.WriteProperty(\"*\", choicePoint.pathStringOnChoice);\n      writer.WriteIntProperty(\"flg\", choicePoint.flags);\n      writer.WriteObjectEnd();\n      return;\n    }\n\n    let boolVal = asOrNull(obj, BoolValue);\n    if (boolVal) {\n      writer.WriteBool(boolVal.value);\n      return;\n    }\n\n    let intVal = asOrNull(obj, IntValue);\n    if (intVal) {\n      writer.WriteInt(intVal.value);\n      return;\n    }\n\n    let floatVal = asOrNull(obj, FloatValue);\n    if (floatVal) {\n      writer.WriteFloat(floatVal.value);\n      return;\n    }\n\n    let strVal = asOrNull(obj, StringValue);\n    if (strVal) {\n      if (strVal.isNewline) {\n        writer.Write(\"\\n\", false);\n      } else {\n        writer.WriteStringStart();\n        writer.WriteStringInner(\"^\");\n        writer.WriteStringInner(strVal.value);\n        writer.WriteStringEnd();\n      }\n      return;\n    }\n\n    let listVal = asOrNull(obj, ListValue);\n    if (listVal) {\n      this.WriteInkList(writer, listVal);\n      return;\n    }\n\n    let divTargetVal = asOrNull(obj, DivertTargetValue);\n    if (divTargetVal) {\n      writer.WriteObjectStart();\n      if (divTargetVal.value === null) {\n        return throwNullException(\"divTargetVal.value\");\n      }\n      writer.WriteProperty(\"^->\", divTargetVal.value.componentsString);\n      writer.WriteObjectEnd();\n\n      return;\n    }\n\n    let varPtrVal = asOrNull(obj, VariablePointerValue);\n    if (varPtrVal) {\n      writer.WriteObjectStart();\n      writer.WriteProperty(\"^var\", varPtrVal.value);\n      writer.WriteIntProperty(\"ci\", varPtrVal.contextIndex);\n      writer.WriteObjectEnd();\n      return;\n    }\n\n    let glue = asOrNull(obj, Glue);\n    if (glue) {\n      writer.Write(\"<>\");\n      return;\n    }\n\n    let controlCmd = asOrNull(obj, ControlCommand);\n    if (controlCmd) {\n      writer.Write(\n        JsonSerialisation._controlCommandNames[controlCmd.commandType]\n      );\n      return;\n    }\n\n    let nativeFunc = asOrNull(obj, NativeFunctionCall);\n    if (nativeFunc) {\n      let name = nativeFunc.name;\n\n      if (name == \"^\") name = \"L^\";\n\n      writer.Write(name);\n      return;\n    }\n\n    let varRef = asOrNull(obj, VariableReference);\n    if (varRef) {\n      writer.WriteObjectStart();\n      let readCountPath = varRef.pathStringForCount;\n      if (readCountPath != null) {\n        writer.WriteProperty(\"CNT?\", readCountPath);\n      } else {\n        writer.WriteProperty(\"VAR?\", varRef.name);\n      }\n\n      writer.WriteObjectEnd();\n      return;\n    }\n\n    let varAss = asOrNull(obj, VariableAssignment);\n    if (varAss) {\n      writer.WriteObjectStart();\n\n      let key = varAss.isGlobal ? \"VAR=\" : \"temp=\";\n      writer.WriteProperty(key, varAss.variableName);\n\n      // Reassignment?\n      if (!varAss.isNewDeclaration) writer.WriteProperty(\"re\", true);\n\n      writer.WriteObjectEnd();\n\n      return;\n    }\n\n    let voidObj = asOrNull(obj, Void);\n    if (voidObj) {\n      writer.Write(\"void\");\n      return;\n    }\n\n    let tag = asOrNull(obj, Tag);\n    if (tag) {\n      writer.WriteObjectStart();\n      writer.WriteProperty(\"#\", tag.text);\n      writer.WriteObjectEnd();\n      return;\n    }\n\n    let choice = asOrNull(obj, Choice);\n    if (choice) {\n      this.WriteChoice(writer, choice);\n      return;\n    }\n\n    throw new Error(\"Failed to convert runtime object to Json token: \" + obj);\n  }\n\n  public static JObjectToDictionaryRuntimeObjs(jObject: Record<string, any>) {\n    let dict: Map<string, InkObject> = new Map();\n\n    for (let key in jObject) {\n      if (jObject.hasOwnProperty(key)) {\n        let inkObject = this.JTokenToRuntimeObject(jObject[key]);\n        if (inkObject === null) {\n          return throwNullException(\"inkObject\");\n        }\n        dict.set(key, inkObject);\n      }\n    }\n\n    return dict;\n  }\n\n  public static JObjectToIntDictionary(jObject: Record<string, any>) {\n    let dict: Map<string, number> = new Map();\n    for (let key in jObject) {\n      if (jObject.hasOwnProperty(key)) {\n        dict.set(key, parseInt(jObject[key]));\n      }\n    }\n    return dict;\n  }\n\n  public static JTokenToRuntimeObject(token: any): InkObject | null {\n    if (\n      (typeof token === \"number\" && !isNaN(token)) ||\n      typeof token === \"boolean\"\n    ) {\n      return Value.Create(token);\n    }\n\n    if (typeof token === \"string\") {\n      let str = token.toString();\n\n      // String value\n      let firstChar = str[0];\n      if (firstChar == \"^\") return new StringValue(str.substring(1));\n      else if (firstChar == \"\\n\" && str.length == 1)\n        return new StringValue(\"\\n\");\n\n      // Glue\n      if (str == \"<>\") return new Glue();\n\n      // Control commands (would looking up in a hash set be faster?)\n      for (let i = 0; i < JsonSerialisation._controlCommandNames.length; ++i) {\n        let cmdName = JsonSerialisation._controlCommandNames[i];\n        if (str == cmdName) {\n          return new ControlCommand(i);\n        }\n      }\n\n      // Native functions\n      if (str == \"L^\") str = \"^\";\n      if (NativeFunctionCall.CallExistsWithName(str))\n        return NativeFunctionCall.CallWithName(str);\n\n      // Pop\n      if (str == \"->->\") return ControlCommand.PopTunnel();\n      else if (str == \"~ret\") return ControlCommand.PopFunction();\n\n      // Void\n      if (str == \"void\") return new Void();\n    }\n\n    if (typeof token === \"object\" && !Array.isArray(token)) {\n      let obj = token as Record<string, any>;\n      let propValue;\n\n      // Divert target value to path\n      if (obj[\"^->\"]) {\n        propValue = obj[\"^->\"];\n        return new DivertTargetValue(new Path(propValue.toString()));\n      }\n\n      // VariablePointerValue\n      if (obj[\"^var\"]) {\n        propValue = obj[\"^var\"];\n        let varPtr = new VariablePointerValue(propValue.toString());\n        if (\"ci\" in obj) {\n          propValue = obj[\"ci\"];\n          varPtr.contextIndex = parseInt(propValue);\n        }\n        return varPtr;\n      }\n\n      // Divert\n      let isDivert = false;\n      let pushesToStack = false;\n      let divPushType = PushPopType.Function;\n      let external = false;\n      if ((propValue = obj[\"->\"])) {\n        isDivert = true;\n      } else if ((propValue = obj[\"f()\"])) {\n        isDivert = true;\n        pushesToStack = true;\n        divPushType = PushPopType.Function;\n      } else if ((propValue = obj[\"->t->\"])) {\n        isDivert = true;\n        pushesToStack = true;\n        divPushType = PushPopType.Tunnel;\n      } else if ((propValue = obj[\"x()\"])) {\n        isDivert = true;\n        external = true;\n        pushesToStack = false;\n        divPushType = PushPopType.Function;\n      }\n\n      if (isDivert) {\n        let divert = new Divert();\n        divert.pushesToStack = pushesToStack;\n        divert.stackPushType = divPushType;\n        divert.isExternal = external;\n\n        let target = propValue.toString();\n\n        if ((propValue = obj[\"var\"])) divert.variableDivertName = target;\n        else divert.targetPathString = target;\n\n        divert.isConditional = !!obj[\"c\"];\n\n        if (external) {\n          if ((propValue = obj[\"exArgs\"]))\n            divert.externalArgs = parseInt(propValue);\n        }\n\n        return divert;\n      }\n\n      // Choice\n      if ((propValue = obj[\"*\"])) {\n        let choice = new ChoicePoint();\n        choice.pathStringOnChoice = propValue.toString();\n\n        if ((propValue = obj[\"flg\"])) choice.flags = parseInt(propValue);\n\n        return choice;\n      }\n\n      // Variable reference\n      if ((propValue = obj[\"VAR?\"])) {\n        return new VariableReference(propValue.toString());\n      } else if ((propValue = obj[\"CNT?\"])) {\n        let readCountVarRef = new VariableReference();\n        readCountVarRef.pathStringForCount = propValue.toString();\n        return readCountVarRef;\n      }\n\n      // Variable assignment\n      let isVarAss = false;\n      let isGlobalVar = false;\n      if ((propValue = obj[\"VAR=\"])) {\n        isVarAss = true;\n        isGlobalVar = true;\n      } else if ((propValue = obj[\"temp=\"])) {\n        isVarAss = true;\n        isGlobalVar = false;\n      }\n      if (isVarAss) {\n        let varName = propValue.toString();\n        let isNewDecl = !obj[\"re\"];\n        let varAss = new VariableAssignment(varName, isNewDecl);\n        varAss.isGlobal = isGlobalVar;\n        return varAss;\n      }\n      if (obj[\"#\"] !== undefined) {\n        propValue = obj[\"#\"];\n        return new Tag(propValue.toString());\n      }\n\n      // List value\n      if ((propValue = obj[\"list\"])) {\n        // var listContent = (Dictionary<string, object>)propValue;\n        let listContent = propValue as Record<string, any>;\n        let rawList = new InkList();\n        if ((propValue = obj[\"origins\"])) {\n          // var namesAsObjs = (List<object>)propValue;\n          let namesAsObjs = propValue as string[];\n          // rawList.SetInitialOriginNames(namesAsObjs.Cast<string>().ToList());\n          rawList.SetInitialOriginNames(namesAsObjs);\n        }\n\n        for (let key in listContent) {\n          if (listContent.hasOwnProperty(key)) {\n            let nameToVal = listContent[key];\n            let item = new InkListItem(key);\n            let val = parseInt(nameToVal);\n            rawList.Add(item, val);\n          }\n        }\n\n        return new ListValue(rawList);\n      }\n\n      if (obj[\"originalChoicePath\"] != null) return this.JObjectToChoice(obj);\n    }\n\n    // Array is always a Runtime.Container\n    if (Array.isArray(token)) {\n      return this.JArrayToContainer(token);\n    }\n\n    if (token === null || token === undefined) return null;\n\n    throw new Error(\n      \"Failed to convert token to runtime object: \" +\n        this.toJson(token, [\"parent\"])\n    );\n  }\n\n  public static toJson<T>(\n    me: T,\n    removes?: (keyof T)[],\n    space?: number\n  ): string {\n    return JSON.stringify(\n      me,\n      (k, v) => (removes?.some((r) => r === k) ? undefined : v),\n      space\n    );\n  }\n\n  public static WriteRuntimeContainer(\n    writer: SimpleJson.Writer,\n    container: Container | null,\n    withoutName: boolean = false\n  ) {\n    writer.WriteArrayStart();\n    if (container === null) {\n      return throwNullException(\"container\");\n    }\n    for (let c of container.content) this.WriteRuntimeObject(writer, c);\n\n    let namedOnlyContent = container.namedOnlyContent;\n    let countFlags = container.countFlags;\n    let hasNameProperty = container.name != null && !withoutName;\n\n    let hasTerminator =\n      namedOnlyContent != null || countFlags > 0 || hasNameProperty;\n    if (hasTerminator) {\n      writer.WriteObjectStart();\n    }\n\n    if (namedOnlyContent != null) {\n      for (let [key, value] of namedOnlyContent) {\n        let name = key;\n        let namedContainer = asOrNull(value, Container);\n        writer.WritePropertyStart(name);\n        this.WriteRuntimeContainer(writer, namedContainer, true);\n        writer.WritePropertyEnd();\n      }\n    }\n\n    if (countFlags > 0) writer.WriteIntProperty(\"#f\", countFlags);\n\n    if (hasNameProperty) writer.WriteProperty(\"#n\", container.name);\n\n    if (hasTerminator) writer.WriteObjectEnd();\n    else writer.WriteNull();\n\n    writer.WriteArrayEnd();\n  }\n\n  public static JArrayToContainer(jArray: any[]) {\n    let container = new Container();\n    container.content = this.JArrayToRuntimeObjList(jArray, true);\n\n    let terminatingObj = jArray[jArray.length - 1] as Record<string, any>;\n    if (terminatingObj != null) {\n      let namedOnlyContent = new Map();\n\n      for (let key in terminatingObj) {\n        if (key == \"#f\") {\n          container.countFlags = parseInt(terminatingObj[key]);\n        } else if (key == \"#n\") {\n          container.name = terminatingObj[key].toString();\n        } else {\n          let namedContentItem = this.JTokenToRuntimeObject(\n            terminatingObj[key]\n          );\n          // var namedSubContainer = namedContentItem as Container;\n          let namedSubContainer = asOrNull(namedContentItem, Container);\n          if (namedSubContainer) namedSubContainer.name = key;\n          namedOnlyContent.set(key, namedContentItem);\n        }\n      }\n\n      container.namedOnlyContent = namedOnlyContent;\n    }\n\n    return container;\n  }\n\n  public static JObjectToChoice(jObj: Record<string, any>) {\n    let choice = new Choice();\n    choice.text = jObj[\"text\"].toString();\n    choice.index = parseInt(jObj[\"index\"]);\n    choice.sourcePath = jObj[\"originalChoicePath\"].toString();\n    choice.originalThreadIndex = parseInt(jObj[\"originalThreadIndex\"]);\n    choice.pathStringOnChoice = jObj[\"targetPath\"].toString();\n    return choice;\n  }\n\n  public static WriteChoice(writer: SimpleJson.Writer, choice: Choice) {\n    writer.WriteObjectStart();\n    writer.WriteProperty(\"text\", choice.text);\n    writer.WriteIntProperty(\"index\", choice.index);\n    writer.WriteProperty(\"originalChoicePath\", choice.sourcePath);\n    writer.WriteIntProperty(\"originalThreadIndex\", choice.originalThreadIndex);\n    writer.WriteProperty(\"targetPath\", choice.pathStringOnChoice);\n    writer.WriteObjectEnd();\n  }\n\n  public static WriteInkList(writer: SimpleJson.Writer, listVal: ListValue) {\n    let rawList = listVal.value;\n    if (rawList === null) {\n      return throwNullException(\"rawList\");\n    }\n\n    writer.WriteObjectStart();\n    writer.WritePropertyStart(\"list\");\n    writer.WriteObjectStart();\n\n    for (let [key, val] of rawList) {\n      let item = InkListItem.fromSerializedKey(key);\n      let itemVal = val;\n\n      if (item.itemName === null) {\n        return throwNullException(\"item.itemName\");\n      }\n\n      writer.WritePropertyNameStart();\n      writer.WritePropertyNameInner(item.originName ? item.originName : \"?\");\n      writer.WritePropertyNameInner(\".\");\n      writer.WritePropertyNameInner(item.itemName);\n      writer.WritePropertyNameEnd();\n\n      writer.Write(itemVal);\n\n      writer.WritePropertyEnd();\n    }\n\n    writer.WriteObjectEnd();\n\n    writer.WritePropertyEnd();\n\n    if (\n      rawList.Count == 0 &&\n      rawList.originNames != null &&\n      rawList.originNames.length > 0\n    ) {\n      writer.WritePropertyStart(\"origins\");\n      writer.WriteArrayStart();\n      for (let name of rawList.originNames) writer.Write(name);\n      writer.WriteArrayEnd();\n      writer.WritePropertyEnd();\n    }\n\n    writer.WriteObjectEnd();\n  }\n\n  public static ListDefinitionsToJToken(origin: ListDefinitionsOrigin) {\n    let result: Record<string, any> = {};\n\n    for (let def of origin.lists) {\n      let listDefJson: Record<string, any> = {};\n\n      for (let [key, val] of def.items) {\n        let item = InkListItem.fromSerializedKey(key);\n        if (item.itemName === null) {\n          return throwNullException(\"item.itemName\");\n        }\n        listDefJson[item.itemName] = val;\n      }\n\n      result[def.name] = listDefJson;\n    }\n\n    return result;\n  }\n\n  public static JTokenToListDefinitions(obj: Record<string, any>) {\n    // var defsObj = (Dictionary<string, object>)obj;\n    let defsObj = obj;\n\n    let allDefs: ListDefinition[] = [];\n\n    for (let key in defsObj) {\n      if (defsObj.hasOwnProperty(key)) {\n        let name = key.toString();\n        // var listDefJson = (Dictionary<string, object>)kv.Value;\n        let listDefJson = defsObj[key] as Record<string, any>;\n\n        // Cast (string, object) to (string, int) for items\n        let items: Map<string, number> = new Map();\n\n        for (let nameValueKey in listDefJson) {\n          if (defsObj.hasOwnProperty(key)) {\n            let nameValue = listDefJson[nameValueKey];\n            items.set(nameValueKey, parseInt(nameValue));\n          }\n        }\n\n        let def = new ListDefinition(name, items);\n        allDefs.push(def);\n      }\n    }\n\n    return new ListDefinitionsOrigin(allDefs);\n  }\n\n  private static _controlCommandNames = (() => {\n    let _controlCommandNames: string[] = [];\n\n    _controlCommandNames[ControlCommand.CommandType.EvalStart] = \"ev\";\n    _controlCommandNames[ControlCommand.CommandType.EvalOutput] = \"out\";\n    _controlCommandNames[ControlCommand.CommandType.EvalEnd] = \"/ev\";\n    _controlCommandNames[ControlCommand.CommandType.Duplicate] = \"du\";\n    _controlCommandNames[ControlCommand.CommandType.PopEvaluatedValue] = \"pop\";\n    _controlCommandNames[ControlCommand.CommandType.PopFunction] = \"~ret\";\n    _controlCommandNames[ControlCommand.CommandType.PopTunnel] = \"->->\";\n    _controlCommandNames[ControlCommand.CommandType.BeginString] = \"str\";\n    _controlCommandNames[ControlCommand.CommandType.EndString] = \"/str\";\n    _controlCommandNames[ControlCommand.CommandType.NoOp] = \"nop\";\n    _controlCommandNames[ControlCommand.CommandType.ChoiceCount] = \"choiceCnt\";\n    _controlCommandNames[ControlCommand.CommandType.Turns] = \"turn\";\n    _controlCommandNames[ControlCommand.CommandType.TurnsSince] = \"turns\";\n    _controlCommandNames[ControlCommand.CommandType.ReadCount] = \"readc\";\n    _controlCommandNames[ControlCommand.CommandType.Random] = \"rnd\";\n    _controlCommandNames[ControlCommand.CommandType.SeedRandom] = \"srnd\";\n    _controlCommandNames[ControlCommand.CommandType.VisitIndex] = \"visit\";\n    _controlCommandNames[ControlCommand.CommandType.SequenceShuffleIndex] =\n      \"seq\";\n    _controlCommandNames[ControlCommand.CommandType.StartThread] = \"thread\";\n    _controlCommandNames[ControlCommand.CommandType.Done] = \"done\";\n    _controlCommandNames[ControlCommand.CommandType.End] = \"end\";\n    _controlCommandNames[ControlCommand.CommandType.ListFromInt] = \"listInt\";\n    _controlCommandNames[ControlCommand.CommandType.ListRange] = \"range\";\n    _controlCommandNames[ControlCommand.CommandType.ListRandom] = \"lrnd\";\n    _controlCommandNames[ControlCommand.CommandType.BeginTag] = \"#\";\n    _controlCommandNames[ControlCommand.CommandType.EndTag] = \"/#\";\n\n    for (let i = 0; i < ControlCommand.CommandType.TOTAL_VALUES; ++i) {\n      if (_controlCommandNames[i] == null)\n        throw new Error(\"Control command not accounted for in serialisation\");\n    }\n\n    return _controlCommandNames;\n  })();\n}\n","import { PushPopType } from \"./PushPop\";\nimport { Path } from \"./Path\";\nimport { Story } from \"./Story\";\nimport { JsonSerialisation } from \"./JsonSerialisation\";\nimport { ListValue } from \"./Value\";\nimport { StringBuilder } from \"./StringBuilder\";\nimport { Pointer } from \"./Pointer\";\nimport { InkObject } from \"./Object\";\nimport { Debug } from \"./Debug\";\nimport { tryGetValueFromMap } from \"./TryGetResult\";\nimport { throwNullException } from \"./NullException\";\nimport { SimpleJson } from \"./SimpleJson\";\n\nexport class CallStack {\n  get elements() {\n    return this.callStack;\n  }\n\n  get depth() {\n    return this.elements.length;\n  }\n\n  get currentElement() {\n    let thread = this._threads[this._threads.length - 1];\n    let cs = thread.callstack;\n    return cs[cs.length - 1];\n  }\n\n  get currentElementIndex() {\n    return this.callStack.length - 1;\n  }\n\n  get currentThread(): CallStack.Thread {\n    return this._threads[this._threads.length - 1];\n  }\n  set currentThread(value: CallStack.Thread) {\n    Debug.Assert(\n      this._threads.length == 1,\n      \"Shouldn't be directly setting the current thread when we have a stack of them\"\n    );\n\n    this._threads.length = 0;\n    this._threads.push(value);\n  }\n\n  get canPop() {\n    return this.callStack.length > 1;\n  }\n\n  constructor(storyContext: Story);\n  constructor(toCopy: CallStack);\n  constructor() {\n    if (arguments[0] instanceof Story) {\n      let storyContext = arguments[0] as Story;\n\n      this._startOfRoot = Pointer.StartOf(storyContext.rootContentContainer);\n      this.Reset();\n    } else {\n      let toCopy = arguments[0] as CallStack;\n\n      this._threads = [];\n      for (let otherThread of toCopy._threads) {\n        this._threads.push(otherThread.Copy());\n      }\n      this._threadCounter = toCopy._threadCounter;\n      this._startOfRoot = toCopy._startOfRoot.copy();\n    }\n  }\n\n  public Reset() {\n    this._threads = [];\n    this._threads.push(new CallStack.Thread());\n\n    this._threads[0].callstack.push(\n      new CallStack.Element(PushPopType.Tunnel, this._startOfRoot)\n    );\n  }\n\n  public SetJsonToken(jObject: Record<string, any>, storyContext: Story) {\n    this._threads.length = 0;\n\n    // TODO: (List<object>) jObject [\"threads\"];\n    let jThreads: any[] = jObject[\"threads\"];\n\n    for (let jThreadTok of jThreads) {\n      // TODO: var jThreadObj = (Dictionary<string, object>)jThreadTok;\n      let jThreadObj = jThreadTok;\n      let thread = new CallStack.Thread(jThreadObj, storyContext);\n      this._threads.push(thread);\n    }\n\n    // TODO: (int)jObject [\"threadCounter\"];\n    this._threadCounter = parseInt(jObject[\"threadCounter\"]);\n    this._startOfRoot = Pointer.StartOf(storyContext.rootContentContainer);\n  }\n  public WriteJson(w: SimpleJson.Writer) {\n    w.WriteObject((writer) => {\n      writer.WritePropertyStart(\"threads\");\n      writer.WriteArrayStart();\n\n      for (let thread of this._threads) {\n        thread.WriteJson(writer);\n      }\n\n      writer.WriteArrayEnd();\n      writer.WritePropertyEnd();\n\n      writer.WritePropertyStart(\"threadCounter\");\n      writer.WriteInt(this._threadCounter);\n      writer.WritePropertyEnd();\n    });\n  }\n\n  public PushThread() {\n    let newThread = this.currentThread.Copy();\n    this._threadCounter++;\n    newThread.threadIndex = this._threadCounter;\n    this._threads.push(newThread);\n  }\n\n  public ForkThread() {\n    let forkedThread = this.currentThread.Copy();\n    this._threadCounter++;\n    forkedThread.threadIndex = this._threadCounter;\n    return forkedThread;\n  }\n\n  public PopThread() {\n    if (this.canPopThread) {\n      this._threads.splice(this._threads.indexOf(this.currentThread), 1); // should be equivalent to a pop()\n    } else {\n      throw new Error(\"Can't pop thread\");\n    }\n  }\n\n  get canPopThread() {\n    return this._threads.length > 1 && !this.elementIsEvaluateFromGame;\n  }\n\n  get elementIsEvaluateFromGame() {\n    return this.currentElement.type == PushPopType.FunctionEvaluationFromGame;\n  }\n\n  public Push(\n    type: PushPopType,\n    externalEvaluationStackHeight: number = 0,\n    outputStreamLengthWithPushed: number = 0\n  ) {\n    let element = new CallStack.Element(\n      type,\n      this.currentElement.currentPointer,\n      false\n    );\n\n    element.evaluationStackHeightWhenPushed = externalEvaluationStackHeight;\n    element.functionStartInOutputStream = outputStreamLengthWithPushed;\n\n    this.callStack.push(element);\n  }\n\n  public CanPop(type: PushPopType | null = null) {\n    if (!this.canPop) return false;\n\n    if (type == null) return true;\n\n    return this.currentElement.type == type;\n  }\n\n  public Pop(type: PushPopType | null = null) {\n    if (this.CanPop(type)) {\n      this.callStack.pop();\n      return;\n    } else {\n      throw new Error(\"Mismatched push/pop in Callstack\");\n    }\n  }\n\n  public GetTemporaryVariableWithName(\n    name: string | null,\n    contextIndex: number = -1\n  ) {\n    if (contextIndex == -1) contextIndex = this.currentElementIndex + 1;\n\n    let contextElement = this.callStack[contextIndex - 1];\n\n    let varValue = tryGetValueFromMap(\n      contextElement.temporaryVariables,\n      name,\n      null\n    );\n    if (varValue.exists) {\n      return varValue.result;\n    } else {\n      return null;\n    }\n  }\n\n  public SetTemporaryVariable(\n    name: string,\n    value: any,\n    declareNew: boolean,\n    contextIndex: number = -1\n  ) {\n    if (contextIndex == -1) contextIndex = this.currentElementIndex + 1;\n\n    let contextElement = this.callStack[contextIndex - 1];\n\n    if (!declareNew && !contextElement.temporaryVariables.get(name)) {\n      throw new Error(\"Could not find temporary variable to set: \" + name);\n    }\n\n    let oldValue = tryGetValueFromMap(\n      contextElement.temporaryVariables,\n      name,\n      null\n    );\n    if (oldValue.exists)\n      ListValue.RetainListOriginsForAssignment(oldValue.result, value);\n\n    contextElement.temporaryVariables.set(name, value);\n  }\n\n  public ContextForVariableNamed(name: string) {\n    if (this.currentElement.temporaryVariables.get(name)) {\n      return this.currentElementIndex + 1;\n    } else {\n      return 0;\n    }\n  }\n\n  public ThreadWithIndex(index: number) {\n    let filtered = this._threads.filter((t) => {\n      if (t.threadIndex == index) return t;\n    });\n\n    return filtered.length > 0 ? filtered[0] : null;\n  }\n\n  get callStack() {\n    return this.currentThread.callstack;\n  }\n\n  get callStackTrace() {\n    let sb = new StringBuilder();\n\n    for (let t = 0; t < this._threads.length; t++) {\n      let thread = this._threads[t];\n      let isCurrent = t == this._threads.length - 1;\n      sb.AppendFormat(\n        \"=== THREAD {0}/{1} {2}===\\n\",\n        t + 1,\n        this._threads.length,\n        isCurrent ? \"(current) \" : \"\"\n      );\n\n      for (let i = 0; i < thread.callstack.length; i++) {\n        if (thread.callstack[i].type == PushPopType.Function)\n          sb.Append(\"  [FUNCTION] \");\n        else sb.Append(\"  [TUNNEL] \");\n\n        let pointer = thread.callstack[i].currentPointer;\n        if (!pointer.isNull) {\n          sb.Append(\"<SOMEWHERE IN \");\n          if (pointer.container === null) {\n            return throwNullException(\"pointer.container\");\n          }\n          sb.Append(pointer.container.path.toString());\n          sb.AppendLine(\">\");\n        }\n      }\n    }\n\n    return sb.toString();\n  }\n\n  public _threads!: CallStack.Thread[]; // Banged because it's initialized in Reset().\n  public _threadCounter: number = 0;\n  public _startOfRoot: Pointer = Pointer.Null;\n}\n\nexport namespace CallStack {\n  export class Element {\n    public currentPointer: Pointer;\n    public inExpressionEvaluation: boolean;\n    public temporaryVariables: Map<string, InkObject>;\n    public type: PushPopType;\n\n    public evaluationStackHeightWhenPushed: number = 0;\n    public functionStartInOutputStream: number = 0;\n\n    constructor(\n      type: PushPopType,\n      pointer: Pointer,\n      inExpressionEvaluation: boolean = false\n    ) {\n      this.currentPointer = pointer.copy();\n      this.inExpressionEvaluation = inExpressionEvaluation;\n      this.temporaryVariables = new Map();\n      this.type = type;\n    }\n\n    public Copy() {\n      let copy = new Element(\n        this.type,\n        this.currentPointer,\n        this.inExpressionEvaluation\n      );\n      copy.temporaryVariables = new Map(this.temporaryVariables);\n      copy.evaluationStackHeightWhenPushed =\n        this.evaluationStackHeightWhenPushed;\n      copy.functionStartInOutputStream = this.functionStartInOutputStream;\n      return copy;\n    }\n  }\n\n  export class Thread {\n    public callstack: Element[];\n    public threadIndex: number = 0;\n    public previousPointer: Pointer = Pointer.Null;\n\n    constructor();\n    constructor(jThreadObj: any, storyContext: Story);\n    constructor() {\n      this.callstack = [];\n\n      if (arguments[0] && arguments[1]) {\n        let jThreadObj = arguments[0];\n        let storyContext = arguments[1];\n\n        // TODO: (int) jThreadObj['threadIndex'] can raise;\n        this.threadIndex = parseInt(jThreadObj[\"threadIndex\"]);\n\n        let jThreadCallstack = jThreadObj[\"callstack\"];\n\n        for (let jElTok of jThreadCallstack) {\n          let jElementObj = jElTok;\n\n          // TODO: (int) jElementObj['type'] can raise;\n          let pushPopType: PushPopType = parseInt(jElementObj[\"type\"]);\n\n          let pointer = Pointer.Null;\n\n          let currentContainerPathStr: string;\n          // TODO: jElementObj.TryGetValue (\"cPath\", out currentContainerPathStrToken);\n          let currentContainerPathStrToken = jElementObj[\"cPath\"];\n          if (typeof currentContainerPathStrToken !== \"undefined\") {\n            currentContainerPathStr = currentContainerPathStrToken.toString();\n\n            let threadPointerResult = storyContext.ContentAtPath(\n              new Path(currentContainerPathStr)\n            );\n            pointer.container = threadPointerResult.container;\n            pointer.index = parseInt(jElementObj[\"idx\"]);\n\n            if (threadPointerResult.obj == null)\n              throw new Error(\n                \"When loading state, internal story location couldn't be found: \" +\n                  currentContainerPathStr +\n                  \". Has the story changed since this save data was created?\"\n              );\n            else if (threadPointerResult.approximate) {\n              if (pointer.container === null) {\n                return throwNullException(\"pointer.container\");\n              }\n              storyContext.Warning(\n                \"When loading state, exact internal story location couldn't be found: '\" +\n                  currentContainerPathStr +\n                  \"', so it was approximated to '\" +\n                  pointer.container.path.toString() +\n                  \"' to recover. Has the story changed since this save data was created?\"\n              );\n            }\n          }\n\n          let inExpressionEvaluation = !!jElementObj[\"exp\"];\n\n          let el = new Element(pushPopType, pointer, inExpressionEvaluation);\n\n          let temps = jElementObj[\"temp\"];\n          if (typeof temps !== \"undefined\") {\n            el.temporaryVariables =\n              JsonSerialisation.JObjectToDictionaryRuntimeObjs(temps);\n          } else {\n            el.temporaryVariables.clear();\n          }\n\n          this.callstack.push(el);\n        }\n\n        let prevContentObjPath = jThreadObj[\"previousContentObject\"];\n        if (typeof prevContentObjPath !== \"undefined\") {\n          let prevPath = new Path(prevContentObjPath.toString());\n          this.previousPointer = storyContext.PointerAtPath(prevPath);\n        }\n      }\n    }\n\n    public Copy() {\n      let copy = new Thread();\n      copy.threadIndex = this.threadIndex;\n      for (let e of this.callstack) {\n        copy.callstack.push(e.Copy());\n      }\n      copy.previousPointer = this.previousPointer.copy();\n      return copy;\n    }\n\n    public WriteJson(writer: SimpleJson.Writer) {\n      writer.WriteObjectStart();\n\n      writer.WritePropertyStart(\"callstack\");\n      writer.WriteArrayStart();\n      for (let el of this.callstack) {\n        writer.WriteObjectStart();\n        if (!el.currentPointer.isNull) {\n          if (el.currentPointer.container === null) {\n            return throwNullException(\"el.currentPointer.container\");\n          }\n          writer.WriteProperty(\n            \"cPath\",\n            el.currentPointer.container.path.componentsString\n          );\n          writer.WriteIntProperty(\"idx\", el.currentPointer.index);\n        }\n\n        writer.WriteProperty(\"exp\", el.inExpressionEvaluation);\n        writer.WriteIntProperty(\"type\", el.type);\n\n        if (el.temporaryVariables.size > 0) {\n          writer.WritePropertyStart(\"temp\");\n          JsonSerialisation.WriteDictionaryRuntimeObjs(\n            writer,\n            el.temporaryVariables\n          );\n          writer.WritePropertyEnd();\n        }\n\n        writer.WriteObjectEnd();\n      }\n      writer.WriteArrayEnd();\n      writer.WritePropertyEnd();\n\n      writer.WriteIntProperty(\"threadIndex\", this.threadIndex);\n\n      if (!this.previousPointer.isNull) {\n        let resolvedPointer = this.previousPointer.Resolve();\n        if (resolvedPointer === null) {\n          return throwNullException(\"this.previousPointer.Resolve()\");\n        }\n        writer.WriteProperty(\n          \"previousContentObject\",\n          resolvedPointer.path.toString()\n        );\n      }\n\n      writer.WriteObjectEnd();\n    }\n  }\n}\n","import {\n  AbstractValue,\n  Value,\n  VariablePointerValue,\n  ListValue,\n  IntValue,\n  FloatValue,\n  BoolValue,\n} from \"./Value\";\nimport { VariableAssignment } from \"./VariableAssignment\";\nimport { InkObject } from \"./Object\";\nimport { ListDefinitionsOrigin } from \"./ListDefinitionsOrigin\";\nimport { StoryException } from \"./StoryException\";\nimport { JsonSerialisation } from \"./JsonSerialisation\";\nimport { asOrThrows, asOrNull, isEquatable } from \"./TypeAssertion\";\nimport { tryGetValueFromMap } from \"./TryGetResult\";\nimport { throwNullException } from \"./NullException\";\nimport { CallStack } from \"./CallStack\";\nimport { StatePatch } from \"./StatePatch\";\nimport { SimpleJson } from \"./SimpleJson\";\nimport { InkList } from \"./Story\";\nimport { Path } from \"./Path\";\n\n// Fake class wrapper around VariableState to have correct typing\n// when using the Proxy syntax in typescript\nfunction VariablesStateAccessor<T>(): new () => Pick<T, keyof T> {\n  return class {} as any;\n}\n\ntype VariableStateValue = boolean | string | number | InkList | Path | null;\n\nexport class VariablesState extends VariablesStateAccessor<\n  Record<string, any>\n>() {\n  // The way variableChangedEvent is a bit different than the reference implementation.\n  // Originally it uses the C# += operator to add delegates, but in js we need to maintain\n  // an actual collection of delegates (ie. callbacks) to register a new one, there is a\n  // special ObserveVariableChange method below.\n  public variableChangedEventCallbacks: Array<\n    (variableName: string, newValue: InkObject) => void\n  > = [];\n  public variableChangedEvent(variableName: string, newValue: InkObject): void {\n    for (let callback of this.variableChangedEventCallbacks) {\n      callback(variableName, newValue);\n    }\n  }\n\n  public patch: StatePatch | null = null;\n\n  get batchObservingVariableChanges() {\n    return this._batchObservingVariableChanges;\n  }\n  set batchObservingVariableChanges(value: boolean) {\n    this._batchObservingVariableChanges = value;\n    if (value) {\n      this._changedVariablesForBatchObs = new Set();\n    } else {\n      if (this._changedVariablesForBatchObs != null) {\n        for (let variableName of this._changedVariablesForBatchObs) {\n          let currentValue = this._globalVariables.get(variableName);\n          if (!currentValue) {\n            throwNullException(\"currentValue\");\n          } else {\n            this.variableChangedEvent(variableName, currentValue);\n          }\n        }\n\n        this._changedVariablesForBatchObs = null;\n      }\n    }\n  }\n\n  get callStack() {\n    return this._callStack;\n  }\n  set callStack(callStack) {\n    this._callStack = callStack;\n  }\n\n  private _batchObservingVariableChanges: boolean = false;\n\n  // the original code uses a magic getter and setter for global variables,\n  // allowing things like variableState['varname]. This is not quite possible\n  // in js without a Proxy, so it is replaced with this $ function.\n  public $(variableName: string): VariableStateValue;\n  public $(variableName: string, value: VariableStateValue): void;\n  public $(variableName: string, value?: any) {\n    if (typeof value === \"undefined\") {\n      let varContents = null;\n\n      if (this.patch !== null) {\n        varContents = this.patch.TryGetGlobal(variableName, null);\n        if (varContents.exists)\n          return (varContents.result as AbstractValue).valueObject;\n      }\n\n      varContents = this._globalVariables.get(variableName);\n\n      if (typeof varContents === \"undefined\") {\n        varContents = this._defaultGlobalVariables.get(variableName);\n      }\n\n      if (typeof varContents !== \"undefined\")\n        return (varContents as AbstractValue).valueObject;\n      else return null;\n    } else {\n      if (typeof this._defaultGlobalVariables.get(variableName) === \"undefined\")\n        throw new StoryException(\n          \"Cannot assign to a variable (\" +\n            variableName +\n            \") that hasn't been declared in the story\"\n        );\n\n      let val = Value.Create(value);\n      if (val == null) {\n        if (value == null) {\n          throw new Error(\"Cannot pass null to VariableState\");\n        } else {\n          throw new Error(\n            \"Invalid value passed to VariableState: \" + value.toString()\n          );\n        }\n      }\n\n      this.SetGlobal(variableName, val);\n    }\n  }\n\n  constructor(\n    callStack: CallStack,\n    listDefsOrigin: ListDefinitionsOrigin | null\n  ) {\n    super();\n    this._globalVariables = new Map();\n    this._callStack = callStack;\n    this._listDefsOrigin = listDefsOrigin;\n\n    // if es6 proxies are available, use them.\n    try {\n      // the proxy is used to allow direct manipulation of global variables.\n      // It first tries to access the objects own property, and if none is\n      // found it delegates the call to the $ method, defined below\n      let p = new Proxy(this, {\n        get(target: any, name) {\n          return name in target ? target[name] : target.$(name);\n        },\n        set(target: any, name, value) {\n          if (name in target) target[name] = value;\n          else target.$(name, value);\n          return true; // returning a falsy value make the trap fail\n        },\n      });\n\n      return p;\n    } catch (e) {\n      // the proxy object is not available in this context. we should warn the\n      // dev but writing to the console feels a bit intrusive.\n      // console.log(\"ES6 Proxy not available - direct manipulation of global variables can't work, use $() instead.\");\n    }\n  }\n\n  public ApplyPatch() {\n    if (this.patch === null) {\n      return throwNullException(\"this.patch\");\n    }\n\n    for (let [namedVarKey, namedVarValue] of this.patch.globals) {\n      this._globalVariables.set(namedVarKey, namedVarValue);\n    }\n\n    if (this._changedVariablesForBatchObs !== null) {\n      for (let name of this.patch.changedVariables) {\n        this._changedVariablesForBatchObs.add(name);\n      }\n    }\n\n    this.patch = null;\n  }\n\n  public SetJsonToken(jToken: Record<string, any>) {\n    this._globalVariables.clear();\n\n    for (let [varValKey, varValValue] of this._defaultGlobalVariables) {\n      let loadedToken = jToken[varValKey];\n      if (typeof loadedToken !== \"undefined\") {\n        let tokenInkObject =\n          JsonSerialisation.JTokenToRuntimeObject(loadedToken);\n        if (tokenInkObject === null) {\n          return throwNullException(\"tokenInkObject\");\n        }\n        this._globalVariables.set(varValKey, tokenInkObject);\n      } else {\n        this._globalVariables.set(varValKey, varValValue);\n      }\n    }\n  }\n\n  public static dontSaveDefaultValues: boolean = true;\n\n  public WriteJson(writer: SimpleJson.Writer) {\n    writer.WriteObjectStart();\n    for (let [keyValKey, keyValValue] of this._globalVariables) {\n      let name = keyValKey;\n      let val = keyValValue;\n\n      if (VariablesState.dontSaveDefaultValues) {\n        if (this._defaultGlobalVariables.has(name)) {\n          let defaultVal = this._defaultGlobalVariables.get(name)!;\n          if (this.RuntimeObjectsEqual(val, defaultVal)) continue;\n        }\n      }\n\n      writer.WritePropertyStart(name);\n      JsonSerialisation.WriteRuntimeObject(writer, val);\n      writer.WritePropertyEnd();\n    }\n    writer.WriteObjectEnd();\n  }\n\n  public RuntimeObjectsEqual(\n    obj1: InkObject | null,\n    obj2: InkObject | null\n  ): boolean {\n    if (obj1 === null) {\n      return throwNullException(\"obj1\");\n    }\n    if (obj2 === null) {\n      return throwNullException(\"obj2\");\n    }\n\n    if (obj1.constructor !== obj2.constructor) return false;\n\n    let boolVal = asOrNull(obj1, BoolValue);\n    if (boolVal !== null) {\n      return boolVal.value === asOrThrows(obj2, BoolValue).value;\n    }\n\n    let intVal = asOrNull(obj1, IntValue);\n    if (intVal !== null) {\n      return intVal.value === asOrThrows(obj2, IntValue).value;\n    }\n\n    let floatVal = asOrNull(obj1, FloatValue);\n    if (floatVal !== null) {\n      return floatVal.value === asOrThrows(obj2, FloatValue).value;\n    }\n\n    let val1 = asOrNull(obj1, Value);\n    let val2 = asOrNull(obj2, Value);\n    if (val1 !== null && val2 !== null) {\n      if (isEquatable(val1.valueObject) && isEquatable(val2.valueObject)) {\n        return val1.valueObject.Equals(val2.valueObject);\n      } else {\n        return val1.valueObject === val2.valueObject;\n      }\n    }\n\n    throw new Error(\n      \"FastRoughDefinitelyEquals: Unsupported runtime object type: \" +\n        obj1.constructor.name\n    );\n  }\n\n  public GetVariableWithName(\n    name: string | null,\n    contextIndex: number = -1\n  ): InkObject | null {\n    let varValue = this.GetRawVariableWithName(name, contextIndex);\n\n    // var varPointer = varValue as VariablePointerValue;\n    let varPointer = asOrNull(varValue, VariablePointerValue);\n    if (varPointer !== null) {\n      varValue = this.ValueAtVariablePointer(varPointer);\n    }\n\n    return varValue;\n  }\n\n  public TryGetDefaultVariableValue(name: string | null): InkObject | null {\n    let val = tryGetValueFromMap(this._defaultGlobalVariables, name, null);\n    return val.exists ? val.result : null;\n  }\n\n  public GlobalVariableExistsWithName(name: string) {\n    return (\n      this._globalVariables.has(name) ||\n      (this._defaultGlobalVariables !== null &&\n        this._defaultGlobalVariables.has(name))\n    );\n  }\n\n  public GetRawVariableWithName(name: string | null, contextIndex: number) {\n    let varValue: InkObject | null = null;\n\n    if (contextIndex == 0 || contextIndex == -1) {\n      let variableValue = null;\n      if (this.patch !== null) {\n        variableValue = this.patch.TryGetGlobal(name, null);\n        if (variableValue.exists) return variableValue.result!;\n      }\n\n      // this is a conditional assignment\n      variableValue = tryGetValueFromMap(this._globalVariables, name, null);\n      if (variableValue.exists) return variableValue.result;\n\n      if (this._defaultGlobalVariables !== null) {\n        variableValue = tryGetValueFromMap(\n          this._defaultGlobalVariables,\n          name,\n          null\n        );\n        if (variableValue.exists) return variableValue.result;\n      }\n\n      if (this._listDefsOrigin === null)\n        return throwNullException(\"VariablesState._listDefsOrigin\");\n      let listItemValue = this._listDefsOrigin.FindSingleItemListWithName(name);\n      if (listItemValue) return listItemValue;\n    }\n\n    varValue = this._callStack.GetTemporaryVariableWithName(name, contextIndex);\n\n    return varValue;\n  }\n\n  public ValueAtVariablePointer(pointer: VariablePointerValue) {\n    return this.GetVariableWithName(pointer.variableName, pointer.contextIndex);\n  }\n\n  public Assign(varAss: VariableAssignment, value: InkObject) {\n    let name = varAss.variableName;\n    if (name === null) {\n      return throwNullException(\"name\");\n    }\n    let contextIndex = -1;\n\n    let setGlobal = false;\n    if (varAss.isNewDeclaration) {\n      setGlobal = varAss.isGlobal;\n    } else {\n      setGlobal = this.GlobalVariableExistsWithName(name);\n    }\n\n    if (varAss.isNewDeclaration) {\n      // var varPointer = value as VariablePointerValue;\n      let varPointer = asOrNull(value, VariablePointerValue);\n      if (varPointer !== null) {\n        let fullyResolvedVariablePointer =\n          this.ResolveVariablePointer(varPointer);\n        value = fullyResolvedVariablePointer;\n      }\n    } else {\n      let existingPointer = null;\n      do {\n        // existingPointer = GetRawVariableWithName (name, contextIndex) as VariablePointerValue;\n        existingPointer = asOrNull(\n          this.GetRawVariableWithName(name, contextIndex),\n          VariablePointerValue\n        );\n        if (existingPointer != null) {\n          name = existingPointer.variableName;\n          contextIndex = existingPointer.contextIndex;\n          setGlobal = contextIndex == 0;\n        }\n      } while (existingPointer != null);\n    }\n\n    if (setGlobal) {\n      this.SetGlobal(name, value);\n    } else {\n      this._callStack.SetTemporaryVariable(\n        name,\n        value,\n        varAss.isNewDeclaration,\n        contextIndex\n      );\n    }\n  }\n\n  public SnapshotDefaultGlobals() {\n    this._defaultGlobalVariables = new Map(this._globalVariables);\n  }\n\n  public RetainListOriginsForAssignment(\n    oldValue: InkObject,\n    newValue: InkObject\n  ) {\n    let oldList = asOrThrows(oldValue, ListValue);\n    let newList = asOrThrows(newValue, ListValue);\n\n    if (oldList.value && newList.value && newList.value.Count == 0) {\n      newList.value.SetInitialOriginNames(oldList.value.originNames);\n    }\n  }\n\n  public SetGlobal(variableName: string | null, value: InkObject) {\n    let oldValue = null;\n\n    if (this.patch === null) {\n      oldValue = tryGetValueFromMap(this._globalVariables, variableName, null);\n    }\n\n    if (this.patch !== null) {\n      oldValue = this.patch.TryGetGlobal(variableName, null);\n      if (!oldValue.exists) {\n        oldValue = tryGetValueFromMap(\n          this._globalVariables,\n          variableName,\n          null\n        );\n      }\n    }\n\n    ListValue.RetainListOriginsForAssignment(oldValue!.result!, value);\n\n    if (variableName === null) {\n      return throwNullException(\"variableName\");\n    }\n\n    if (this.patch !== null) {\n      this.patch.SetGlobal(variableName, value);\n    } else {\n      this._globalVariables.set(variableName, value);\n    }\n\n    // TODO: Not sure !== is equivalent to !value.Equals(oldValue)\n    if (\n      this.variableChangedEvent !== null &&\n      oldValue !== null &&\n      value !== oldValue.result\n    ) {\n      if (this.batchObservingVariableChanges) {\n        if (this._changedVariablesForBatchObs === null) {\n          return throwNullException(\"this._changedVariablesForBatchObs\");\n        }\n\n        if (this.patch !== null) {\n          this.patch.AddChangedVariable(variableName);\n        } else if (this._changedVariablesForBatchObs !== null) {\n          this._changedVariablesForBatchObs.add(variableName);\n        }\n      } else {\n        this.variableChangedEvent(variableName, value);\n      }\n    }\n  }\n\n  public ResolveVariablePointer(varPointer: VariablePointerValue) {\n    let contextIndex = varPointer.contextIndex;\n\n    if (contextIndex == -1)\n      contextIndex = this.GetContextIndexOfVariableNamed(\n        varPointer.variableName\n      );\n\n    let valueOfVariablePointedTo = this.GetRawVariableWithName(\n      varPointer.variableName,\n      contextIndex\n    );\n\n    // var doubleRedirectionPointer = valueOfVariablePointedTo as VariablePointerValue;\n    let doubleRedirectionPointer = asOrNull(\n      valueOfVariablePointedTo,\n      VariablePointerValue\n    );\n    if (doubleRedirectionPointer != null) {\n      return doubleRedirectionPointer;\n    } else {\n      return new VariablePointerValue(varPointer.variableName, contextIndex);\n    }\n  }\n\n  public GetContextIndexOfVariableNamed(varName: string) {\n    if (this.GlobalVariableExistsWithName(varName)) return 0;\n\n    return this._callStack.currentElementIndex;\n  }\n\n  /**\n   * This function is specific to the js version of ink. It allows to register a\n   * callback that will be called when a variable changes. The original code uses\n   * `state.variableChangedEvent += callback` instead.\n   *\n   * @param {function} callback\n   */\n  public ObserveVariableChange(\n    callback: (variableName: string, newValue: InkObject) => void\n  ) {\n    this.variableChangedEventCallbacks.push(callback);\n  }\n\n  private _globalVariables: Map<string, InkObject>;\n  private _defaultGlobalVariables: Map<string, InkObject> = new Map();\n\n  private _callStack: CallStack;\n  private _changedVariablesForBatchObs: Set<string> | null = new Set();\n  private _listDefsOrigin: ListDefinitionsOrigin | null;\n}\n","// Taken from https://gist.github.com/blixt/f17b47c62508be59987b\n// Ink uses a seedable PRNG of which there is none in native javascript.\nexport class PRNG {\n  private seed: number;\n\n  constructor(seed: number) {\n    this.seed = seed % 2147483647;\n    if (this.seed <= 0) this.seed += 2147483646;\n  }\n  public next(): number {\n    return (this.seed = (this.seed * 48271) % 2147483647);\n  }\n  public nextFloat(): number {\n    return (this.next() - 1) / 2147483646;\n  }\n}\n","import { InkObject } from \"./Object\";\nimport { Container } from \"./Container\";\n\nexport class StatePatch {\n  get globals() {\n    return this._globals;\n  }\n  get changedVariables() {\n    return this._changedVariables;\n  }\n  get visitCounts() {\n    return this._visitCounts;\n  }\n  get turnIndices() {\n    return this._turnIndices;\n  }\n\n  constructor();\n  constructor(toCopy: StatePatch | null);\n  constructor() {\n    if (arguments.length === 1 && arguments[0] !== null) {\n      let toCopy = arguments[0] as StatePatch;\n      this._globals = new Map(toCopy._globals);\n      this._changedVariables = new Set(toCopy._changedVariables);\n      this._visitCounts = new Map(toCopy._visitCounts);\n      this._turnIndices = new Map(toCopy._turnIndices);\n    } else {\n      this._globals = new Map();\n      this._changedVariables = new Set();\n      this._visitCounts = new Map();\n      this._turnIndices = new Map();\n    }\n  }\n\n  public TryGetGlobal(name: string | null, /* out */ value: InkObject | null) {\n    if (name !== null && this._globals.has(name)) {\n      return { result: this._globals.get(name), exists: true };\n    }\n\n    return { result: value, exists: false };\n  }\n\n  public SetGlobal(name: string, value: InkObject) {\n    this._globals.set(name, value);\n  }\n\n  public AddChangedVariable(name: string) {\n    return this._changedVariables.add(name);\n  }\n\n  public TryGetVisitCount(container: Container, /* out */ count: number) {\n    if (this._visitCounts.has(container)) {\n      return { result: this._visitCounts.get(container), exists: true };\n    }\n\n    return { result: count, exists: false };\n  }\n\n  public SetVisitCount(container: Container, count: number) {\n    this._visitCounts.set(container, count);\n  }\n\n  public SetTurnIndex(container: Container, index: number) {\n    this._turnIndices.set(container, index);\n  }\n\n  public TryGetTurnIndex(container: Container, /* out */ index: number) {\n    if (this._turnIndices.has(container)) {\n      return { result: this._turnIndices.get(container), exists: true };\n    }\n\n    return { result: index, exists: false };\n  }\n\n  private _globals: Map<string, InkObject>;\n  private _changedVariables: Set<string> = new Set();\n  private _visitCounts: Map<Container, number> = new Map();\n  private _turnIndices: Map<Container, number> = new Map();\n}\n","export class SimpleJson {\n  public static TextToDictionary(text: string) {\n    return new SimpleJson.Reader(text).ToDictionary();\n  }\n\n  public static TextToArray(text: string) {\n    return new SimpleJson.Reader(text).ToArray();\n  }\n}\n\nexport namespace SimpleJson {\n  export class Reader {\n    constructor(text: string) {\n      this._rootObject = JSON.parse(text);\n    }\n\n    public ToDictionary() {\n      return this._rootObject as Record<string, any>;\n    }\n\n    public ToArray() {\n      return this._rootObject as any[];\n    }\n\n    private _rootObject: any[] | Record<string, any>;\n  }\n\n  // In C#, this class writes json tokens directly to a StringWriter or\n  // another stream. Here, a temporary hierarchy is created in the form\n  // of a javascript object, which is serialised in the `toString` method.\n  // See individual methods and properties for more information.\n  export class Writer {\n    public WriteObject(inner: (w: Writer) => void) {\n      this.WriteObjectStart();\n      inner(this);\n      this.WriteObjectEnd();\n    }\n\n    // Add a new object.\n    public WriteObjectStart() {\n      this.StartNewObject(true);\n\n      let newObject: Record<string, any> = {};\n\n      if (this.state === SimpleJson.Writer.State.Property) {\n        // This object is created as the value of a property,\n        // inside an other object.\n        this.Assert(this.currentCollection !== null);\n        this.Assert(this.currentPropertyName !== null);\n\n        let propertyName = this._propertyNameStack.pop();\n        this.currentCollection![propertyName!] = newObject;\n        this._collectionStack.push(newObject);\n      } else if (this.state === SimpleJson.Writer.State.Array) {\n        // This object is created as the child of an array.\n        this.Assert(this.currentCollection !== null);\n\n        this.currentCollection!.push(newObject);\n        this._collectionStack.push(newObject);\n      } else {\n        // This object is the root object.\n        this.Assert(this.state === SimpleJson.Writer.State.None);\n        this._jsonObject = newObject;\n        this._collectionStack.push(newObject);\n      }\n\n      this._stateStack.push(\n        new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.Object)\n      );\n    }\n\n    public WriteObjectEnd() {\n      this.Assert(this.state === SimpleJson.Writer.State.Object);\n      this._collectionStack.pop();\n      this._stateStack.pop();\n    }\n\n    // Write a property name / value pair to the current object.\n    public WriteProperty(\n      name: any,\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      innerOrContent: ((w: Writer) => void) | string | boolean | null\n    ) {\n      this.WritePropertyStart(name);\n      if (arguments[1] instanceof Function) {\n        let inner = arguments[1];\n        inner(this);\n      } else {\n        let content: string | boolean | null = arguments[1];\n        this.Write(content);\n      }\n      this.WritePropertyEnd();\n    }\n\n    // Int and Float are separate calls, since there both are\n    // numbers in JavaScript, but need to be handled differently.\n\n    public WriteIntProperty(name: any, content: number) {\n      this.WritePropertyStart(name);\n      this.WriteInt(content);\n      this.WritePropertyEnd();\n    }\n\n    public WriteFloatProperty(name: any, content: number) {\n      this.WritePropertyStart(name);\n      this.WriteFloat(content);\n      this.WritePropertyEnd();\n    }\n\n    // Prepare a new property name, which will be use to add the\n    // new object when calling _addToCurrentObject() from a Write\n    // method.\n    public WritePropertyStart(name: any) {\n      this.Assert(this.state === SimpleJson.Writer.State.Object);\n      this._propertyNameStack.push(name);\n\n      this.IncrementChildCount();\n\n      this._stateStack.push(\n        new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.Property)\n      );\n    }\n\n    public WritePropertyEnd() {\n      this.Assert(this.state === SimpleJson.Writer.State.Property);\n      this.Assert(this.childCount === 1);\n      this._stateStack.pop();\n    }\n\n    // Prepare a new property name, except this time, the property name\n    // will be created by concatenating all the strings passed to\n    // WritePropertyNameInner.\n    public WritePropertyNameStart() {\n      this.Assert(this.state === SimpleJson.Writer.State.Object);\n      this.IncrementChildCount();\n\n      this._currentPropertyName = \"\";\n\n      this._stateStack.push(\n        new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.Property)\n      );\n      this._stateStack.push(\n        new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.PropertyName)\n      );\n    }\n\n    public WritePropertyNameEnd() {\n      this.Assert(this.state === SimpleJson.Writer.State.PropertyName);\n      this.Assert(this._currentPropertyName !== null);\n      this._propertyNameStack.push(this._currentPropertyName!);\n      this._currentPropertyName = null;\n      this._stateStack.pop();\n    }\n\n    public WritePropertyNameInner(str: string) {\n      this.Assert(this.state === SimpleJson.Writer.State.PropertyName);\n      this.Assert(this._currentPropertyName !== null);\n      this._currentPropertyName += str;\n    }\n\n    // Add a new array.\n    public WriteArrayStart() {\n      this.StartNewObject(true);\n\n      let newObject: any[] = [];\n\n      if (this.state === SimpleJson.Writer.State.Property) {\n        // This array is created as the value of a property,\n        // inside an object.\n        this.Assert(this.currentCollection !== null);\n        this.Assert(this.currentPropertyName !== null);\n\n        let propertyName = this._propertyNameStack.pop();\n        this.currentCollection![propertyName!] = newObject;\n        this._collectionStack.push(newObject);\n      } else if (this.state === SimpleJson.Writer.State.Array) {\n        // This array is created as the child of another array.\n        this.Assert(this.currentCollection !== null);\n\n        this.currentCollection!.push(newObject);\n        this._collectionStack.push(newObject);\n      } else {\n        // This array is the root object.\n        this.Assert(this.state === SimpleJson.Writer.State.None);\n        this._jsonObject = newObject;\n        this._collectionStack.push(newObject);\n      }\n\n      this._stateStack.push(\n        new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.Array)\n      );\n    }\n\n    public WriteArrayEnd() {\n      this.Assert(this.state === SimpleJson.Writer.State.Array);\n      this._collectionStack.pop();\n      this._stateStack.pop();\n    }\n\n    // Add the value to the appropriate collection (array / object), given the current\n    // context.\n    public Write(\n      value: number | string | boolean | null,\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      escape: boolean = true\n    ) {\n      if (value === null) {\n        console.error(\"Warning: trying to write a null value\");\n        return;\n      }\n\n      this.StartNewObject(false);\n      this._addToCurrentObject(value);\n    }\n\n    public WriteBool(value: boolean | null) {\n      if (value === null) {\n        return;\n      }\n\n      this.StartNewObject(false);\n      this._addToCurrentObject(value);\n    }\n\n    public WriteInt(value: number | null) {\n      if (value === null) {\n        return;\n      }\n\n      this.StartNewObject(false);\n\n      // Math.floor is used as a precaution:\n      //     1. to ensure that the value is written as an integer\n      //        (without a fractional part -> 1 instead of 1.0), even\n      //        though it should be the default behaviour of\n      //        JSON.serialize;\n      //     2. to ensure that if a floating number is passed\n      //        accidentally, it's converted to an integer.\n      //\n      // This guarantees savegame compatibility with the reference\n      // implementation.\n      this._addToCurrentObject(Math.floor(value));\n    }\n\n    // Since JSON doesn't support NaN and Infinity, these values\n    // are converted here.\n    public WriteFloat(value: number | null) {\n      if (value === null) {\n        return;\n      }\n\n      this.StartNewObject(false);\n      if (value == Number.POSITIVE_INFINITY) {\n        this._addToCurrentObject(3.4e38);\n      } else if (value == Number.NEGATIVE_INFINITY) {\n        this._addToCurrentObject(-3.4e38);\n      } else if (isNaN(value)) {\n        this._addToCurrentObject(0.0);\n      } else {\n        this._addToCurrentObject(value);\n      }\n    }\n\n    public WriteNull() {\n      this.StartNewObject(false);\n      this._addToCurrentObject(null);\n    }\n\n    // Prepare a string before adding it to the current collection in\n    // WriteStringEnd(). The string will be a concatenation of all the\n    // strings passed to WriteStringInner.\n    public WriteStringStart() {\n      this.StartNewObject(false);\n      this._currentString = \"\";\n      this._stateStack.push(\n        new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.String)\n      );\n    }\n\n    public WriteStringEnd() {\n      this.Assert(this.state == SimpleJson.Writer.State.String);\n      this._stateStack.pop();\n      this._addToCurrentObject(this._currentString);\n      this._currentString = null;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    public WriteStringInner(str: string | null, escape: boolean = true) {\n      this.Assert(this.state === SimpleJson.Writer.State.String);\n\n      if (str === null) {\n        console.error(\"Warning: trying to write a null string\");\n        return;\n      }\n\n      this._currentString += str;\n    }\n\n    // Serialise the root object into a JSON string.\n    public toString() {\n      if (this._jsonObject === null) {\n        return \"\";\n      }\n\n      return JSON.stringify(this._jsonObject);\n    }\n\n    // Prepare the state stack when adding new objects / values.\n    private StartNewObject(container: boolean) {\n      if (container) {\n        this.Assert(\n          this.state === SimpleJson.Writer.State.None ||\n            this.state === SimpleJson.Writer.State.Property ||\n            this.state === SimpleJson.Writer.State.Array\n        );\n      } else {\n        this.Assert(\n          this.state === SimpleJson.Writer.State.Property ||\n            this.state === SimpleJson.Writer.State.Array\n        );\n      }\n\n      if (this.state === SimpleJson.Writer.State.Property) {\n        this.Assert(this.childCount === 0);\n      }\n\n      if (\n        this.state === SimpleJson.Writer.State.Array ||\n        this.state === SimpleJson.Writer.State.Property\n      ) {\n        this.IncrementChildCount();\n      }\n    }\n\n    // These getters peek all the different stacks.\n\n    private get state() {\n      if (this._stateStack.length > 0) {\n        return this._stateStack[this._stateStack.length - 1].type;\n      } else {\n        return SimpleJson.Writer.State.None;\n      }\n    }\n\n    private get childCount() {\n      if (this._stateStack.length > 0) {\n        return this._stateStack[this._stateStack.length - 1].childCount;\n      } else {\n        return 0;\n      }\n    }\n\n    private get currentCollection() {\n      if (this._collectionStack.length > 0) {\n        return this._collectionStack[this._collectionStack.length - 1];\n      } else {\n        return null;\n      }\n    }\n\n    private get currentPropertyName() {\n      if (this._propertyNameStack.length > 0) {\n        return this._propertyNameStack[this._propertyNameStack.length - 1];\n      } else {\n        return null;\n      }\n    }\n\n    private IncrementChildCount() {\n      this.Assert(this._stateStack.length > 0);\n      let currEl = this._stateStack.pop()!;\n      currEl.childCount++;\n      this._stateStack.push(currEl);\n    }\n\n    private Assert(condition: boolean) {\n      if (!condition) throw Error(\"Assert failed while writing JSON\");\n    }\n\n    // This method did not exist in the original C# code. It adds\n    // the given value to the current collection (used by Write methods).\n    private _addToCurrentObject(value: number | string | boolean | null) {\n      this.Assert(this.currentCollection !== null);\n      if (this.state === SimpleJson.Writer.State.Array) {\n        this.Assert(Array.isArray(this.currentCollection));\n        (this.currentCollection as any[]).push(value);\n      } else if (this.state === SimpleJson.Writer.State.Property) {\n        this.Assert(!Array.isArray(this.currentCollection));\n        this.Assert(this.currentPropertyName !== null);\n        (this.currentCollection as Record<string, any>)[\n          this.currentPropertyName!\n        ] = value;\n        this._propertyNameStack.pop();\n      }\n    }\n\n    // In addition to `_stateStack` present in the original code,\n    // this implementation of SimpleJson use two other stacks and two\n    // temporary variables holding the current context.\n\n    // Used to keep track of the current property name being built\n    // with `WritePropertyNameStart`, `WritePropertyNameInner` and\n    // `WritePropertyNameEnd`.\n    private _currentPropertyName: string | null = null;\n\n    // Used to keep track of the current string value being built\n    // with `WriteStringStart`, `WriteStringInner` and\n    // `WriteStringEnd`.\n    private _currentString: string | null = null;\n\n    private _stateStack: SimpleJson.Writer.StateElement[] = [];\n\n    // Keep track of the current collection being built (either an array\n    // or an object). For instance, at the '?' step during the hiarchy\n    // creation, this hierarchy:\n    // [3, {a: [b, ?]}] will have this corresponding stack:\n    // (bottom) [Array, Object, Array] (top)\n    private _collectionStack: Array<any[] | Record<string, any>> = [];\n\n    // Keep track of the current property being assigned. For instance, at\n    // the '?' step during the hiarchy creation, this hierarchy:\n    // [3, {a: [b, {c: ?}]}] will have this corresponding stack:\n    // (bottom) [a, c] (top)\n    private _propertyNameStack: string[] = [];\n\n    // Object containing the entire hiearchy.\n    private _jsonObject: Record<string, any> | any[] | null = null;\n  }\n\n  export namespace Writer {\n    export enum State {\n      None,\n      Object,\n      Array,\n      Property,\n      PropertyName,\n      String,\n    }\n\n    export class StateElement {\n      public type: SimpleJson.Writer.State = SimpleJson.Writer.State.None;\n      public childCount: number = 0;\n\n      constructor(type: SimpleJson.Writer.State) {\n        this.type = type;\n      }\n    }\n  }\n}\n","import { CallStack } from \"./CallStack\";\nimport { Choice } from \"./Choice\";\nimport { JsonSerialisation } from \"./JsonSerialisation\";\nimport { InkObject } from \"./Object\";\nimport { SimpleJson } from \"./SimpleJson\";\nimport { Story } from \"./Story\";\nimport { throwNullException } from \"./NullException\";\n\nexport class Flow {\n  public name: string;\n  public callStack: CallStack;\n  public outputStream: InkObject[];\n  public currentChoices: Choice[];\n\n  constructor(name: String, story: Story);\n  constructor(name: String, story: Story, jObject: Record<string, any>);\n  constructor() {\n    let name = arguments[0] as string;\n    let story = arguments[1] as Story;\n\n    this.name = name;\n    this.callStack = new CallStack(story);\n\n    if (arguments[2]) {\n      let jObject = arguments[2] as Record<string, any>;\n\n      this.callStack.SetJsonToken(jObject[\"callstack\"], story);\n      this.outputStream = JsonSerialisation.JArrayToRuntimeObjList(\n        jObject[\"outputStream\"]\n      );\n      this.currentChoices = JsonSerialisation.JArrayToRuntimeObjList(\n        jObject[\"currentChoices\"]\n      ) as Choice[];\n\n      let jChoiceThreadsObj = jObject[\"choiceThreads\"];\n      if (typeof jChoiceThreadsObj !== \"undefined\") {\n        this.LoadFlowChoiceThreads(jChoiceThreadsObj, story);\n      }\n    } else {\n      this.outputStream = [];\n      this.currentChoices = [];\n    }\n  }\n\n  public WriteJson(writer: SimpleJson.Writer) {\n    writer.WriteObjectStart();\n\n    writer.WriteProperty(\"callstack\", (w) => this.callStack.WriteJson(w));\n    writer.WriteProperty(\"outputStream\", (w) =>\n      JsonSerialisation.WriteListRuntimeObjs(w, this.outputStream)\n    );\n\n    let hasChoiceThreads = false;\n    for (let c of this.currentChoices) {\n      if (c.threadAtGeneration === null)\n        return throwNullException(\"c.threadAtGeneration\");\n\n      c.originalThreadIndex = c.threadAtGeneration.threadIndex;\n\n      if (this.callStack.ThreadWithIndex(c.originalThreadIndex) === null) {\n        if (!hasChoiceThreads) {\n          hasChoiceThreads = true;\n          writer.WritePropertyStart(\"choiceThreads\");\n          writer.WriteObjectStart();\n        }\n\n        writer.WritePropertyStart(c.originalThreadIndex);\n        c.threadAtGeneration.WriteJson(writer);\n        writer.WritePropertyEnd();\n      }\n    }\n\n    if (hasChoiceThreads) {\n      writer.WriteObjectEnd();\n      writer.WritePropertyEnd();\n    }\n\n    writer.WriteProperty(\"currentChoices\", (w) => {\n      w.WriteArrayStart();\n      for (let c of this.currentChoices) {\n        JsonSerialisation.WriteChoice(w, c);\n      }\n      w.WriteArrayEnd();\n    });\n\n    writer.WriteObjectEnd();\n  }\n\n  public LoadFlowChoiceThreads(\n    jChoiceThreads: Record<string, any>,\n    story: Story\n  ) {\n    for (let choice of this.currentChoices) {\n      let foundActiveThread = this.callStack.ThreadWithIndex(\n        choice.originalThreadIndex\n      );\n      if (foundActiveThread !== null) {\n        choice.threadAtGeneration = foundActiveThread.Copy();\n      } else {\n        let jSavedChoiceThread =\n          jChoiceThreads[`${choice.originalThreadIndex}`];\n        choice.threadAtGeneration = new CallStack.Thread(\n          jSavedChoiceThread,\n          story\n        );\n      }\n    }\n  }\n}\n","// TODO: Unify with Compiler.\n\nexport type ErrorHandler = (message: string, type: ErrorType) => void;\n\nexport enum ErrorType {\n  Author,\n  Warning,\n  Error,\n}\n","import { Container } from \"./Container\";\nimport { InkObject } from \"./Object\";\nimport { JsonSerialisation } from \"./JsonSerialisation\";\nimport { StoryState } from \"./StoryState\";\nimport { ControlCommand } from \"./ControlCommand\";\nimport { PushPopType } from \"./PushPop\";\nimport { ChoicePoint } from \"./ChoicePoint\";\nimport { Choice } from \"./Choice\";\nimport { Divert } from \"./Divert\";\nimport {\n  Value,\n  StringValue,\n  IntValue,\n  DivertTargetValue,\n  VariablePointerValue,\n  ListValue,\n} from \"./Value\";\nimport { Path } from \"./Path\";\nimport { Void } from \"./Void\";\nimport { Tag } from \"./Tag\";\nimport { VariableAssignment } from \"./VariableAssignment\";\nimport { VariableReference } from \"./VariableReference\";\nimport { NativeFunctionCall } from \"./NativeFunctionCall\";\nimport { StoryException } from \"./StoryException\";\nimport { PRNG } from \"./PRNG\";\nimport { StringBuilder } from \"./StringBuilder\";\nimport { ListDefinitionsOrigin } from \"./ListDefinitionsOrigin\";\nimport { ListDefinition } from \"./ListDefinition\";\nimport { Stopwatch } from \"./StopWatch\";\nimport { Pointer } from \"./Pointer\";\nimport { InkList, InkListItem, KeyValuePair } from \"./InkList\";\nimport { asOrNull, asOrThrows } from \"./TypeAssertion\";\nimport { DebugMetadata } from \"./DebugMetadata\";\nimport { throwNullException } from \"./NullException\";\nimport { SimpleJson } from \"./SimpleJson\";\nimport { ErrorHandler, ErrorType } from \"./Error\";\n\nexport { InkList } from \"./InkList\";\n\nif (!Number.isInteger) {\n  Number.isInteger = function isInteger(nVal: any) {\n    return (\n      typeof nVal === \"number\" &&\n      isFinite(nVal) &&\n      nVal > -9007199254740992 &&\n      nVal < 9007199254740992 &&\n      Math.floor(nVal) === nVal\n    );\n  };\n}\n\nexport class Story extends InkObject {\n  public static inkVersionCurrent = 21;\n\n  public inkVersionMinimumCompatible = 18;\n\n  get currentChoices() {\n    let choices: Choice[] = [];\n\n    if (this._state === null) {\n      return throwNullException(\"this._state\");\n    }\n    for (let c of this._state.currentChoices) {\n      if (!c.isInvisibleDefault) {\n        c.index = choices.length;\n        choices.push(c);\n      }\n    }\n\n    return choices;\n  }\n\n  get currentText() {\n    this.IfAsyncWeCant(\"call currentText since it's a work in progress\");\n    return this.state.currentText;\n  }\n\n  get currentTags() {\n    this.IfAsyncWeCant(\"call currentTags since it's a work in progress\");\n    return this.state.currentTags;\n  }\n\n  get currentErrors() {\n    return this.state.currentErrors;\n  }\n\n  get currentWarnings() {\n    return this.state.currentWarnings;\n  }\n\n  get currentFlowName() {\n    return this.state.currentFlowName;\n  }\n\n  get currentFlowIsDefaultFlow() {\n    return this.state.currentFlowIsDefaultFlow;\n  }\n\n  get aliveFlowNames() {\n    return this.state.aliveFlowNames;\n  }\n\n  get hasError() {\n    return this.state.hasError;\n  }\n\n  get hasWarning() {\n    return this.state.hasWarning;\n  }\n\n  get variablesState() {\n    return this.state.variablesState;\n  }\n\n  get listDefinitions() {\n    return this._listDefinitions;\n  }\n\n  get state() {\n    return this._state;\n  }\n\n  public onError: ErrorHandler | null = null;\n\n  public onDidContinue: (() => void) | null = null;\n\n  public onMakeChoice: ((arg1: Choice) => void) | null = null;\n\n  public onEvaluateFunction: ((arg1: string, arg2: any[]) => void) | null =\n    null;\n\n  public onCompleteEvaluateFunction:\n    | ((arg1: string, arg2: any[], arg3: string, arg4: any) => void)\n    | null = null;\n\n  public onChoosePathString: ((arg1: string, arg2: any[]) => void) | null =\n    null;\n\n  // TODO: Implement Profiler\n  public StartProfiling() {\n    /* */\n  }\n  public EndProfiling() {\n    /* */\n  }\n\n  constructor(contentContainer: Container, lists: ListDefinition[] | null);\n  constructor(jsonString: string);\n  constructor(json: Record<string, any>);\n  constructor() {\n    super();\n\n    // Discrimination between constructors\n    let contentContainer: Container;\n    let lists: ListDefinition[] | null = null;\n    let json: Record<string, any> | null = null;\n\n    if (arguments[0] instanceof Container) {\n      contentContainer = arguments[0] as Container;\n\n      if (typeof arguments[1] !== \"undefined\") {\n        lists = arguments[1] as ListDefinition[];\n      }\n\n      // ------ Story (Container contentContainer, List<Runtime.ListDefinition> lists = null)\n      this._mainContentContainer = contentContainer;\n      // ------\n    } else {\n      if (typeof arguments[0] === \"string\") {\n        let jsonString = arguments[0] as string;\n        json = SimpleJson.TextToDictionary(jsonString);\n      } else {\n        json = arguments[0] as Record<string, any>;\n      }\n    }\n\n    // ------ Story (Container contentContainer, List<Runtime.ListDefinition> lists = null)\n    if (lists != null) this._listDefinitions = new ListDefinitionsOrigin(lists);\n\n    this._externals = new Map();\n    // ------\n\n    // ------ Story(string jsonString) : this((Container)null)\n    if (json !== null) {\n      let rootObject: Record<string, any> = json;\n\n      let versionObj = rootObject[\"inkVersion\"];\n      if (versionObj == null)\n        throw new Error(\n          \"ink version number not found. Are you sure it's a valid .ink.json file?\"\n        );\n\n      let formatFromFile = parseInt(versionObj);\n      if (formatFromFile > Story.inkVersionCurrent) {\n        throw new Error(\n          \"Version of ink used to build story was newer than the current version of the engine\"\n        );\n      } else if (formatFromFile < this.inkVersionMinimumCompatible) {\n        throw new Error(\n          \"Version of ink used to build story is too old to be loaded by this version of the engine\"\n        );\n      } else if (formatFromFile != Story.inkVersionCurrent) {\n        console.warn(\n          \"WARNING: Version of ink used to build story doesn't match current version of engine. Non-critical, but recommend synchronising.\"\n        );\n      }\n\n      let rootToken = rootObject[\"root\"];\n      if (rootToken == null)\n        throw new Error(\n          \"Root node for ink not found. Are you sure it's a valid .ink.json file?\"\n        );\n\n      let listDefsObj;\n      if ((listDefsObj = rootObject[\"listDefs\"])) {\n        this._listDefinitions =\n          JsonSerialisation.JTokenToListDefinitions(listDefsObj);\n      }\n\n      this._mainContentContainer = asOrThrows(\n        JsonSerialisation.JTokenToRuntimeObject(rootToken),\n        Container\n      );\n\n      this.ResetState();\n    }\n    // ------\n  }\n\n  // Merge together `public string ToJson()` and `void ToJson(SimpleJson.Writer writer)`.\n  // Will only return a value if writer was not provided.\n  public ToJson(writer?: SimpleJson.Writer): string | void {\n    let shouldReturn = false;\n\n    if (!writer) {\n      shouldReturn = true;\n      writer = new SimpleJson.Writer();\n    }\n\n    writer.WriteObjectStart();\n\n    writer.WriteIntProperty(\"inkVersion\", Story.inkVersionCurrent);\n\n    writer.WriteProperty(\"root\", (w) =>\n      JsonSerialisation.WriteRuntimeContainer(w, this._mainContentContainer)\n    );\n\n    if (this._listDefinitions != null) {\n      writer.WritePropertyStart(\"listDefs\");\n      writer.WriteObjectStart();\n\n      for (let def of this._listDefinitions.lists) {\n        writer.WritePropertyStart(def.name);\n        writer.WriteObjectStart();\n\n        for (let [key, value] of def.items) {\n          let item = InkListItem.fromSerializedKey(key);\n          let val = value;\n          writer.WriteIntProperty(item.itemName, val);\n        }\n\n        writer.WriteObjectEnd();\n        writer.WritePropertyEnd();\n      }\n\n      writer.WriteObjectEnd();\n      writer.WritePropertyEnd();\n    }\n\n    writer.WriteObjectEnd();\n\n    if (shouldReturn) return writer.toString();\n  }\n\n  public ResetState() {\n    this.IfAsyncWeCant(\"ResetState\");\n\n    this._state = new StoryState(this);\n    this._state.variablesState.ObserveVariableChange(\n      this.VariableStateDidChangeEvent.bind(this)\n    );\n\n    this.ResetGlobals();\n  }\n\n  public ResetErrors() {\n    if (this._state === null) {\n      return throwNullException(\"this._state\");\n    }\n    this._state.ResetErrors();\n  }\n\n  public ResetCallstack() {\n    this.IfAsyncWeCant(\"ResetCallstack\");\n    if (this._state === null) {\n      return throwNullException(\"this._state\");\n    }\n    this._state.ForceEnd();\n  }\n\n  public ResetGlobals() {\n    if (this._mainContentContainer.namedContent.get(\"global decl\")) {\n      let originalPointer = this.state.currentPointer.copy();\n\n      this.ChoosePath(new Path(\"global decl\"), false);\n\n      this.ContinueInternal();\n\n      this.state.currentPointer = originalPointer;\n    }\n\n    this.state.variablesState.SnapshotDefaultGlobals();\n  }\n\n  public SwitchFlow(flowName: string) {\n    this.IfAsyncWeCant(\"switch flow\");\n    if (this._asyncSaving) {\n      throw new Error(\n        \"Story is already in background saving mode, can't switch flow to \" +\n          flowName\n      );\n    }\n\n    this.state.SwitchFlow_Internal(flowName);\n  }\n\n  public RemoveFlow(flowName: string) {\n    this.state.RemoveFlow_Internal(flowName);\n  }\n\n  public SwitchToDefaultFlow() {\n    this.state.SwitchToDefaultFlow_Internal();\n  }\n\n  public Continue() {\n    this.ContinueAsync(0);\n    return this.currentText;\n  }\n\n  get canContinue() {\n    return this.state.canContinue;\n  }\n\n  get asyncContinueComplete() {\n    return !this._asyncContinueActive;\n  }\n\n  public ContinueAsync(millisecsLimitAsync: number) {\n    if (!this._hasValidatedExternals) this.ValidateExternalBindings();\n\n    this.ContinueInternal(millisecsLimitAsync);\n  }\n\n  public ContinueInternal(millisecsLimitAsync = 0) {\n    if (this._profiler != null) this._profiler.PreContinue();\n\n    let isAsyncTimeLimited = millisecsLimitAsync > 0;\n    this._recursiveContinueCount++;\n\n    if (!this._asyncContinueActive) {\n      this._asyncContinueActive = isAsyncTimeLimited;\n\n      if (!this.canContinue) {\n        throw new Error(\n          \"Can't continue - should check canContinue before calling Continue\"\n        );\n      }\n\n      this._state.didSafeExit = false;\n      this._state.ResetOutput();\n\n      if (this._recursiveContinueCount == 1)\n        this._state.variablesState.batchObservingVariableChanges = true;\n    }\n\n    let durationStopwatch = new Stopwatch();\n    durationStopwatch.Start();\n\n    let outputStreamEndsInNewline = false;\n    this._sawLookaheadUnsafeFunctionAfterNewline = false;\n    do {\n      try {\n        outputStreamEndsInNewline = this.ContinueSingleStep();\n      } catch (e) {\n        if (!(e instanceof StoryException)) throw e;\n\n        this.AddError(e.message, undefined, e.useEndLineNumber);\n        break;\n      }\n\n      if (outputStreamEndsInNewline) break;\n\n      if (\n        this._asyncContinueActive &&\n        durationStopwatch.ElapsedMilliseconds > millisecsLimitAsync\n      ) {\n        break;\n      }\n    } while (this.canContinue);\n\n    durationStopwatch.Stop();\n\n    if (outputStreamEndsInNewline || !this.canContinue) {\n      if (this._stateSnapshotAtLastNewline !== null) {\n        this.RestoreStateSnapshot();\n      }\n\n      if (!this.canContinue) {\n        if (this.state.callStack.canPopThread)\n          this.AddError(\n            \"Thread available to pop, threads should always be flat by the end of evaluation?\"\n          );\n\n        if (\n          this.state.generatedChoices.length == 0 &&\n          !this.state.didSafeExit &&\n          this._temporaryEvaluationContainer == null\n        ) {\n          if (this.state.callStack.CanPop(PushPopType.Tunnel))\n            this.AddError(\n              \"unexpectedly reached end of content. Do you need a '->->' to return from a tunnel?\"\n            );\n          else if (this.state.callStack.CanPop(PushPopType.Function))\n            this.AddError(\n              \"unexpectedly reached end of content. Do you need a '~ return'?\"\n            );\n          else if (!this.state.callStack.canPop)\n            this.AddError(\n              \"ran out of content. Do you need a '-> DONE' or '-> END'?\"\n            );\n          else\n            this.AddError(\n              \"unexpectedly reached end of content for unknown reason. Please debug compiler!\"\n            );\n        }\n      }\n\n      this.state.didSafeExit = false;\n      this._sawLookaheadUnsafeFunctionAfterNewline = false;\n\n      if (this._recursiveContinueCount == 1)\n        this._state.variablesState.batchObservingVariableChanges = false;\n\n      this._asyncContinueActive = false;\n      if (this.onDidContinue !== null) this.onDidContinue();\n    }\n\n    this._recursiveContinueCount--;\n\n    if (this._profiler != null) this._profiler.PostContinue();\n\n    // In the following code, we're masking a lot of non-null assertion,\n    // because testing for against `hasError` or `hasWarning` makes sure\n    // the arrays are present and contain at least one element.\n    if (this.state.hasError || this.state.hasWarning) {\n      if (this.onError !== null) {\n        if (this.state.hasError) {\n          for (let err of this.state.currentErrors!) {\n            this.onError(err, ErrorType.Error);\n          }\n        }\n        if (this.state.hasWarning) {\n          for (let err of this.state.currentWarnings!) {\n            this.onError(err, ErrorType.Warning);\n          }\n        }\n        this.ResetErrors();\n      } else {\n        let sb = new StringBuilder();\n        sb.Append(\"Ink had \");\n        if (this.state.hasError) {\n          sb.Append(`${this.state.currentErrors!.length}`);\n          sb.Append(\n            this.state.currentErrors!.length == 1 ? \" error\" : \"errors\"\n          );\n          if (this.state.hasWarning) sb.Append(\" and \");\n        }\n        if (this.state.hasWarning) {\n          sb.Append(`${this.state.currentWarnings!.length}`);\n          sb.Append(\n            this.state.currentWarnings!.length == 1 ? \" warning\" : \"warnings\"\n          );\n          if (this.state.hasWarning) sb.Append(\" and \");\n        }\n        sb.Append(\n          \". It is strongly suggested that you assign an error handler to story.onError. The first issue was: \"\n        );\n        sb.Append(\n          this.state.hasError\n            ? this.state.currentErrors![0]\n            : this.state.currentWarnings![0]\n        );\n\n        throw new StoryException(sb.toString());\n      }\n    }\n  }\n\n  public ContinueSingleStep() {\n    if (this._profiler != null) this._profiler.PreStep();\n\n    this.Step();\n\n    if (this._profiler != null) this._profiler.PostStep();\n\n    if (!this.canContinue && !this.state.callStack.elementIsEvaluateFromGame) {\n      this.TryFollowDefaultInvisibleChoice();\n    }\n\n    if (this._profiler != null) this._profiler.PreSnapshot();\n\n    if (!this.state.inStringEvaluation) {\n      if (this._stateSnapshotAtLastNewline !== null) {\n        if (this._stateSnapshotAtLastNewline.currentTags === null) {\n          return throwNullException(\"this._stateAtLastNewline.currentTags\");\n        }\n        if (this.state.currentTags === null) {\n          return throwNullException(\"this.state.currentTags\");\n        }\n\n        let change = this.CalculateNewlineOutputStateChange(\n          this._stateSnapshotAtLastNewline.currentText,\n          this.state.currentText,\n          this._stateSnapshotAtLastNewline.currentTags.length,\n          this.state.currentTags.length\n        );\n\n        if (\n          change == Story.OutputStateChange.ExtendedBeyondNewline ||\n          this._sawLookaheadUnsafeFunctionAfterNewline\n        ) {\n          this.RestoreStateSnapshot();\n\n          return true;\n        } else if (change == Story.OutputStateChange.NewlineRemoved) {\n          this.DiscardSnapshot();\n        }\n      }\n\n      if (this.state.outputStreamEndsInNewline) {\n        if (this.canContinue) {\n          if (this._stateSnapshotAtLastNewline == null) this.StateSnapshot();\n        } else {\n          this.DiscardSnapshot();\n        }\n      }\n    }\n\n    if (this._profiler != null) this._profiler.PostSnapshot();\n\n    return false;\n  }\n\n  public CalculateNewlineOutputStateChange(\n    prevText: string | null,\n    currText: string | null,\n    prevTagCount: number,\n    currTagCount: number\n  ) {\n    if (prevText === null) {\n      return throwNullException(\"prevText\");\n    }\n    if (currText === null) {\n      return throwNullException(\"currText\");\n    }\n\n    let newlineStillExists =\n      currText.length >= prevText.length &&\n      prevText.length > 0 &&\n      currText.charAt(prevText.length - 1) == \"\\n\";\n    if (\n      prevTagCount == currTagCount &&\n      prevText.length == currText.length &&\n      newlineStillExists\n    )\n      return Story.OutputStateChange.NoChange;\n\n    if (!newlineStillExists) {\n      return Story.OutputStateChange.NewlineRemoved;\n    }\n\n    if (currTagCount > prevTagCount)\n      return Story.OutputStateChange.ExtendedBeyondNewline;\n\n    for (let i = prevText.length; i < currText.length; i++) {\n      let c = currText.charAt(i);\n      if (c != \" \" && c != \"\\t\") {\n        return Story.OutputStateChange.ExtendedBeyondNewline;\n      }\n    }\n\n    return Story.OutputStateChange.NoChange;\n  }\n\n  public ContinueMaximally() {\n    this.IfAsyncWeCant(\"ContinueMaximally\");\n\n    let sb = new StringBuilder();\n\n    while (this.canContinue) {\n      sb.Append(this.Continue());\n    }\n\n    return sb.toString();\n  }\n\n  public ContentAtPath(path: Path) {\n    return this.mainContentContainer.ContentAtPath(path);\n  }\n\n  public KnotContainerWithName(name: string) {\n    let namedContainer = this.mainContentContainer.namedContent.get(name);\n    if (namedContainer instanceof Container) return namedContainer;\n    else return null;\n  }\n\n  public PointerAtPath(path: Path) {\n    if (path.length == 0) return Pointer.Null;\n\n    let p = new Pointer();\n\n    let pathLengthToUse = path.length;\n\n    let result = null;\n    if (path.lastComponent === null) {\n      return throwNullException(\"path.lastComponent\");\n    }\n\n    if (path.lastComponent.isIndex) {\n      pathLengthToUse = path.length - 1;\n      result = this.mainContentContainer.ContentAtPath(\n        path,\n        undefined,\n        pathLengthToUse\n      );\n      p.container = result.container;\n      p.index = path.lastComponent.index;\n    } else {\n      result = this.mainContentContainer.ContentAtPath(path);\n      p.container = result.container;\n      p.index = -1;\n    }\n\n    if (\n      result.obj == null ||\n      (result.obj == this.mainContentContainer && pathLengthToUse > 0)\n    ) {\n      this.Error(\n        \"Failed to find content at path '\" +\n          path +\n          \"', and no approximation of it was possible.\"\n      );\n    } else if (result.approximate)\n      this.Warning(\n        \"Failed to find content at path '\" +\n          path +\n          \"', so it was approximated to: '\" +\n          result.obj.path +\n          \"'.\"\n      );\n\n    return p;\n  }\n\n  public StateSnapshot() {\n    this._stateSnapshotAtLastNewline = this._state;\n    this._state = this._state.CopyAndStartPatching();\n  }\n\n  public RestoreStateSnapshot() {\n    if (this._stateSnapshotAtLastNewline === null) {\n      throwNullException(\"_stateSnapshotAtLastNewline\");\n    }\n    this._stateSnapshotAtLastNewline.RestoreAfterPatch();\n\n    this._state = this._stateSnapshotAtLastNewline;\n    this._stateSnapshotAtLastNewline = null;\n\n    if (!this._asyncSaving) {\n      this._state.ApplyAnyPatch();\n    }\n  }\n\n  public DiscardSnapshot() {\n    if (!this._asyncSaving) this._state.ApplyAnyPatch();\n\n    this._stateSnapshotAtLastNewline = null;\n  }\n\n  public CopyStateForBackgroundThreadSave() {\n    this.IfAsyncWeCant(\"start saving on a background thread\");\n\n    if (this._asyncSaving)\n      throw new Error(\n        \"Story is already in background saving mode, can't call CopyStateForBackgroundThreadSave again!\"\n      );\n\n    let stateToSave = this._state;\n    this._state = this._state.CopyAndStartPatching();\n    this._asyncSaving = true;\n    return stateToSave;\n  }\n\n  public BackgroundSaveComplete() {\n    if (this._stateSnapshotAtLastNewline === null) {\n      this._state.ApplyAnyPatch();\n    }\n\n    this._asyncSaving = false;\n  }\n\n  public Step() {\n    let shouldAddToStream = true;\n\n    let pointer = this.state.currentPointer.copy();\n    if (pointer.isNull) {\n      return;\n    }\n\n    // Container containerToEnter = pointer.Resolve () as Container;\n    let containerToEnter = asOrNull(pointer.Resolve(), Container);\n\n    while (containerToEnter) {\n      this.VisitContainer(containerToEnter, true);\n\n      // No content? the most we can do is step past it\n      if (containerToEnter.content.length == 0) {\n        break;\n      }\n\n      pointer = Pointer.StartOf(containerToEnter);\n      // containerToEnter = pointer.Resolve() as Container;\n      containerToEnter = asOrNull(pointer.Resolve(), Container);\n    }\n\n    this.state.currentPointer = pointer.copy();\n\n    if (this._profiler != null) this._profiler.Step(this.state.callStack);\n\n    // Is the current content object:\n    //  - Normal content\n    //  - Or a logic/flow statement - if so, do it\n    // Stop flow if we hit a stack pop when we're unable to pop (e.g. return/done statement in knot\n    // that was diverted to rather than called as a function)\n    let currentContentObj = pointer.Resolve();\n    let isLogicOrFlowControl =\n      this.PerformLogicAndFlowControl(currentContentObj);\n\n    // Has flow been forced to end by flow control above?\n    if (this.state.currentPointer.isNull) {\n      return;\n    }\n\n    if (isLogicOrFlowControl) {\n      shouldAddToStream = false;\n    }\n\n    // Choice with condition?\n    // var choicePoint = currentContentObj as ChoicePoint;\n    let choicePoint = asOrNull(currentContentObj, ChoicePoint);\n    if (choicePoint) {\n      let choice = this.ProcessChoice(choicePoint);\n      if (choice) {\n        this.state.generatedChoices.push(choice);\n      }\n\n      currentContentObj = null;\n      shouldAddToStream = false;\n    }\n\n    // If the container has no content, then it will be\n    // the \"content\" itself, but we skip over it.\n    if (currentContentObj instanceof Container) {\n      shouldAddToStream = false;\n    }\n\n    // Content to add to evaluation stack or the output stream\n    if (shouldAddToStream) {\n      // If we're pushing a variable pointer onto the evaluation stack, ensure that it's specific\n      // to our current (possibly temporary) context index. And make a copy of the pointer\n      // so that we're not editing the original runtime object.\n      // var varPointer = currentContentObj as VariablePointerValue;\n      let varPointer = asOrNull(currentContentObj, VariablePointerValue);\n      if (varPointer && varPointer.contextIndex == -1) {\n        // Create new object so we're not overwriting the story's own data\n        let contextIdx = this.state.callStack.ContextForVariableNamed(\n          varPointer.variableName\n        );\n        currentContentObj = new VariablePointerValue(\n          varPointer.variableName,\n          contextIdx\n        );\n      }\n\n      // Expression evaluation content\n      if (this.state.inExpressionEvaluation) {\n        this.state.PushEvaluationStack(currentContentObj);\n      }\n      // Output stream content (i.e. not expression evaluation)\n      else {\n        this.state.PushToOutputStream(currentContentObj);\n      }\n    }\n\n    // Increment the content pointer, following diverts if necessary\n    this.NextContent();\n\n    // Starting a thread should be done after the increment to the content pointer,\n    // so that when returning from the thread, it returns to the content after this instruction.\n    // var controlCmd = currentContentObj as ;\n    let controlCmd = asOrNull(currentContentObj, ControlCommand);\n    if (\n      controlCmd &&\n      controlCmd.commandType == ControlCommand.CommandType.StartThread\n    ) {\n      this.state.callStack.PushThread();\n    }\n  }\n\n  public VisitContainer(container: Container, atStart: boolean) {\n    if (!container.countingAtStartOnly || atStart) {\n      if (container.visitsShouldBeCounted)\n        this.state.IncrementVisitCountForContainer(container);\n\n      if (container.turnIndexShouldBeCounted)\n        this.state.RecordTurnIndexVisitToContainer(container);\n    }\n  }\n\n  private _prevContainers: Container[] = [];\n  public VisitChangedContainersDueToDivert() {\n    let previousPointer = this.state.previousPointer.copy();\n    let pointer = this.state.currentPointer.copy();\n\n    if (pointer.isNull || pointer.index == -1) return;\n\n    this._prevContainers.length = 0;\n    if (!previousPointer.isNull) {\n      // Container prevAncestor = previousPointer.Resolve() as Container ?? previousPointer.container as Container;\n      let resolvedPreviousAncestor = previousPointer.Resolve();\n      let prevAncestor =\n        asOrNull(resolvedPreviousAncestor, Container) ||\n        asOrNull(previousPointer.container, Container);\n      while (prevAncestor) {\n        this._prevContainers.push(prevAncestor);\n        // prevAncestor = prevAncestor.parent as Container;\n        prevAncestor = asOrNull(prevAncestor.parent, Container);\n      }\n    }\n\n    let currentChildOfContainer = pointer.Resolve();\n\n    if (currentChildOfContainer == null) return;\n\n    // Container currentContainerAncestor = currentChildOfContainer.parent as Container;\n    let currentContainerAncestor = asOrNull(\n      currentChildOfContainer.parent,\n      Container\n    );\n    let allChildrenEnteredAtStart = true;\n    while (\n      currentContainerAncestor &&\n      (this._prevContainers.indexOf(currentContainerAncestor) < 0 ||\n        currentContainerAncestor.countingAtStartOnly)\n    ) {\n      // Check whether this ancestor container is being entered at the start,\n      // by checking whether the child object is the first.\n      let enteringAtStart =\n        currentContainerAncestor.content.length > 0 &&\n        currentChildOfContainer == currentContainerAncestor.content[0] &&\n        allChildrenEnteredAtStart;\n\n      if (!enteringAtStart) allChildrenEnteredAtStart = false;\n\n      // Mark a visit to this container\n      this.VisitContainer(currentContainerAncestor, enteringAtStart);\n\n      currentChildOfContainer = currentContainerAncestor;\n      // currentContainerAncestor = currentContainerAncestor.parent as Container;\n      currentContainerAncestor = asOrNull(\n        currentContainerAncestor.parent,\n        Container\n      );\n    }\n  }\n\n  public PopChoiceStringAndTags(tags: string[]) {\n    let choiceOnlyStrVal = asOrThrows(\n      this.state.PopEvaluationStack(),\n      StringValue\n    );\n\n    while (\n      this.state.evaluationStack.length > 0 &&\n      asOrNull(this.state.PeekEvaluationStack(), Tag) != null\n    ) {\n      let tag = asOrNull(this.state.PopEvaluationStack(), Tag);\n      if (tag) tags.push(tag.text);\n    }\n    return choiceOnlyStrVal.value;\n  }\n\n  public ProcessChoice(choicePoint: ChoicePoint) {\n    let showChoice = true;\n\n    // Don't create choice if choice point doesn't pass conditional\n    if (choicePoint.hasCondition) {\n      let conditionValue = this.state.PopEvaluationStack();\n      if (!this.IsTruthy(conditionValue)) {\n        showChoice = false;\n      }\n    }\n\n    let startText = \"\";\n    let choiceOnlyText = \"\";\n    let tags: string[] = [];\n\n    if (choicePoint.hasChoiceOnlyContent) {\n      choiceOnlyText = this.PopChoiceStringAndTags(tags) || \"\";\n    }\n\n    if (choicePoint.hasStartContent) {\n      startText = this.PopChoiceStringAndTags(tags) || \"\";\n    }\n\n    // Don't create choice if player has already read this content\n    if (choicePoint.onceOnly) {\n      let visitCount = this.state.VisitCountForContainer(\n        choicePoint.choiceTarget\n      );\n      if (visitCount > 0) {\n        showChoice = false;\n      }\n    }\n\n    // We go through the full process of creating the choice above so\n    // that we consume the content for it, since otherwise it'll\n    // be shown on the output stream.\n    if (!showChoice) {\n      return null;\n    }\n\n    let choice = new Choice();\n    choice.targetPath = choicePoint.pathOnChoice;\n    choice.sourcePath = choicePoint.path.toString();\n    choice.isInvisibleDefault = choicePoint.isInvisibleDefault;\n    choice.threadAtGeneration = this.state.callStack.ForkThread();\n    choice.tags = tags.reverse(); //C# is a stack\n    choice.text = (startText + choiceOnlyText).replace(/^[ \\t]+|[ \\t]+$/g, \"\");\n\n    return choice;\n  }\n\n  public IsTruthy(obj: InkObject) {\n    let truthy = false;\n    if (obj instanceof Value) {\n      let val = obj;\n\n      if (val instanceof DivertTargetValue) {\n        let divTarget = val;\n        this.Error(\n          \"Shouldn't use a divert target (to \" +\n            divTarget.targetPath +\n            \") as a conditional value. Did you intend a function call 'likeThis()' or a read count check 'likeThis'? (no arrows)\"\n        );\n        return false;\n      }\n\n      return val.isTruthy;\n    }\n    return truthy;\n  }\n\n  public PerformLogicAndFlowControl(contentObj: InkObject | null) {\n    if (contentObj == null) {\n      return false;\n    }\n\n    // Divert\n    if (contentObj instanceof Divert) {\n      let currentDivert = contentObj;\n\n      if (currentDivert.isConditional) {\n        let conditionValue = this.state.PopEvaluationStack();\n\n        // False conditional? Cancel divert\n        if (!this.IsTruthy(conditionValue)) return true;\n      }\n\n      if (currentDivert.hasVariableTarget) {\n        let varName = currentDivert.variableDivertName;\n\n        let varContents =\n          this.state.variablesState.GetVariableWithName(varName);\n\n        if (varContents == null) {\n          this.Error(\n            \"Tried to divert using a target from a variable that could not be found (\" +\n              varName +\n              \")\"\n          );\n        } else if (!(varContents instanceof DivertTargetValue)) {\n          // var intContent = varContents as IntValue;\n          let intContent = asOrNull(varContents, IntValue);\n\n          let errorMessage =\n            \"Tried to divert to a target from a variable, but the variable (\" +\n            varName +\n            \") didn't contain a divert target, it \";\n          if (intContent instanceof IntValue && intContent.value == 0) {\n            errorMessage += \"was empty/null (the value 0).\";\n          } else {\n            errorMessage += \"contained '\" + varContents + \"'.\";\n          }\n\n          this.Error(errorMessage);\n        }\n\n        let target = asOrThrows(varContents, DivertTargetValue);\n        this.state.divertedPointer = this.PointerAtPath(target.targetPath);\n      } else if (currentDivert.isExternal) {\n        this.CallExternalFunction(\n          currentDivert.targetPathString,\n          currentDivert.externalArgs\n        );\n        return true;\n      } else {\n        this.state.divertedPointer = currentDivert.targetPointer.copy();\n      }\n\n      if (currentDivert.pushesToStack) {\n        this.state.callStack.Push(\n          currentDivert.stackPushType,\n          undefined,\n          this.state.outputStream.length\n        );\n      }\n\n      if (this.state.divertedPointer.isNull && !currentDivert.isExternal) {\n        if (\n          currentDivert &&\n          currentDivert.debugMetadata &&\n          currentDivert.debugMetadata.sourceName != null\n        ) {\n          this.Error(\n            \"Divert target doesn't exist: \" +\n              currentDivert.debugMetadata.sourceName\n          );\n        } else {\n          this.Error(\"Divert resolution failed: \" + currentDivert);\n        }\n      }\n\n      return true;\n    }\n\n    // Start/end an expression evaluation? Or print out the result?\n    else if (contentObj instanceof ControlCommand) {\n      let evalCommand = contentObj;\n\n      switch (evalCommand.commandType) {\n        case ControlCommand.CommandType.EvalStart:\n          this.Assert(\n            this.state.inExpressionEvaluation === false,\n            \"Already in expression evaluation?\"\n          );\n          this.state.inExpressionEvaluation = true;\n          break;\n\n        case ControlCommand.CommandType.EvalEnd:\n          this.Assert(\n            this.state.inExpressionEvaluation === true,\n            \"Not in expression evaluation mode\"\n          );\n          this.state.inExpressionEvaluation = false;\n          break;\n\n        case ControlCommand.CommandType.EvalOutput:\n          // If the expression turned out to be empty, there may not be anything on the stack\n          if (this.state.evaluationStack.length > 0) {\n            let output = this.state.PopEvaluationStack();\n\n            // Functions may evaluate to Void, in which case we skip output\n            if (!(output instanceof Void)) {\n              // TODO: Should we really always blanket convert to string?\n              // It would be okay to have numbers in the output stream the\n              // only problem is when exporting text for viewing, it skips over numbers etc.\n              let text = new StringValue(output.toString());\n\n              this.state.PushToOutputStream(text);\n            }\n          }\n          break;\n\n        case ControlCommand.CommandType.NoOp:\n          break;\n\n        case ControlCommand.CommandType.Duplicate:\n          this.state.PushEvaluationStack(this.state.PeekEvaluationStack());\n          break;\n\n        case ControlCommand.CommandType.PopEvaluatedValue:\n          this.state.PopEvaluationStack();\n          break;\n\n        case ControlCommand.CommandType.PopFunction:\n        case ControlCommand.CommandType.PopTunnel:\n          let popType =\n            evalCommand.commandType == ControlCommand.CommandType.PopFunction\n              ? PushPopType.Function\n              : PushPopType.Tunnel;\n\n          let overrideTunnelReturnTarget: DivertTargetValue | null = null;\n          if (popType == PushPopType.Tunnel) {\n            let popped = this.state.PopEvaluationStack();\n            // overrideTunnelReturnTarget = popped as DivertTargetValue;\n            overrideTunnelReturnTarget = asOrNull(popped, DivertTargetValue);\n            if (overrideTunnelReturnTarget === null) {\n              this.Assert(\n                popped instanceof Void,\n                \"Expected void if ->-> doesn't override target\"\n              );\n            }\n          }\n\n          if (this.state.TryExitFunctionEvaluationFromGame()) {\n            break;\n          } else if (\n            this.state.callStack.currentElement.type != popType ||\n            !this.state.callStack.canPop\n          ) {\n            let names: Map<PushPopType, string> = new Map();\n            names.set(\n              PushPopType.Function,\n              \"function return statement (~ return)\"\n            );\n            names.set(PushPopType.Tunnel, \"tunnel onwards statement (->->)\");\n\n            let expected = names.get(this.state.callStack.currentElement.type);\n            if (!this.state.callStack.canPop) {\n              expected = \"end of flow (-> END or choice)\";\n            }\n\n            let errorMsg =\n              \"Found \" + names.get(popType) + \", when expected \" + expected;\n\n            this.Error(errorMsg);\n          } else {\n            this.state.PopCallStack();\n\n            if (overrideTunnelReturnTarget)\n              this.state.divertedPointer = this.PointerAtPath(\n                overrideTunnelReturnTarget.targetPath\n              );\n          }\n          break;\n\n        case ControlCommand.CommandType.BeginString:\n          this.state.PushToOutputStream(evalCommand);\n\n          this.Assert(\n            this.state.inExpressionEvaluation === true,\n            \"Expected to be in an expression when evaluating a string\"\n          );\n          this.state.inExpressionEvaluation = false;\n          break;\n\n        // Leave it to story.currentText and story.currentTags to sort out the text from the tags\n        // This is mostly because we can't always rely on the existence of EndTag, and we don't want\n        // to try and flatten dynamic tags to strings every time \\n is pushed to output\n        case ControlCommand.CommandType.BeginTag:\n          this.state.PushToOutputStream(evalCommand);\n          break;\n\n        // EndTag has 2 modes:\n        //  - When in string evaluation (for choices)\n        //  - Normal\n        //\n        // The only way you could have an EndTag in the middle of\n        // string evaluation is if we're currently generating text for a\n        // choice, such as:\n        //\n        //   + choice # tag\n        //\n        // In the above case, the ink will be run twice:\n        //  - First, to generate the choice text. String evaluation\n        //    will be on, and the final string will be pushed to the\n        //    evaluation stack, ready to be popped to make a Choice\n        //    object.\n        //  - Second, when ink generates text after choosing the choice.\n        //    On this ocassion, it's not in string evaluation mode.\n        //\n        // On the writing side, we disallow manually putting tags within\n        // strings like this:\n        //\n        //   {\"hello # world\"}\n        //\n        // So we know that the tag must be being generated as part of\n        // choice content. Therefore, when the tag has been generated,\n        // we push it onto the evaluation stack in the exact same way\n        // as the string for the choice content.\n        case ControlCommand.CommandType.EndTag: {\n          if (this.state.inStringEvaluation) {\n            let contentStackForTag: InkObject[] = [];\n            let outputCountConsumed = 0;\n            for (let i = this.state.outputStream.length - 1; i >= 0; --i) {\n              let obj = this.state.outputStream[i];\n              outputCountConsumed++;\n\n              // var command = obj as ControlCommand;\n              let command = asOrNull(obj, ControlCommand);\n              if (command != null) {\n                if (\n                  command.commandType == ControlCommand.CommandType.BeginTag\n                ) {\n                  break;\n                } else {\n                  this.Error(\n                    \"Unexpected ControlCommand while extracting tag from choice\"\n                  );\n                  break;\n                }\n              }\n              if (obj instanceof StringValue) {\n                contentStackForTag.push(obj);\n              }\n            }\n\n            // Consume the content that was produced for this string\n            this.state.PopFromOutputStream(outputCountConsumed);\n            // Build string out of the content we collected\n            let sb = new StringBuilder();\n            for (let strVal of contentStackForTag) {\n              sb.Append(strVal.toString());\n            }\n            let choiceTag = new Tag(\n              this.state.CleanOutputWhitespace(sb.toString())\n            );\n            // Pushing to the evaluation stack means it gets picked up\n            // when a Choice is generated from the next Choice Point.\n            this.state.PushEvaluationStack(choiceTag);\n          } else {\n            // Otherwise! Simply push EndTag, so that in the output stream we\n            // have a structure of: [BeginTag, \"the tag content\", EndTag]\n            this.state.PushToOutputStream(evalCommand);\n          }\n          break;\n        }\n\n        case ControlCommand.CommandType.EndString: {\n          let contentStackForString: InkObject[] = [];\n          let contentToRetain: InkObject[] = [];\n\n          let outputCountConsumed = 0;\n          for (let i = this.state.outputStream.length - 1; i >= 0; --i) {\n            let obj = this.state.outputStream[i];\n\n            outputCountConsumed++;\n\n            // var command = obj as ControlCommand;\n            let command = asOrNull(obj, ControlCommand);\n            if (\n              command &&\n              command.commandType == ControlCommand.CommandType.BeginString\n            ) {\n              break;\n            }\n            if (obj instanceof Tag) {\n              contentToRetain.push(obj);\n            }\n            if (obj instanceof StringValue) {\n              contentStackForString.push(obj);\n            }\n          }\n\n          // Consume the content that was produced for this string\n          this.state.PopFromOutputStream(outputCountConsumed);\n\n          // Rescue the tags that we want actually to keep on the output stack\n          // rather than consume as part of the string we're building.\n          // At the time of writing, this only applies to Tag objects generated\n          // by choices, which are pushed to the stack during string generation.\n          for (let rescuedTag of contentToRetain)\n            this.state.PushToOutputStream(rescuedTag);\n\n          // The C# version uses a Stack for contentStackForString, but we're\n          // using a simple array, so we need to reverse it before using it\n          contentStackForString = contentStackForString.reverse();\n\n          // Build string out of the content we collected\n          let sb = new StringBuilder();\n          for (let c of contentStackForString) {\n            sb.Append(c.toString());\n          }\n\n          // Return to expression evaluation (from content mode)\n          this.state.inExpressionEvaluation = true;\n          this.state.PushEvaluationStack(new StringValue(sb.toString()));\n          break;\n        }\n\n        case ControlCommand.CommandType.ChoiceCount:\n          let choiceCount = this.state.generatedChoices.length;\n          this.state.PushEvaluationStack(new IntValue(choiceCount));\n          break;\n\n        case ControlCommand.CommandType.Turns:\n          this.state.PushEvaluationStack(\n            new IntValue(this.state.currentTurnIndex + 1)\n          );\n          break;\n\n        case ControlCommand.CommandType.TurnsSince:\n        case ControlCommand.CommandType.ReadCount:\n          let target = this.state.PopEvaluationStack();\n          if (!(target instanceof DivertTargetValue)) {\n            let extraNote = \"\";\n            if (target instanceof IntValue)\n              extraNote =\n                \". Did you accidentally pass a read count ('knot_name') instead of a target ('-> knot_name')?\";\n            this.Error(\n              \"TURNS_SINCE / READ_COUNT expected a divert target (knot, stitch, label name), but saw \" +\n                target +\n                extraNote\n            );\n            break;\n          }\n\n          // var divertTarget = target as DivertTargetValue;\n          let divertTarget = asOrThrows(target, DivertTargetValue);\n          // var container = ContentAtPath (divertTarget.targetPath).correctObj as Container;\n          let container = asOrNull(\n            this.ContentAtPath(divertTarget.targetPath).correctObj,\n            Container\n          );\n\n          let eitherCount;\n          if (container != null) {\n            if (\n              evalCommand.commandType == ControlCommand.CommandType.TurnsSince\n            )\n              eitherCount = this.state.TurnsSinceForContainer(container);\n            else eitherCount = this.state.VisitCountForContainer(container);\n          } else {\n            if (\n              evalCommand.commandType == ControlCommand.CommandType.TurnsSince\n            )\n              eitherCount = -1;\n            else eitherCount = 0;\n\n            this.Warning(\n              \"Failed to find container for \" +\n                evalCommand.toString() +\n                \" lookup at \" +\n                divertTarget.targetPath.toString()\n            );\n          }\n\n          this.state.PushEvaluationStack(new IntValue(eitherCount));\n          break;\n\n        case ControlCommand.CommandType.Random: {\n          let maxInt = asOrNull(this.state.PopEvaluationStack(), IntValue);\n          let minInt = asOrNull(this.state.PopEvaluationStack(), IntValue);\n\n          if (minInt == null || minInt instanceof IntValue === false)\n            return this.Error(\n              \"Invalid value for minimum parameter of RANDOM(min, max)\"\n            );\n\n          if (maxInt == null || minInt instanceof IntValue === false)\n            return this.Error(\n              \"Invalid value for maximum parameter of RANDOM(min, max)\"\n            );\n\n          // Originally a primitive type, but here, can be null.\n          // TODO: Replace by default value?\n          if (maxInt.value === null) {\n            return throwNullException(\"maxInt.value\");\n          }\n          if (minInt.value === null) {\n            return throwNullException(\"minInt.value\");\n          }\n\n          // This code is differs a bit from the reference implementation, since\n          // JavaScript has no true integers. Hence integer arithmetics and\n          // interger overflows don't apply here. A loss of precision can\n          // happen with big numbers however.\n          //\n          // The case where 'randomRange' is lower than zero is handled below,\n          // so there's no need to test against Number.MIN_SAFE_INTEGER.\n          let randomRange = maxInt.value - minInt.value + 1;\n          if (!isFinite(randomRange) || randomRange > Number.MAX_SAFE_INTEGER) {\n            randomRange = Number.MAX_SAFE_INTEGER;\n            this.Error(\n              \"RANDOM was called with a range that exceeds the size that ink numbers can use.\"\n            );\n          }\n          if (randomRange <= 0)\n            this.Error(\n              \"RANDOM was called with minimum as \" +\n                minInt.value +\n                \" and maximum as \" +\n                maxInt.value +\n                \". The maximum must be larger\"\n            );\n\n          let resultSeed = this.state.storySeed + this.state.previousRandom;\n          let random = new PRNG(resultSeed);\n\n          let nextRandom = random.next();\n          let chosenValue = (nextRandom % randomRange) + minInt.value;\n          this.state.PushEvaluationStack(new IntValue(chosenValue));\n\n          // Next random number (rather than keeping the Random object around)\n          this.state.previousRandom = nextRandom;\n          break;\n        }\n\n        case ControlCommand.CommandType.SeedRandom:\n          let seed = asOrNull(this.state.PopEvaluationStack(), IntValue);\n          if (seed == null || seed instanceof IntValue === false)\n            return this.Error(\"Invalid value passed to SEED_RANDOM\");\n\n          // Originally a primitive type, but here, can be null.\n          // TODO: Replace by default value?\n          if (seed.value === null) {\n            return throwNullException(\"minInt.value\");\n          }\n\n          this.state.storySeed = seed.value;\n          this.state.previousRandom = 0;\n\n          this.state.PushEvaluationStack(new Void());\n          break;\n\n        case ControlCommand.CommandType.VisitIndex:\n          let count =\n            this.state.VisitCountForContainer(\n              this.state.currentPointer.container\n            ) - 1; // index not count\n          this.state.PushEvaluationStack(new IntValue(count));\n          break;\n\n        case ControlCommand.CommandType.SequenceShuffleIndex:\n          let shuffleIndex = this.NextSequenceShuffleIndex();\n          this.state.PushEvaluationStack(new IntValue(shuffleIndex));\n          break;\n\n        case ControlCommand.CommandType.StartThread:\n          // Handled in main step function\n          break;\n\n        case ControlCommand.CommandType.Done:\n          // We may exist in the context of the initial\n          // act of creating the thread, or in the context of\n          // evaluating the content.\n          if (this.state.callStack.canPopThread) {\n            this.state.callStack.PopThread();\n          }\n\n          // In normal flow - allow safe exit without warning\n          else {\n            this.state.didSafeExit = true;\n\n            // Stop flow in current thread\n            this.state.currentPointer = Pointer.Null;\n          }\n\n          break;\n\n        // Force flow to end completely\n        case ControlCommand.CommandType.End:\n          this.state.ForceEnd();\n          break;\n\n        case ControlCommand.CommandType.ListFromInt:\n          // var intVal = state.PopEvaluationStack () as IntValue;\n          let intVal = asOrNull(this.state.PopEvaluationStack(), IntValue);\n          // var listNameVal = state.PopEvaluationStack () as StringValue;\n          let listNameVal = asOrThrows(\n            this.state.PopEvaluationStack(),\n            StringValue\n          );\n\n          if (intVal === null) {\n            throw new StoryException(\n              \"Passed non-integer when creating a list element from a numerical value.\"\n            );\n          }\n\n          let generatedListValue = null;\n\n          if (this.listDefinitions === null) {\n            return throwNullException(\"this.listDefinitions\");\n          }\n          let foundListDef = this.listDefinitions.TryListGetDefinition(\n            listNameVal.value,\n            null\n          );\n          if (foundListDef.exists) {\n            // Originally a primitive type, but here, can be null.\n            // TODO: Replace by default value?\n            if (intVal.value === null) {\n              return throwNullException(\"minInt.value\");\n            }\n\n            let foundItem = foundListDef.result!.TryGetItemWithValue(\n              intVal.value,\n              InkListItem.Null\n            );\n            if (foundItem.exists) {\n              generatedListValue = new ListValue(\n                foundItem.result!,\n                intVal.value\n              );\n            }\n          } else {\n            throw new StoryException(\n              \"Failed to find LIST called \" + listNameVal.value\n            );\n          }\n\n          if (generatedListValue == null) generatedListValue = new ListValue();\n\n          this.state.PushEvaluationStack(generatedListValue);\n          break;\n\n        case ControlCommand.CommandType.ListRange:\n          let max = asOrNull(this.state.PopEvaluationStack(), Value);\n          let min = asOrNull(this.state.PopEvaluationStack(), Value);\n\n          // var targetList = state.PopEvaluationStack () as ListValue;\n          let targetList = asOrNull(this.state.PopEvaluationStack(), ListValue);\n\n          if (targetList === null || min === null || max === null)\n            throw new StoryException(\n              \"Expected list, minimum and maximum for LIST_RANGE\"\n            );\n\n          if (targetList.value === null) {\n            return throwNullException(\"targetList.value\");\n          }\n          let result = targetList.value.ListWithSubRange(\n            min.valueObject,\n            max.valueObject\n          );\n\n          this.state.PushEvaluationStack(new ListValue(result));\n          break;\n\n        case ControlCommand.CommandType.ListRandom: {\n          let listVal = this.state.PopEvaluationStack() as ListValue;\n          if (listVal === null)\n            throw new StoryException(\"Expected list for LIST_RANDOM\");\n\n          let list = listVal.value;\n\n          let newList: InkList | null = null;\n\n          if (list === null) {\n            throw throwNullException(\"list\");\n          }\n          if (list.Count == 0) {\n            newList = new InkList();\n          } else {\n            // Generate a random index for the element to take\n            let resultSeed = this.state.storySeed + this.state.previousRandom;\n            let random = new PRNG(resultSeed);\n\n            let nextRandom = random.next();\n            let listItemIndex = nextRandom % list.Count;\n\n            // This bit is a little different from the original\n            // C# code, since iterators do not work in the same way.\n            // First, we iterate listItemIndex - 1 times, calling next().\n            // The listItemIndex-th time is made outside of the loop,\n            // in order to retrieve the value.\n            let listEnumerator = list.entries();\n            for (let i = 0; i <= listItemIndex - 1; i++) {\n              listEnumerator.next();\n            }\n            let value = listEnumerator.next().value;\n            let randomItem: KeyValuePair<InkListItem, number> = {\n              Key: InkListItem.fromSerializedKey(value[0]),\n              Value: value[1],\n            };\n\n            // Origin list is simply the origin of the one element\n            if (randomItem.Key.originName === null) {\n              return throwNullException(\"randomItem.Key.originName\");\n            }\n            newList = new InkList(randomItem.Key.originName, this);\n            newList.Add(randomItem.Key, randomItem.Value);\n\n            this.state.previousRandom = nextRandom;\n          }\n\n          this.state.PushEvaluationStack(new ListValue(newList));\n          break;\n        }\n\n        default:\n          this.Error(\"unhandled ControlCommand: \" + evalCommand);\n          break;\n      }\n\n      return true;\n    }\n\n    // Variable assignment\n    else if (contentObj instanceof VariableAssignment) {\n      let varAss = contentObj;\n      let assignedVal = this.state.PopEvaluationStack();\n\n      this.state.variablesState.Assign(varAss, assignedVal);\n\n      return true;\n    }\n\n    // Variable reference\n    else if (contentObj instanceof VariableReference) {\n      let varRef = contentObj;\n      let foundValue = null;\n\n      // Explicit read count value\n      if (varRef.pathForCount != null) {\n        let container = varRef.containerForCount;\n        let count = this.state.VisitCountForContainer(container);\n        foundValue = new IntValue(count);\n      }\n\n      // Normal variable reference\n      else {\n        foundValue = this.state.variablesState.GetVariableWithName(varRef.name);\n\n        if (foundValue == null) {\n          this.Warning(\n            \"Variable not found: '\" +\n              varRef.name +\n              \"'. Using default value of 0 (false). This can happen with temporary variables if the declaration hasn't yet been hit. Globals are always given a default value on load if a value doesn't exist in the save state.\"\n          );\n          foundValue = new IntValue(0);\n        }\n      }\n\n      this.state.PushEvaluationStack(foundValue);\n\n      return true;\n    }\n\n    // Native function call\n    else if (contentObj instanceof NativeFunctionCall) {\n      let func = contentObj;\n      let funcParams = this.state.PopEvaluationStack(func.numberOfParameters);\n      let result = func.Call(funcParams);\n      this.state.PushEvaluationStack(result);\n      return true;\n    }\n\n    // No control content, must be ordinary content\n    return false;\n  }\n\n  public ChoosePathString(\n    path: string,\n    resetCallstack = true,\n    args: any[] = []\n  ) {\n    this.IfAsyncWeCant(\"call ChoosePathString right now\");\n    if (this.onChoosePathString !== null) this.onChoosePathString(path, args);\n\n    if (resetCallstack) {\n      this.ResetCallstack();\n    } else {\n      if (this.state.callStack.currentElement.type == PushPopType.Function) {\n        let funcDetail = \"\";\n        let container =\n          this.state.callStack.currentElement.currentPointer.container;\n        if (container != null) {\n          funcDetail = \"(\" + container.path.toString() + \") \";\n        }\n        throw new Error(\n          \"Story was running a function \" +\n            funcDetail +\n            \"when you called ChoosePathString(\" +\n            path +\n            \") - this is almost certainly not not what you want! Full stack trace: \\n\" +\n            this.state.callStack.callStackTrace\n        );\n      }\n    }\n\n    this.state.PassArgumentsToEvaluationStack(args);\n    this.ChoosePath(new Path(path));\n  }\n\n  public IfAsyncWeCant(activityStr: string) {\n    if (this._asyncContinueActive)\n      throw new Error(\n        \"Can't \" +\n          activityStr +\n          \". Story is in the middle of a ContinueAsync(). Make more ContinueAsync() calls or a single Continue() call beforehand.\"\n      );\n  }\n\n  public ChoosePath(p: Path, incrementingTurnIndex: boolean = true) {\n    this.state.SetChosenPath(p, incrementingTurnIndex);\n\n    // Take a note of newly visited containers for read counts etc\n    this.VisitChangedContainersDueToDivert();\n  }\n\n  public ChooseChoiceIndex(choiceIdx: number) {\n    choiceIdx = choiceIdx;\n    let choices = this.currentChoices;\n    this.Assert(\n      choiceIdx >= 0 && choiceIdx < choices.length,\n      \"choice out of range\"\n    );\n\n    let choiceToChoose = choices[choiceIdx];\n    if (this.onMakeChoice !== null) this.onMakeChoice(choiceToChoose);\n\n    if (choiceToChoose.threadAtGeneration === null) {\n      return throwNullException(\"choiceToChoose.threadAtGeneration\");\n    }\n    if (choiceToChoose.targetPath === null) {\n      return throwNullException(\"choiceToChoose.targetPath\");\n    }\n\n    this.state.callStack.currentThread = choiceToChoose.threadAtGeneration;\n\n    this.ChoosePath(choiceToChoose.targetPath);\n  }\n\n  public HasFunction(functionName: string) {\n    try {\n      return this.KnotContainerWithName(functionName) != null;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  public EvaluateFunction(\n    functionName: string,\n    args: any[] = [],\n    returnTextOutput: boolean = false\n  ): Story.EvaluateFunctionTextOutput | any {\n    // EvaluateFunction behaves slightly differently than the C# version.\n    // In C#, you can pass a (second) parameter `out textOutput` to get the\n    // text outputted by the function. This is not possible in js. Instead,\n    // we maintain the regular signature (functionName, args), plus an\n    // optional third parameter returnTextOutput. If set to true, we will\n    // return both the textOutput and the returned value, as an object.\n\n    if (this.onEvaluateFunction !== null)\n      this.onEvaluateFunction(functionName, args);\n\n    this.IfAsyncWeCant(\"evaluate a function\");\n\n    if (functionName == null) {\n      throw new Error(\"Function is null\");\n    } else if (functionName == \"\" || functionName.trim() == \"\") {\n      throw new Error(\"Function is empty or white space.\");\n    }\n\n    let funcContainer = this.KnotContainerWithName(functionName);\n    if (funcContainer == null) {\n      throw new Error(\"Function doesn't exist: '\" + functionName + \"'\");\n    }\n\n    let outputStreamBefore: InkObject[] = [];\n    outputStreamBefore.push(...this.state.outputStream);\n    this._state.ResetOutput();\n\n    this.state.StartFunctionEvaluationFromGame(funcContainer, args);\n\n    // Evaluate the function, and collect the string output\n    let stringOutput = new StringBuilder();\n    while (this.canContinue) {\n      stringOutput.Append(this.Continue());\n    }\n    let textOutput = stringOutput.toString();\n\n    this._state.ResetOutput(outputStreamBefore);\n\n    let result = this.state.CompleteFunctionEvaluationFromGame();\n    if (this.onCompleteEvaluateFunction != null)\n      this.onCompleteEvaluateFunction(functionName, args, textOutput, result);\n\n    return returnTextOutput ? { returned: result, output: textOutput } : result;\n  }\n\n  public EvaluateExpression(exprContainer: Container) {\n    let startCallStackHeight = this.state.callStack.elements.length;\n\n    this.state.callStack.Push(PushPopType.Tunnel);\n\n    this._temporaryEvaluationContainer = exprContainer;\n\n    this.state.GoToStart();\n\n    let evalStackHeight = this.state.evaluationStack.length;\n\n    this.Continue();\n\n    this._temporaryEvaluationContainer = null;\n\n    // Should have fallen off the end of the Container, which should\n    // have auto-popped, but just in case we didn't for some reason,\n    // manually pop to restore the state (including currentPath).\n    if (this.state.callStack.elements.length > startCallStackHeight) {\n      this.state.PopCallStack();\n    }\n\n    let endStackHeight = this.state.evaluationStack.length;\n    if (endStackHeight > evalStackHeight) {\n      return this.state.PopEvaluationStack();\n    } else {\n      return null;\n    }\n  }\n\n  public allowExternalFunctionFallbacks: boolean = false;\n\n  public CallExternalFunction(\n    funcName: string | null,\n    numberOfArguments: number\n  ) {\n    if (funcName === null) {\n      return throwNullException(\"funcName\");\n    }\n    let funcDef = this._externals.get(funcName);\n    let fallbackFunctionContainer = null;\n\n    let foundExternal = typeof funcDef !== \"undefined\";\n\n    if (\n      foundExternal &&\n      !funcDef!.lookAheadSafe &&\n      this._stateSnapshotAtLastNewline !== null\n    ) {\n      this._sawLookaheadUnsafeFunctionAfterNewline = true;\n      return;\n    }\n\n    if (!foundExternal) {\n      if (this.allowExternalFunctionFallbacks) {\n        fallbackFunctionContainer = this.KnotContainerWithName(funcName);\n        this.Assert(\n          fallbackFunctionContainer !== null,\n          \"Trying to call EXTERNAL function '\" +\n            funcName +\n            \"' which has not been bound, and fallback ink function could not be found.\"\n        );\n\n        // Divert direct into fallback function and we're done\n        this.state.callStack.Push(\n          PushPopType.Function,\n          undefined,\n          this.state.outputStream.length\n        );\n        this.state.divertedPointer = Pointer.StartOf(fallbackFunctionContainer);\n        return;\n      } else {\n        this.Assert(\n          false,\n          \"Trying to call EXTERNAL function '\" +\n            funcName +\n            \"' which has not been bound (and ink fallbacks disabled).\"\n        );\n      }\n    }\n\n    // Pop arguments\n    let args: any[] = [];\n    for (let i = 0; i < numberOfArguments; ++i) {\n      // var poppedObj = state.PopEvaluationStack () as Value;\n      let poppedObj = asOrThrows(this.state.PopEvaluationStack(), Value);\n      let valueObj = poppedObj.valueObject;\n      args.push(valueObj);\n    }\n\n    // Reverse arguments from the order they were popped,\n    // so they're the right way round again.\n    args.reverse();\n\n    // Run the function!\n    let funcResult = funcDef!.function(args);\n\n    // Convert return value (if any) to the a type that the ink engine can use\n    let returnObj = null;\n    if (funcResult != null) {\n      returnObj = Value.Create(funcResult);\n      this.Assert(\n        returnObj !== null,\n        \"Could not create ink value from returned object of type \" +\n          typeof funcResult\n      );\n    } else {\n      returnObj = new Void();\n    }\n\n    this.state.PushEvaluationStack(returnObj);\n  }\n\n  public BindExternalFunctionGeneral(\n    funcName: string,\n    func: Story.ExternalFunction,\n    lookaheadSafe: boolean = true\n  ) {\n    this.IfAsyncWeCant(\"bind an external function\");\n    this.Assert(\n      !this._externals.has(funcName),\n      \"Function '\" + funcName + \"' has already been bound.\"\n    );\n    this._externals.set(funcName, {\n      function: func,\n      lookAheadSafe: lookaheadSafe,\n    });\n  }\n\n  public TryCoerce(value: any) {\n    // We're skipping type coercition in this implementation. First of, js\n    // is loosely typed, so it's not that important. Secondly, there is no\n    // clean way (AFAIK) for the user to describe what type of parameters\n    // they expect.\n    return value;\n  }\n\n  public BindExternalFunction(\n    funcName: string,\n    func: Story.ExternalFunction,\n    lookaheadSafe: boolean = false\n  ) {\n    this.Assert(func != null, \"Can't bind a null function\");\n\n    this.BindExternalFunctionGeneral(\n      funcName,\n      (args: any) => {\n        this.Assert(\n          args.length >= func.length,\n          \"External function expected \" + func.length + \" arguments\"\n        );\n\n        let coercedArgs = [];\n        for (let i = 0, l = args.length; i < l; i++) {\n          coercedArgs[i] = this.TryCoerce(args[i]);\n        }\n        return func.apply(null, coercedArgs);\n      },\n      lookaheadSafe\n    );\n  }\n\n  public UnbindExternalFunction(funcName: string) {\n    this.IfAsyncWeCant(\"unbind an external a function\");\n    this.Assert(\n      this._externals.has(funcName),\n      \"Function '\" + funcName + \"' has not been bound.\"\n    );\n    this._externals.delete(funcName);\n  }\n\n  public ValidateExternalBindings(): void;\n  public ValidateExternalBindings(\n    c: Container | null,\n    missingExternals: Set<string>\n  ): void;\n  public ValidateExternalBindings(\n    o: InkObject | null,\n    missingExternals: Set<string>\n  ): void;\n  public ValidateExternalBindings() {\n    let c: Container | null = null;\n    let o: InkObject | null = null;\n    let missingExternals: Set<string> = arguments[1] || new Set();\n\n    if (arguments[0] instanceof Container) {\n      c = arguments[0];\n    }\n\n    if (arguments[0] instanceof InkObject) {\n      o = arguments[0];\n    }\n\n    if (c === null && o === null) {\n      this.ValidateExternalBindings(\n        this._mainContentContainer,\n        missingExternals\n      );\n      this._hasValidatedExternals = true;\n\n      // No problem! Validation complete\n      if (missingExternals.size == 0) {\n        this._hasValidatedExternals = true;\n      } else {\n        let message = \"Error: Missing function binding for external\";\n        message += missingExternals.size > 1 ? \"s\" : \"\";\n        message += \": '\";\n        message += Array.from(missingExternals).join(\"', '\");\n        message += \"' \";\n        message += this.allowExternalFunctionFallbacks\n          ? \", and no fallback ink function found.\"\n          : \" (ink fallbacks disabled)\";\n\n        this.Error(message);\n      }\n    } else if (c != null) {\n      for (let innerContent of c.content) {\n        let container = innerContent as Container;\n        if (container == null || !container.hasValidName)\n          this.ValidateExternalBindings(innerContent, missingExternals);\n      }\n      for (let [, value] of c.namedContent) {\n        this.ValidateExternalBindings(\n          asOrNull(value, InkObject),\n          missingExternals\n        );\n      }\n    } else if (o != null) {\n      let divert = asOrNull(o, Divert);\n      if (divert && divert.isExternal) {\n        let name = divert.targetPathString;\n        if (name === null) {\n          return throwNullException(\"name\");\n        }\n        if (!this._externals.has(name)) {\n          if (this.allowExternalFunctionFallbacks) {\n            let fallbackFound =\n              this.mainContentContainer.namedContent.has(name);\n            if (!fallbackFound) {\n              missingExternals.add(name);\n            }\n          } else {\n            missingExternals.add(name);\n          }\n        }\n      }\n    }\n  }\n\n  public ObserveVariable(\n    variableName: string,\n    observer: Story.VariableObserver\n  ) {\n    this.IfAsyncWeCant(\"observe a new variable\");\n\n    if (this._variableObservers === null) this._variableObservers = new Map();\n\n    if (!this.state.variablesState.GlobalVariableExistsWithName(variableName))\n      throw new Error(\n        \"Cannot observe variable '\" +\n          variableName +\n          \"' because it wasn't declared in the ink story.\"\n      );\n\n    if (this._variableObservers.has(variableName)) {\n      this._variableObservers.get(variableName)!.push(observer);\n    } else {\n      this._variableObservers.set(variableName, [observer]);\n    }\n  }\n\n  public ObserveVariables(\n    variableNames: string[],\n    observers: Story.VariableObserver[]\n  ) {\n    for (let i = 0, l = variableNames.length; i < l; i++) {\n      this.ObserveVariable(variableNames[i], observers[i]);\n    }\n  }\n\n  public RemoveVariableObserver(\n    observer?: Story.VariableObserver,\n    specificVariableName?: string\n  ) {\n    // A couple of things to know about this method:\n    //\n    // 1. Since `RemoveVariableObserver` is exposed to the JavaScript world,\n    //    optionality is marked as `undefined` rather than `null`.\n    //    To keep things simple, null-checks are performed using regular\n    //    equality operators, where undefined == null.\n    //\n    // 2. Since C# delegates are translated to arrays of functions,\n    //    -= becomes a call to splice and null-checks are replaced by\n    //    emptiness-checks.\n    //\n    this.IfAsyncWeCant(\"remove a variable observer\");\n\n    if (this._variableObservers === null) return;\n\n    if (specificVariableName != null) {\n      if (this._variableObservers.has(specificVariableName)) {\n        if (observer != null) {\n          let variableObservers =\n            this._variableObservers.get(specificVariableName);\n          if (variableObservers != null) {\n            variableObservers.splice(variableObservers.indexOf(observer), 1);\n            if (variableObservers.length === 0) {\n              this._variableObservers.delete(specificVariableName);\n            }\n          }\n        } else {\n          this._variableObservers.delete(specificVariableName);\n        }\n      }\n    } else if (observer != null) {\n      let keys = this._variableObservers.keys();\n      for (let varName of keys) {\n        let variableObservers = this._variableObservers.get(varName);\n        if (variableObservers != null) {\n          variableObservers.splice(variableObservers.indexOf(observer), 1);\n          if (variableObservers.length === 0) {\n            this._variableObservers.delete(varName);\n          }\n        }\n      }\n    }\n  }\n\n  public VariableStateDidChangeEvent(\n    variableName: string,\n    newValueObj: InkObject\n  ) {\n    if (this._variableObservers === null) return;\n\n    let observers = this._variableObservers.get(variableName);\n    if (typeof observers !== \"undefined\") {\n      if (!(newValueObj instanceof Value)) {\n        throw new Error(\n          \"Tried to get the value of a variable that isn't a standard type\"\n        );\n      }\n      // var val = newValueObj as Value;\n      let val = asOrThrows(newValueObj, Value);\n\n      for (let observer of observers) {\n        observer(variableName, val.valueObject);\n      }\n    }\n  }\n\n  get globalTags() {\n    return this.TagsAtStartOfFlowContainerWithPathString(\"\");\n  }\n\n  public TagsForContentAtPath(path: string) {\n    return this.TagsAtStartOfFlowContainerWithPathString(path);\n  }\n\n  public TagsAtStartOfFlowContainerWithPathString(pathString: string) {\n    let path = new Path(pathString);\n\n    let flowContainer = this.ContentAtPath(path).container;\n    if (flowContainer === null) {\n      return throwNullException(\"flowContainer\");\n    }\n    while (true) {\n      let firstContent: InkObject = flowContainer.content[0];\n      if (firstContent instanceof Container) flowContainer = firstContent;\n      else break;\n    }\n\n    let inTag = false;\n    let tags: string[] | null = null;\n\n    for (let c of flowContainer.content) {\n      // var tag = c as Runtime.Tag;\n      let command = asOrNull(c, ControlCommand);\n\n      if (command != null) {\n        if (command.commandType == ControlCommand.CommandType.BeginTag) {\n          inTag = true;\n        } else if (command.commandType == ControlCommand.CommandType.EndTag) {\n          inTag = false;\n        }\n      } else if (inTag) {\n        let str = asOrNull(c, StringValue);\n        if (str !== null) {\n          if (tags === null) tags = [];\n          if (str.value !== null) tags.push(str.value);\n        } else {\n          this.Error(\n            \"Tag contained non-text content. Only plain text is allowed when using globalTags or TagsAtContentPath. If you want to evaluate dynamic content, you need to use story.Continue().\"\n          );\n        }\n      } else {\n        break;\n      }\n    }\n\n    return tags;\n  }\n\n  public BuildStringOfHierarchy() {\n    let sb = new StringBuilder();\n\n    this.mainContentContainer.BuildStringOfHierarchy(\n      sb,\n      0,\n      this.state.currentPointer.Resolve()\n    );\n\n    return sb.toString();\n  }\n\n  public BuildStringOfContainer(container: Container) {\n    let sb = new StringBuilder();\n    container.BuildStringOfHierarchy(\n      sb,\n      0,\n      this.state.currentPointer.Resolve()\n    );\n    return sb.toString();\n  }\n\n  public NextContent() {\n    this.state.previousPointer = this.state.currentPointer.copy();\n\n    if (!this.state.divertedPointer.isNull) {\n      this.state.currentPointer = this.state.divertedPointer.copy();\n      this.state.divertedPointer = Pointer.Null;\n\n      this.VisitChangedContainersDueToDivert();\n\n      if (!this.state.currentPointer.isNull) {\n        return;\n      }\n    }\n\n    let successfulPointerIncrement = this.IncrementContentPointer();\n\n    if (!successfulPointerIncrement) {\n      let didPop = false;\n\n      if (this.state.callStack.CanPop(PushPopType.Function)) {\n        this.state.PopCallStack(PushPopType.Function);\n\n        if (this.state.inExpressionEvaluation) {\n          this.state.PushEvaluationStack(new Void());\n        }\n\n        didPop = true;\n      } else if (this.state.callStack.canPopThread) {\n        this.state.callStack.PopThread();\n\n        didPop = true;\n      } else {\n        this.state.TryExitFunctionEvaluationFromGame();\n      }\n\n      if (didPop && !this.state.currentPointer.isNull) {\n        this.NextContent();\n      }\n    }\n  }\n\n  public IncrementContentPointer() {\n    let successfulIncrement = true;\n\n    let pointer = this.state.callStack.currentElement.currentPointer.copy();\n    pointer.index++;\n\n    if (pointer.container === null) {\n      return throwNullException(\"pointer.container\");\n    }\n    while (pointer.index >= pointer.container.content.length) {\n      successfulIncrement = false;\n\n      // Container nextAncestor = pointer.container.parent as Container;\n      let nextAncestor = asOrNull(pointer.container.parent, Container);\n      if (nextAncestor instanceof Container === false) {\n        break;\n      }\n\n      let indexInAncestor = nextAncestor!.content.indexOf(pointer.container);\n      if (indexInAncestor == -1) {\n        break;\n      }\n\n      pointer = new Pointer(nextAncestor, indexInAncestor);\n\n      pointer.index++;\n\n      successfulIncrement = true;\n      if (pointer.container === null) {\n        return throwNullException(\"pointer.container\");\n      }\n    }\n\n    if (!successfulIncrement) pointer = Pointer.Null;\n\n    this.state.callStack.currentElement.currentPointer = pointer.copy();\n\n    return successfulIncrement;\n  }\n\n  public TryFollowDefaultInvisibleChoice() {\n    let allChoices = this._state.currentChoices;\n\n    let invisibleChoices = allChoices.filter((c) => c.isInvisibleDefault);\n\n    if (\n      invisibleChoices.length == 0 ||\n      allChoices.length > invisibleChoices.length\n    )\n      return false;\n\n    let choice = invisibleChoices[0];\n\n    if (choice.targetPath === null) {\n      return throwNullException(\"choice.targetPath\");\n    }\n\n    if (choice.threadAtGeneration === null) {\n      return throwNullException(\"choice.threadAtGeneration\");\n    }\n\n    this.state.callStack.currentThread = choice.threadAtGeneration;\n\n    if (this._stateSnapshotAtLastNewline !== null) {\n      this.state.callStack.currentThread = this.state.callStack.ForkThread();\n    }\n\n    this.ChoosePath(choice.targetPath, false);\n\n    return true;\n  }\n\n  public NextSequenceShuffleIndex() {\n    // var numElementsIntVal = state.PopEvaluationStack () as IntValue;\n    let numElementsIntVal = asOrNull(this.state.PopEvaluationStack(), IntValue);\n    if (!(numElementsIntVal instanceof IntValue)) {\n      this.Error(\"expected number of elements in sequence for shuffle index\");\n      return 0;\n    }\n\n    let seqContainer = this.state.currentPointer.container;\n    if (seqContainer === null) {\n      return throwNullException(\"seqContainer\");\n    }\n\n    // Originally a primitive type, but here, can be null.\n    // TODO: Replace by default value?\n    if (numElementsIntVal.value === null) {\n      return throwNullException(\"numElementsIntVal.value\");\n    }\n    let numElements = numElementsIntVal.value;\n\n    // var seqCountVal = state.PopEvaluationStack () as IntValue;\n    let seqCountVal = asOrThrows(this.state.PopEvaluationStack(), IntValue);\n    let seqCount = seqCountVal.value;\n\n    // Originally a primitive type, but here, can be null.\n    // TODO: Replace by default value?\n    if (seqCount === null) {\n      return throwNullException(\"seqCount\");\n    }\n\n    let loopIndex = seqCount / numElements;\n    let iterationIndex = seqCount % numElements;\n\n    let seqPathStr = seqContainer.path.toString();\n    let sequenceHash = 0;\n    for (let i = 0, l = seqPathStr.length; i < l; i++) {\n      sequenceHash += seqPathStr.charCodeAt(i) || 0;\n    }\n    let randomSeed = sequenceHash + loopIndex + this.state.storySeed;\n    let random = new PRNG(Math.floor(randomSeed));\n\n    let unpickedIndices = [];\n    for (let i = 0; i < numElements; ++i) {\n      unpickedIndices.push(i);\n    }\n\n    for (let i = 0; i <= iterationIndex; ++i) {\n      let chosen = random.next() % unpickedIndices.length;\n      let chosenIndex = unpickedIndices[chosen];\n      unpickedIndices.splice(chosen, 1);\n\n      if (i == iterationIndex) {\n        return chosenIndex;\n      }\n    }\n\n    throw new Error(\"Should never reach here\");\n  }\n\n  public Error(message: string, useEndLineNumber = false): never {\n    let e = new StoryException(message);\n    e.useEndLineNumber = useEndLineNumber;\n    throw e;\n  }\n\n  public Warning(message: string) {\n    this.AddError(message, true);\n  }\n\n  public AddError(\n    message: string,\n    isWarning = false,\n    useEndLineNumber = false\n  ) {\n    let dm = this.currentDebugMetadata;\n\n    let errorTypeStr = isWarning ? \"WARNING\" : \"ERROR\";\n\n    if (dm != null) {\n      let lineNum = useEndLineNumber ? dm.endLineNumber : dm.startLineNumber;\n      message =\n        \"RUNTIME \" +\n        errorTypeStr +\n        \": '\" +\n        dm.fileName +\n        \"' line \" +\n        lineNum +\n        \": \" +\n        message;\n    } else if (!this.state.currentPointer.isNull) {\n      message =\n        \"RUNTIME \" +\n        errorTypeStr +\n        \": (\" +\n        this.state.currentPointer +\n        \"): \" +\n        message;\n    } else {\n      message = \"RUNTIME \" + errorTypeStr + \": \" + message;\n    }\n\n    this.state.AddError(message, isWarning);\n\n    // In a broken state don't need to know about any other errors.\n    if (!isWarning) this.state.ForceEnd();\n  }\n\n  public Assert(condition: boolean, message: string | null = null) {\n    if (condition == false) {\n      if (message == null) {\n        message = \"Story assert\";\n      }\n\n      throw new Error(message + \" \" + this.currentDebugMetadata);\n    }\n  }\n\n  get currentDebugMetadata(): DebugMetadata | null {\n    let dm: DebugMetadata | null;\n\n    let pointer = this.state.currentPointer;\n    if (!pointer.isNull && pointer.Resolve() !== null) {\n      dm = pointer.Resolve()!.debugMetadata;\n      if (dm !== null) {\n        return dm;\n      }\n    }\n\n    for (let i = this.state.callStack.elements.length - 1; i >= 0; --i) {\n      pointer = this.state.callStack.elements[i].currentPointer;\n      if (!pointer.isNull && pointer.Resolve() !== null) {\n        dm = pointer.Resolve()!.debugMetadata;\n        if (dm !== null) {\n          return dm;\n        }\n      }\n    }\n\n    for (let i = this.state.outputStream.length - 1; i >= 0; --i) {\n      let outputObj = this.state.outputStream[i];\n      dm = outputObj.debugMetadata;\n      if (dm !== null) {\n        return dm;\n      }\n    }\n\n    return null;\n  }\n\n  get mainContentContainer() {\n    if (this._temporaryEvaluationContainer) {\n      return this._temporaryEvaluationContainer;\n    } else {\n      return this._mainContentContainer;\n    }\n  }\n\n  /**\n   * `_mainContentContainer` is almost guaranteed to be set in the\n   * constructor, unless the json is malformed.\n   */\n  private _mainContentContainer!: Container;\n  private _listDefinitions: ListDefinitionsOrigin | null = null;\n\n  private _externals: Map<string, Story.ExternalFunctionDef>;\n  private _variableObservers: Map<string, Story.VariableObserver[]> | null =\n    null;\n  private _hasValidatedExternals: boolean = false;\n\n  private _temporaryEvaluationContainer: Container | null = null;\n\n  /**\n   * `state` is almost guaranteed to be set in the constructor, unless\n   * using the compiler-specific constructor which will likely not be used in\n   * the real world.\n   */\n  private _state!: StoryState;\n\n  private _asyncContinueActive: boolean = false;\n  private _stateSnapshotAtLastNewline: StoryState | null = null;\n  private _sawLookaheadUnsafeFunctionAfterNewline: boolean = false;\n\n  private _recursiveContinueCount: number = 0;\n\n  private _asyncSaving: boolean = false;\n\n  private _profiler: any | null = null; // TODO: Profiler\n}\n\nexport namespace Story {\n  export enum OutputStateChange {\n    NoChange = 0,\n    ExtendedBeyondNewline = 1,\n    NewlineRemoved = 2,\n  }\n\n  export interface EvaluateFunctionTextOutput {\n    returned: any;\n    output: string;\n  }\n\n  export interface ExternalFunctionDef {\n    function: ExternalFunction;\n    lookAheadSafe: boolean;\n  }\n\n  export type VariableObserver = (variableName: string, newValue: any) => void;\n  export type ExternalFunction = (...args: any) => any;\n}\n","import { CallStack } from \"./CallStack\";\nimport { VariablesState } from \"./VariablesState\";\nimport { ValueType, Value, StringValue, ListValue } from \"./Value\";\nimport { PushPopType } from \"./PushPop\";\nimport { Tag } from \"./Tag\";\nimport { Glue } from \"./Glue\";\nimport { Path } from \"./Path\";\nimport { ControlCommand } from \"./ControlCommand\";\nimport { StringBuilder } from \"./StringBuilder\";\nimport { JsonSerialisation } from \"./JsonSerialisation\";\nimport { PRNG } from \"./PRNG\";\nimport { Void } from \"./Void\";\nimport { Pointer } from \"./Pointer\";\nimport { tryGetValueFromMap } from \"./TryGetResult\";\nimport { Choice } from \"./Choice\";\nimport { asOrNull, asOrThrows, nullIfUndefined } from \"./TypeAssertion\";\nimport { Debug } from \"./Debug\";\nimport { Container } from \"./Container\";\nimport { InkObject } from \"./Object\";\nimport { throwNullException } from \"./NullException\";\nimport { Story } from \"./Story\";\nimport { StatePatch } from \"./StatePatch\";\nimport { SimpleJson } from \"./SimpleJson\";\nimport { Flow } from \"./Flow\";\nimport { InkList } from \"./InkList\";\n\nexport class StoryState {\n  // Backward compatible changes since v8:\n  // v10: dynamic tags\n  // v9:  multi-flows\n  public readonly kInkSaveStateVersion = 10;\n  public readonly kMinCompatibleLoadVersion = 8;\n\n  public onDidLoadState: (() => void) | null = null;\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  public ToJson(indented: boolean = false) {\n    let writer = new SimpleJson.Writer();\n    this.WriteJson(writer);\n    return writer.toString();\n  }\n  public toJson(indented: boolean = false) {\n    return this.ToJson(indented);\n  }\n\n  public LoadJson(json: string) {\n    let jObject = SimpleJson.TextToDictionary(json);\n    this.LoadJsonObj(jObject);\n    if (this.onDidLoadState !== null) this.onDidLoadState();\n  }\n\n  public VisitCountAtPathString(pathString: string) {\n    let visitCountOut;\n\n    if (this._patch !== null) {\n      let container = this.story.ContentAtPath(new Path(pathString)).container;\n      if (container === null)\n        throw new Error(\"Content at path not found: \" + pathString);\n\n      visitCountOut = this._patch.TryGetVisitCount(container, 0);\n      if (visitCountOut.exists) return visitCountOut.result;\n    }\n\n    visitCountOut = tryGetValueFromMap(this._visitCounts, pathString, null);\n    if (visitCountOut.exists) return visitCountOut.result;\n\n    return 0;\n  }\n\n  public VisitCountForContainer(container: Container | null): number {\n    if (container === null) {\n      return throwNullException(\"container\");\n    }\n    if (!container.visitsShouldBeCounted) {\n      this.story.Error(\n        \"Read count for target (\" +\n          container.name +\n          \" - on \" +\n          container.debugMetadata +\n          \") unknown. The story may need to be compiled with countAllVisits flag (-c).\"\n      );\n      return 0;\n    }\n\n    if (this._patch !== null) {\n      let count = this._patch.TryGetVisitCount(container, 0);\n      if (count.exists) {\n        return count.result!;\n      }\n    }\n\n    let containerPathStr = container.path.toString();\n    let count2 = tryGetValueFromMap(this._visitCounts, containerPathStr, null);\n    if (count2.exists) {\n      return count2.result!;\n    }\n\n    return 0;\n  }\n\n  public IncrementVisitCountForContainer(container: Container) {\n    if (this._patch !== null) {\n      let currCount = this.VisitCountForContainer(container);\n      currCount++;\n      this._patch.SetVisitCount(container, currCount);\n      return;\n    }\n\n    let containerPathStr = container.path.toString();\n    let count = tryGetValueFromMap(this._visitCounts, containerPathStr, null);\n    if (count.exists) {\n      this._visitCounts.set(containerPathStr, count.result! + 1);\n    } else {\n      this._visitCounts.set(containerPathStr, 1);\n    }\n  }\n\n  public RecordTurnIndexVisitToContainer(container: Container) {\n    if (this._patch !== null) {\n      this._patch.SetTurnIndex(container, this.currentTurnIndex);\n      return;\n    }\n\n    let containerPathStr = container.path.toString();\n    this._turnIndices.set(containerPathStr, this.currentTurnIndex);\n  }\n\n  public TurnsSinceForContainer(container: Container) {\n    if (!container.turnIndexShouldBeCounted) {\n      this.story.Error(\n        \"TURNS_SINCE() for target (\" +\n          container.name +\n          \" - on \" +\n          container.debugMetadata +\n          \") unknown. The story may need to be compiled with countAllVisits flag (-c).\"\n      );\n    }\n\n    if (this._patch !== null) {\n      let index = this._patch.TryGetTurnIndex(container, 0);\n      if (index.exists) {\n        return this.currentTurnIndex - index.result!;\n      }\n    }\n\n    let containerPathStr = container.path.toString();\n    let index2 = tryGetValueFromMap(this._turnIndices, containerPathStr, 0);\n    if (index2.exists) {\n      return this.currentTurnIndex - index2.result!;\n    } else {\n      return -1;\n    }\n  }\n\n  get callstackDepth() {\n    return this.callStack.depth;\n  }\n\n  get outputStream() {\n    return this._currentFlow.outputStream;\n  }\n\n  get currentChoices() {\n    // If we can continue generating text content rather than choices,\n    // then we reflect the choice list as being empty, since choices\n    // should always come at the end.\n    if (this.canContinue) return [];\n    return this._currentFlow.currentChoices;\n  }\n\n  get generatedChoices() {\n    return this._currentFlow.currentChoices;\n  }\n\n  get currentErrors() {\n    return this._currentErrors;\n  }\n  private _currentErrors: string[] | null = null;\n\n  get currentWarnings() {\n    return this._currentWarnings;\n  }\n  private _currentWarnings: string[] | null = null;\n\n  get variablesState() {\n    return this._variablesState;\n  }\n  set variablesState(value) {\n    this._variablesState = value;\n  }\n  private _variablesState: VariablesState;\n\n  get callStack() {\n    return this._currentFlow.callStack;\n  }\n\n  get evaluationStack() {\n    return this._evaluationStack;\n  }\n  private _evaluationStack: InkObject[];\n\n  public divertedPointer: Pointer = Pointer.Null;\n\n  get currentTurnIndex() {\n    return this._currentTurnIndex;\n  }\n  set currentTurnIndex(value) {\n    this._currentTurnIndex = value;\n  }\n  private _currentTurnIndex: number = 0;\n\n  public storySeed: number = 0;\n  public previousRandom: number = 0;\n  public didSafeExit: boolean = false;\n\n  public story: Story;\n\n  get currentPathString() {\n    let pointer = this.currentPointer;\n    if (pointer.isNull) {\n      return null;\n    } else {\n      if (pointer.path === null) {\n        return throwNullException(\"pointer.path\");\n      }\n      return pointer.path.toString();\n    }\n  }\n\n  get currentPointer() {\n    return this.callStack.currentElement.currentPointer.copy();\n  }\n\n  set currentPointer(value) {\n    this.callStack.currentElement.currentPointer = value.copy();\n  }\n\n  get previousPointer() {\n    return this.callStack.currentThread.previousPointer.copy();\n  }\n\n  set previousPointer(value) {\n    this.callStack.currentThread.previousPointer = value.copy();\n  }\n\n  get canContinue() {\n    return !this.currentPointer.isNull && !this.hasError;\n  }\n\n  get hasError() {\n    return this.currentErrors != null && this.currentErrors.length > 0;\n  }\n\n  get hasWarning() {\n    return this.currentWarnings != null && this.currentWarnings.length > 0;\n  }\n\n  get currentText() {\n    if (this._outputStreamTextDirty) {\n      let sb = new StringBuilder();\n\n      let inTag: boolean = false;\n\n      for (let outputObj of this.outputStream) {\n        // var textContent = outputObj as StringValue;\n        let textContent = asOrNull(outputObj, StringValue);\n        if (!inTag && textContent !== null) {\n          sb.Append(textContent.value);\n        } else {\n          let controlCommand = asOrNull(outputObj, ControlCommand);\n          if (controlCommand !== null) {\n            if (\n              controlCommand.commandType == ControlCommand.CommandType.BeginTag\n            ) {\n              inTag = true;\n            } else if (\n              controlCommand.commandType == ControlCommand.CommandType.EndTag\n            ) {\n              inTag = false;\n            }\n          }\n        }\n      }\n\n      this._currentText = this.CleanOutputWhitespace(sb.toString());\n      this._outputStreamTextDirty = false;\n    }\n\n    return this._currentText;\n  }\n  private _currentText: string | null = null;\n\n  public CleanOutputWhitespace(str: string) {\n    let sb = new StringBuilder();\n\n    let currentWhitespaceStart = -1;\n    let startOfLine = 0;\n\n    for (let i = 0; i < str.length; i++) {\n      let c = str.charAt(i);\n\n      let isInlineWhitespace = c == \" \" || c == \"\\t\";\n\n      if (isInlineWhitespace && currentWhitespaceStart == -1)\n        currentWhitespaceStart = i;\n\n      if (!isInlineWhitespace) {\n        if (\n          c != \"\\n\" &&\n          currentWhitespaceStart > 0 &&\n          currentWhitespaceStart != startOfLine\n        ) {\n          sb.Append(\" \");\n        }\n        currentWhitespaceStart = -1;\n      }\n\n      if (c == \"\\n\") startOfLine = i + 1;\n\n      if (!isInlineWhitespace) sb.Append(c);\n    }\n\n    return sb.toString();\n  }\n\n  get currentTags() {\n    if (this._outputStreamTagsDirty) {\n      this._currentTags = [];\n      let inTag: boolean = false;\n      let sb = new StringBuilder();\n\n      for (let outputObj of this.outputStream) {\n        let controlCommand = asOrNull(outputObj, ControlCommand);\n        if (controlCommand != null) {\n          if (\n            controlCommand.commandType == ControlCommand.CommandType.BeginTag\n          ) {\n            if (inTag && sb.Length > 0) {\n              let txt = this.CleanOutputWhitespace(sb.toString());\n              this._currentTags.push(txt);\n              sb.Clear();\n            }\n            inTag = true;\n          } else if (\n            controlCommand.commandType == ControlCommand.CommandType.EndTag\n          ) {\n            if (sb.Length > 0) {\n              let txt = this.CleanOutputWhitespace(sb.toString());\n              this._currentTags.push(txt);\n              sb.Clear();\n            }\n            inTag = false;\n          }\n        } else if (inTag) {\n          let strVal = asOrNull(outputObj, StringValue);\n          if (strVal !== null) {\n            sb.Append(strVal.value);\n          }\n        } else {\n          let tag = asOrNull(outputObj, Tag);\n          if (tag != null && tag.text != null && tag.text.length > 0) {\n            this._currentTags.push(tag.text); // tag.text has whitespae already cleaned\n          }\n        }\n      }\n\n      if (sb.Length > 0) {\n        let txt = this.CleanOutputWhitespace(sb.toString());\n        this._currentTags.push(txt);\n        sb.Clear();\n      }\n\n      this._outputStreamTagsDirty = false;\n    }\n\n    return this._currentTags;\n  }\n  private _currentTags: string[] | null = null;\n\n  get currentFlowName() {\n    return this._currentFlow.name;\n  }\n\n  get currentFlowIsDefaultFlow() {\n    return this._currentFlow.name == this.kDefaultFlowName;\n  }\n\n  get aliveFlowNames() {\n    if (this._aliveFlowNamesDirty) {\n      this._aliveFlowNames = [];\n\n      if (this._namedFlows != null) {\n        for (let flowName of this._namedFlows.keys()) {\n          if (flowName != this.kDefaultFlowName) {\n            this._aliveFlowNames.push(flowName);\n          }\n        }\n      }\n\n      this._aliveFlowNamesDirty = false;\n    }\n\n    return this._aliveFlowNames;\n  }\n\n  get inExpressionEvaluation() {\n    return this.callStack.currentElement.inExpressionEvaluation;\n  }\n  set inExpressionEvaluation(value) {\n    this.callStack.currentElement.inExpressionEvaluation = value;\n  }\n\n  constructor(story: Story) {\n    this.story = story;\n\n    this._currentFlow = new Flow(this.kDefaultFlowName, story);\n    this.OutputStreamDirty();\n\n    this._aliveFlowNamesDirty = true;\n    this._evaluationStack = [];\n\n    this._variablesState = new VariablesState(\n      this.callStack,\n      story.listDefinitions\n    );\n\n    this._visitCounts = new Map();\n    this._turnIndices = new Map();\n    this.currentTurnIndex = -1;\n\n    let timeSeed = new Date().getTime();\n    this.storySeed = new PRNG(timeSeed).next() % 100;\n    this.previousRandom = 0;\n\n    this.GoToStart();\n  }\n\n  public GoToStart() {\n    this.callStack.currentElement.currentPointer = Pointer.StartOf(\n      this.story.mainContentContainer\n    );\n  }\n\n  public SwitchFlow_Internal(flowName: string | null) {\n    if (flowName === null)\n      throw new Error(\"Must pass a non-null string to Story.SwitchFlow\");\n\n    if (this._namedFlows === null) {\n      this._namedFlows = new Map();\n      this._namedFlows.set(this.kDefaultFlowName, this._currentFlow);\n    }\n\n    if (flowName === this._currentFlow.name) {\n      return;\n    }\n\n    let flow: Flow;\n    let content = tryGetValueFromMap(this._namedFlows, flowName, null);\n    if (content.exists) {\n      flow = content.result!;\n    } else {\n      flow = new Flow(flowName, this.story);\n      this._namedFlows.set(flowName, flow);\n      this._aliveFlowNamesDirty = true;\n    }\n\n    this._currentFlow = flow;\n    this.variablesState.callStack = this._currentFlow.callStack;\n\n    this.OutputStreamDirty();\n  }\n\n  public SwitchToDefaultFlow_Internal() {\n    if (this._namedFlows === null) return;\n    this.SwitchFlow_Internal(this.kDefaultFlowName);\n  }\n\n  public RemoveFlow_Internal(flowName: string | null) {\n    if (flowName === null)\n      throw new Error(\"Must pass a non-null string to Story.DestroyFlow\");\n    if (flowName === this.kDefaultFlowName)\n      throw new Error(\"Cannot destroy default flow\");\n\n    if (this._currentFlow.name === flowName) {\n      this.SwitchToDefaultFlow_Internal();\n    }\n\n    if (this._namedFlows === null)\n      return throwNullException(\"this._namedFlows\");\n    this._namedFlows.delete(flowName);\n    this._aliveFlowNamesDirty = true;\n  }\n\n  public CopyAndStartPatching() {\n    let copy = new StoryState(this.story);\n\n    copy._patch = new StatePatch(this._patch);\n\n    copy._currentFlow.name = this._currentFlow.name;\n    copy._currentFlow.callStack = new CallStack(this._currentFlow.callStack);\n    copy._currentFlow.currentChoices.push(...this._currentFlow.currentChoices);\n    copy._currentFlow.outputStream.push(...this._currentFlow.outputStream);\n    copy.OutputStreamDirty();\n\n    if (this._namedFlows !== null) {\n      copy._namedFlows = new Map();\n      for (let [namedFlowKey, namedFlowValue] of this._namedFlows) {\n        copy._namedFlows.set(namedFlowKey, namedFlowValue);\n        copy._aliveFlowNamesDirty = true;\n      }\n      copy._namedFlows.set(this._currentFlow.name, copy._currentFlow);\n    }\n\n    if (this.hasError) {\n      copy._currentErrors = [];\n      copy._currentErrors.push(...(this.currentErrors || []));\n    }\n\n    if (this.hasWarning) {\n      copy._currentWarnings = [];\n      copy._currentWarnings.push(...(this.currentWarnings || []));\n    }\n\n    copy.variablesState = this.variablesState;\n    copy.variablesState.callStack = copy.callStack;\n    copy.variablesState.patch = copy._patch;\n\n    copy.evaluationStack.push(...this.evaluationStack);\n\n    if (!this.divertedPointer.isNull)\n      copy.divertedPointer = this.divertedPointer.copy();\n\n    copy.previousPointer = this.previousPointer.copy();\n\n    copy._visitCounts = this._visitCounts;\n    copy._turnIndices = this._turnIndices;\n\n    copy.currentTurnIndex = this.currentTurnIndex;\n    copy.storySeed = this.storySeed;\n    copy.previousRandom = this.previousRandom;\n\n    copy.didSafeExit = this.didSafeExit;\n\n    return copy;\n  }\n\n  public RestoreAfterPatch() {\n    this.variablesState.callStack = this.callStack;\n    this.variablesState.patch = this._patch;\n  }\n\n  public ApplyAnyPatch() {\n    if (this._patch === null) return;\n\n    this.variablesState.ApplyPatch();\n\n    for (let [key, value] of this._patch.visitCounts)\n      this.ApplyCountChanges(key, value, true);\n\n    for (let [key, value] of this._patch.turnIndices)\n      this.ApplyCountChanges(key, value, false);\n\n    this._patch = null;\n  }\n\n  public ApplyCountChanges(\n    container: Container,\n    newCount: number,\n    isVisit: boolean\n  ) {\n    let counts = isVisit ? this._visitCounts : this._turnIndices;\n    counts.set(container.path.toString(), newCount);\n  }\n\n  public WriteJson(writer: SimpleJson.Writer) {\n    writer.WriteObjectStart();\n\n    writer.WritePropertyStart(\"flows\");\n    writer.WriteObjectStart();\n\n    // NOTE: Never pass `WriteJson` directly as an argument to `WriteProperty`.\n    // Call it inside a function to make sure `this` is correctly bound\n    // and passed down the call hierarchy.\n\n    if (this._namedFlows !== null) {\n      for (let [namedFlowKey, namedFlowValue] of this._namedFlows) {\n        writer.WriteProperty(namedFlowKey, (w) => namedFlowValue.WriteJson(w));\n      }\n    } else {\n      writer.WriteProperty(this._currentFlow.name, (w) =>\n        this._currentFlow.WriteJson(w)\n      );\n    }\n\n    writer.WriteObjectEnd();\n    writer.WritePropertyEnd();\n\n    writer.WriteProperty(\"currentFlowName\", this._currentFlow.name);\n\n    writer.WriteProperty(\"variablesState\", (w) =>\n      this.variablesState.WriteJson(w)\n    );\n\n    writer.WriteProperty(\"evalStack\", (w) =>\n      JsonSerialisation.WriteListRuntimeObjs(w, this.evaluationStack)\n    );\n\n    if (!this.divertedPointer.isNull) {\n      if (this.divertedPointer.path === null) {\n        return throwNullException(\"divertedPointer\");\n      }\n      writer.WriteProperty(\n        \"currentDivertTarget\",\n        this.divertedPointer.path.componentsString\n      );\n    }\n\n    writer.WriteProperty(\"visitCounts\", (w) =>\n      JsonSerialisation.WriteIntDictionary(w, this._visitCounts)\n    );\n    writer.WriteProperty(\"turnIndices\", (w) =>\n      JsonSerialisation.WriteIntDictionary(w, this._turnIndices)\n    );\n\n    writer.WriteIntProperty(\"turnIdx\", this.currentTurnIndex);\n    writer.WriteIntProperty(\"storySeed\", this.storySeed);\n    writer.WriteIntProperty(\"previousRandom\", this.previousRandom);\n\n    writer.WriteIntProperty(\"inkSaveVersion\", this.kInkSaveStateVersion);\n\n    writer.WriteIntProperty(\"inkFormatVersion\", Story.inkVersionCurrent);\n\n    writer.WriteObjectEnd();\n  }\n\n  public LoadJsonObj(value: Record<string, any>) {\n    let jObject = value;\n\n    let jSaveVersion = jObject[\"inkSaveVersion\"];\n    if (jSaveVersion == null) {\n      throw new Error(\"ink save format incorrect, can't load.\");\n    } else if (parseInt(jSaveVersion) < this.kMinCompatibleLoadVersion) {\n      throw new Error(\n        \"Ink save format isn't compatible with the current version (saw '\" +\n          jSaveVersion +\n          \"', but minimum is \" +\n          this.kMinCompatibleLoadVersion +\n          \"), so can't load.\"\n      );\n    }\n\n    let flowsObj = jObject[\"flows\"];\n    if (flowsObj != null) {\n      let flowsObjDict = flowsObj as Record<string, any>;\n\n      // Single default flow\n      if (Object.keys(flowsObjDict).length === 1) {\n        this._namedFlows = null;\n      } else if (this._namedFlows === null) {\n        this._namedFlows = new Map();\n      } else {\n        this._namedFlows.clear();\n      }\n\n      let flowsObjDictEntries = Object.entries(flowsObjDict);\n      for (let [namedFlowObjKey, namedFlowObjValue] of flowsObjDictEntries) {\n        let name = namedFlowObjKey;\n        let flowObj = namedFlowObjValue as Record<string, any>;\n\n        let flow = new Flow(name, this.story, flowObj);\n\n        if (Object.keys(flowsObjDict).length === 1) {\n          this._currentFlow = new Flow(name, this.story, flowObj);\n        } else {\n          if (this._namedFlows === null)\n            return throwNullException(\"this._namedFlows\");\n          this._namedFlows.set(name, flow);\n        }\n      }\n\n      if (this._namedFlows != null && this._namedFlows.size > 1) {\n        let currFlowName = jObject[\"currentFlowName\"] as string;\n        // Adding a bang at the end, because we're trusting the save, as\n        // done in upstream.  If the save is corrupted, the execution\n        // is undefined.\n        this._currentFlow = this._namedFlows.get(currFlowName)!;\n      }\n    } else {\n      this._namedFlows = null;\n      this._currentFlow.name = this.kDefaultFlowName;\n      this._currentFlow.callStack.SetJsonToken(\n        jObject[\"callstackThreads\"] as Record<string, any>,\n        this.story\n      );\n      this._currentFlow.outputStream = JsonSerialisation.JArrayToRuntimeObjList(\n        jObject[\"outputStream\"] as any[]\n      );\n      this._currentFlow.currentChoices =\n        JsonSerialisation.JArrayToRuntimeObjList(\n          jObject[\"currentChoices\"] as any[]\n        ) as Choice[];\n\n      let jChoiceThreadsObj = jObject[\"choiceThreads\"];\n      this._currentFlow.LoadFlowChoiceThreads(jChoiceThreadsObj, this.story);\n    }\n\n    this.OutputStreamDirty();\n    this._aliveFlowNamesDirty = true;\n\n    this.variablesState.SetJsonToken(jObject[\"variablesState\"]);\n    this.variablesState.callStack = this._currentFlow.callStack;\n\n    this._evaluationStack = JsonSerialisation.JArrayToRuntimeObjList(\n      jObject[\"evalStack\"]\n    );\n\n    let currentDivertTargetPath = jObject[\"currentDivertTarget\"];\n    if (currentDivertTargetPath != null) {\n      let divertPath = new Path(currentDivertTargetPath.toString());\n      this.divertedPointer = this.story.PointerAtPath(divertPath);\n    }\n\n    this._visitCounts = JsonSerialisation.JObjectToIntDictionary(\n      jObject[\"visitCounts\"]\n    );\n    this._turnIndices = JsonSerialisation.JObjectToIntDictionary(\n      jObject[\"turnIndices\"]\n    );\n    this.currentTurnIndex = parseInt(jObject[\"turnIdx\"]);\n    this.storySeed = parseInt(jObject[\"storySeed\"]);\n    this.previousRandom = parseInt(jObject[\"previousRandom\"]);\n  }\n\n  public ResetErrors() {\n    this._currentErrors = null;\n    this._currentWarnings = null;\n  }\n  public ResetOutput(objs: InkObject[] | null = null) {\n    this.outputStream.length = 0;\n    if (objs !== null) this.outputStream.push(...objs);\n    this.OutputStreamDirty();\n  }\n\n  public PushToOutputStream(obj: InkObject | null) {\n    // var text = obj as StringValue;\n    let text = asOrNull(obj, StringValue);\n    if (text !== null) {\n      let listText = this.TrySplittingHeadTailWhitespace(text);\n      if (listText !== null) {\n        for (let textObj of listText) {\n          this.PushToOutputStreamIndividual(textObj);\n        }\n        this.OutputStreamDirty();\n        return;\n      }\n    }\n\n    this.PushToOutputStreamIndividual(obj);\n    this.OutputStreamDirty();\n  }\n\n  public PopFromOutputStream(count: number) {\n    this.outputStream.splice(this.outputStream.length - count, count);\n    this.OutputStreamDirty();\n  }\n\n  public TrySplittingHeadTailWhitespace(single: StringValue) {\n    let str = single.value;\n    if (str === null) {\n      return throwNullException(\"single.value\");\n    }\n\n    let headFirstNewlineIdx = -1;\n    let headLastNewlineIdx = -1;\n    for (let i = 0; i < str.length; i++) {\n      let c = str[i];\n      if (c == \"\\n\") {\n        if (headFirstNewlineIdx == -1) headFirstNewlineIdx = i;\n        headLastNewlineIdx = i;\n      } else if (c == \" \" || c == \"\\t\") continue;\n      else break;\n    }\n\n    let tailLastNewlineIdx = -1;\n    let tailFirstNewlineIdx = -1;\n    for (let i = str.length - 1; i >= 0; i--) {\n      let c = str[i];\n      if (c == \"\\n\") {\n        if (tailLastNewlineIdx == -1) tailLastNewlineIdx = i;\n        tailFirstNewlineIdx = i;\n      } else if (c == \" \" || c == \"\\t\") continue;\n      else break;\n    }\n\n    // No splitting to be done?\n    if (headFirstNewlineIdx == -1 && tailLastNewlineIdx == -1) return null;\n\n    let listTexts: StringValue[] = [];\n    let innerStrStart = 0;\n    let innerStrEnd = str.length;\n\n    if (headFirstNewlineIdx != -1) {\n      if (headFirstNewlineIdx > 0) {\n        let leadingSpaces = new StringValue(\n          str.substring(0, headFirstNewlineIdx)\n        );\n        listTexts.push(leadingSpaces);\n      }\n      listTexts.push(new StringValue(\"\\n\"));\n      innerStrStart = headLastNewlineIdx + 1;\n    }\n\n    if (tailLastNewlineIdx != -1) {\n      innerStrEnd = tailFirstNewlineIdx;\n    }\n\n    if (innerStrEnd > innerStrStart) {\n      let innerStrText = str.substring(innerStrStart, innerStrEnd);\n      listTexts.push(new StringValue(innerStrText));\n    }\n\n    if (tailLastNewlineIdx != -1 && tailFirstNewlineIdx > headLastNewlineIdx) {\n      listTexts.push(new StringValue(\"\\n\"));\n      if (tailLastNewlineIdx < str.length - 1) {\n        let numSpaces = str.length - tailLastNewlineIdx - 1;\n        let trailingSpaces = new StringValue(\n          str.substring(\n            tailLastNewlineIdx + 1,\n            tailLastNewlineIdx + 1 + numSpaces\n          )\n        );\n        listTexts.push(trailingSpaces);\n      }\n    }\n\n    return listTexts;\n  }\n\n  public PushToOutputStreamIndividual(obj: InkObject | null) {\n    let glue = asOrNull(obj, Glue);\n    let text = asOrNull(obj, StringValue);\n\n    let includeInOutput = true;\n\n    if (glue) {\n      this.TrimNewlinesFromOutputStream();\n      includeInOutput = true;\n    } else if (text) {\n      let functionTrimIndex = -1;\n      let currEl = this.callStack.currentElement;\n      if (currEl.type == PushPopType.Function) {\n        functionTrimIndex = currEl.functionStartInOutputStream;\n      }\n\n      let glueTrimIndex = -1;\n      for (let i = this.outputStream.length - 1; i >= 0; i--) {\n        let o = this.outputStream[i];\n        let c = o instanceof ControlCommand ? o : null;\n        let g = o instanceof Glue ? o : null;\n\n        if (g != null) {\n          glueTrimIndex = i;\n          break;\n        } else if (\n          c != null &&\n          c.commandType == ControlCommand.CommandType.BeginString\n        ) {\n          if (i >= functionTrimIndex) {\n            functionTrimIndex = -1;\n          }\n          break;\n        }\n      }\n\n      let trimIndex = -1;\n      if (glueTrimIndex != -1 && functionTrimIndex != -1)\n        trimIndex = Math.min(functionTrimIndex, glueTrimIndex);\n      else if (glueTrimIndex != -1) trimIndex = glueTrimIndex;\n      else trimIndex = functionTrimIndex;\n\n      if (trimIndex != -1) {\n        if (text.isNewline) {\n          includeInOutput = false;\n        } else if (text.isNonWhitespace) {\n          if (glueTrimIndex > -1) this.RemoveExistingGlue();\n\n          if (functionTrimIndex > -1) {\n            let callStackElements = this.callStack.elements;\n            for (let i = callStackElements.length - 1; i >= 0; i--) {\n              let el = callStackElements[i];\n              if (el.type == PushPopType.Function) {\n                el.functionStartInOutputStream = -1;\n              } else {\n                break;\n              }\n            }\n          }\n        }\n      } else if (text.isNewline) {\n        if (this.outputStreamEndsInNewline || !this.outputStreamContainsContent)\n          includeInOutput = false;\n      }\n    }\n\n    if (includeInOutput) {\n      if (obj === null) {\n        return throwNullException(\"obj\");\n      }\n      this.outputStream.push(obj);\n      this.OutputStreamDirty();\n    }\n  }\n\n  public TrimNewlinesFromOutputStream() {\n    let removeWhitespaceFrom = -1;\n\n    let i = this.outputStream.length - 1;\n    while (i >= 0) {\n      let obj = this.outputStream[i];\n      let cmd = asOrNull(obj, ControlCommand);\n      let txt = asOrNull(obj, StringValue);\n\n      if (cmd != null || (txt != null && txt.isNonWhitespace)) {\n        break;\n      } else if (txt != null && txt.isNewline) {\n        removeWhitespaceFrom = i;\n      }\n      i--;\n    }\n\n    // Remove the whitespace\n    if (removeWhitespaceFrom >= 0) {\n      i = removeWhitespaceFrom;\n      while (i < this.outputStream.length) {\n        let text = asOrNull(this.outputStream[i], StringValue);\n        if (text) {\n          this.outputStream.splice(i, 1);\n        } else {\n          i++;\n        }\n      }\n    }\n\n    this.OutputStreamDirty();\n  }\n\n  public RemoveExistingGlue() {\n    for (let i = this.outputStream.length - 1; i >= 0; i--) {\n      let c = this.outputStream[i];\n      if (c instanceof Glue) {\n        this.outputStream.splice(i, 1);\n      } else if (c instanceof ControlCommand) {\n        break;\n      }\n    }\n\n    this.OutputStreamDirty();\n  }\n\n  get outputStreamEndsInNewline() {\n    if (this.outputStream.length > 0) {\n      for (let i = this.outputStream.length - 1; i >= 0; i--) {\n        let obj = this.outputStream[i];\n        if (obj instanceof ControlCommand) break;\n        let text = this.outputStream[i];\n        if (text instanceof StringValue) {\n          if (text.isNewline) return true;\n          else if (text.isNonWhitespace) break;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  get outputStreamContainsContent() {\n    for (let content of this.outputStream) {\n      if (content instanceof StringValue) return true;\n    }\n    return false;\n  }\n\n  get inStringEvaluation() {\n    for (let i = this.outputStream.length - 1; i >= 0; i--) {\n      let cmd = asOrNull(this.outputStream[i], ControlCommand);\n      if (\n        cmd instanceof ControlCommand &&\n        cmd.commandType == ControlCommand.CommandType.BeginString\n      ) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  public PushEvaluationStack(obj: InkObject | null) {\n    // var listValue = obj as ListValue;\n    let listValue = asOrNull(obj, ListValue);\n    if (listValue) {\n      // Update origin when list is has something to indicate the list origin\n      let rawList = listValue.value;\n      if (rawList === null) {\n        return throwNullException(\"rawList\");\n      }\n\n      if (rawList.originNames != null) {\n        if (!rawList.origins) rawList.origins = [];\n        rawList.origins.length = 0;\n\n        for (let n of rawList.originNames) {\n          if (this.story.listDefinitions === null)\n            return throwNullException(\"StoryState.story.listDefinitions\");\n          let def = this.story.listDefinitions.TryListGetDefinition(n, null);\n          if (def.result === null)\n            return throwNullException(\"StoryState def.result\");\n          if (rawList.origins.indexOf(def.result) < 0)\n            rawList.origins.push(def.result);\n        }\n      }\n    }\n\n    if (obj === null) {\n      return throwNullException(\"obj\");\n    }\n    this.evaluationStack.push(obj);\n  }\n\n  public PopEvaluationStack(): InkObject;\n  public PopEvaluationStack(numberOfObjects: number): InkObject[];\n  public PopEvaluationStack(numberOfObjects?: number) {\n    if (typeof numberOfObjects === \"undefined\") {\n      let obj = this.evaluationStack.pop();\n      return nullIfUndefined(obj);\n    } else {\n      if (numberOfObjects > this.evaluationStack.length) {\n        throw new Error(\"trying to pop too many objects\");\n      }\n\n      let popped = this.evaluationStack.splice(\n        this.evaluationStack.length - numberOfObjects,\n        numberOfObjects\n      );\n      return nullIfUndefined(popped);\n    }\n  }\n\n  public PeekEvaluationStack() {\n    return this.evaluationStack[this.evaluationStack.length - 1];\n  }\n\n  public ForceEnd() {\n    this.callStack.Reset();\n\n    this._currentFlow.currentChoices.length = 0;\n\n    this.currentPointer = Pointer.Null;\n    this.previousPointer = Pointer.Null;\n\n    this.didSafeExit = true;\n  }\n\n  public TrimWhitespaceFromFunctionEnd() {\n    Debug.Assert(this.callStack.currentElement.type == PushPopType.Function);\n    let functionStartPoint =\n      this.callStack.currentElement.functionStartInOutputStream;\n\n    if (functionStartPoint == -1) {\n      functionStartPoint = 0;\n    }\n\n    for (let i = this.outputStream.length - 1; i >= functionStartPoint; i--) {\n      let obj = this.outputStream[i];\n      let txt = asOrNull(obj, StringValue);\n      let cmd = asOrNull(obj, ControlCommand);\n\n      if (txt == null) continue;\n      if (cmd) break;\n\n      if (txt.isNewline || txt.isInlineWhitespace) {\n        this.outputStream.splice(i, 1);\n        this.OutputStreamDirty();\n      } else {\n        break;\n      }\n    }\n  }\n\n  public PopCallStack(popType: PushPopType | null = null) {\n    if (this.callStack.currentElement.type == PushPopType.Function)\n      this.TrimWhitespaceFromFunctionEnd();\n\n    this.callStack.Pop(popType);\n  }\n\n  public SetChosenPath(path: Path, incrementingTurnIndex: boolean) {\n    // Changing direction, assume we need to clear current set of choices\n    this._currentFlow.currentChoices.length = 0;\n\n    let newPointer = this.story.PointerAtPath(path);\n    if (!newPointer.isNull && newPointer.index == -1) newPointer.index = 0;\n\n    this.currentPointer = newPointer;\n\n    if (incrementingTurnIndex) {\n      this.currentTurnIndex++;\n    }\n  }\n\n  public StartFunctionEvaluationFromGame(\n    funcContainer: Container,\n    args: any[]\n  ) {\n    this.callStack.Push(\n      PushPopType.FunctionEvaluationFromGame,\n      this.evaluationStack.length\n    );\n    this.callStack.currentElement.currentPointer =\n      Pointer.StartOf(funcContainer);\n\n    this.PassArgumentsToEvaluationStack(args);\n  }\n\n  public PassArgumentsToEvaluationStack(args: any[] | null) {\n    if (args !== null) {\n      for (let i = 0; i < args.length; i++) {\n        if (\n          !(\n            typeof args[i] === \"number\" ||\n            typeof args[i] === \"string\" ||\n            typeof args[i] === \"boolean\" ||\n            args[i] instanceof InkList\n          )\n        ) {\n          throw new Error(\n            \"ink arguments when calling EvaluateFunction / ChoosePathStringWithParameters must be\" +\n            \"number, string, bool or InkList. Argument was \" +\n            (nullIfUndefined(arguments[i]) === null)\n              ? \"null\"\n              : arguments[i].constructor.name\n          );\n        }\n\n        this.PushEvaluationStack(Value.Create(args[i]));\n      }\n    }\n  }\n\n  public TryExitFunctionEvaluationFromGame() {\n    if (\n      this.callStack.currentElement.type ==\n      PushPopType.FunctionEvaluationFromGame\n    ) {\n      this.currentPointer = Pointer.Null;\n      this.didSafeExit = true;\n      return true;\n    }\n\n    return false;\n  }\n\n  public CompleteFunctionEvaluationFromGame() {\n    if (\n      this.callStack.currentElement.type !=\n      PushPopType.FunctionEvaluationFromGame\n    ) {\n      throw new Error(\n        \"Expected external function evaluation to be complete. Stack trace: \" +\n          this.callStack.callStackTrace\n      );\n    }\n\n    let originalEvaluationStackHeight =\n      this.callStack.currentElement.evaluationStackHeightWhenPushed;\n\n    let returnedObj: InkObject | null = null;\n    while (this.evaluationStack.length > originalEvaluationStackHeight) {\n      let poppedObj = this.PopEvaluationStack();\n      if (returnedObj === null) returnedObj = poppedObj;\n    }\n\n    this.PopCallStack(PushPopType.FunctionEvaluationFromGame);\n\n    if (returnedObj) {\n      if (returnedObj instanceof Void) return null;\n\n      // Some kind of value, if not void\n      // var returnVal = returnedObj as Runtime.Value;\n      let returnVal = asOrThrows(returnedObj, Value);\n\n      // DivertTargets get returned as the string of components\n      // (rather than a Path, which isn't public)\n      if (returnVal.valueType == ValueType.DivertTarget) {\n        return returnVal.valueObject.toString();\n      }\n\n      // Other types can just have their exact object type:\n      // int, float, string. VariablePointers get returned as strings.\n      return returnVal.valueObject;\n    }\n\n    return null;\n  }\n\n  public AddError(message: string, isWarning: boolean) {\n    if (!isWarning) {\n      if (this._currentErrors == null) this._currentErrors = [];\n      this._currentErrors.push(message);\n    } else {\n      if (this._currentWarnings == null) this._currentWarnings = [];\n      this._currentWarnings.push(message);\n    }\n  }\n\n  public OutputStreamDirty() {\n    this._outputStreamTextDirty = true;\n    this._outputStreamTagsDirty = true;\n  }\n\n  private _visitCounts: Map<string, number>;\n  private _turnIndices: Map<string, number>;\n\n  private _outputStreamTextDirty = true;\n  private _outputStreamTagsDirty = true;\n\n  private _patch: StatePatch | null = null;\n\n  private _currentFlow: Flow;\n  private _aliveFlowNames: string[] | null = null;\n  private _namedFlows: Map<string, Flow> | null = null;\n  private readonly kDefaultFlowName = \"DEFAULT_FLOW\";\n  private _aliveFlowNamesDirty: boolean = true;\n}\n","// This is simple replacement of the Stopwatch class from the .NET Framework.\n// The original class can count time with much more accuracy than the Javascript version.\n// It might be worth considering using `window.performance` in the browser\n// or `process.hrtime()` in node.\nexport class Stopwatch {\n  private startTime: number | undefined;\n\n  constructor() {\n    this.startTime = undefined;\n  }\n\n  get ElapsedMilliseconds(): number {\n    if (typeof this.startTime === \"undefined\") {\n      return 0;\n    }\n    return new Date().getTime() - this.startTime;\n  }\n\n  public Start() {\n    this.startTime = new Date().getTime();\n  }\n  public Stop() {\n    this.startTime = undefined;\n  }\n}\n"],"names":["Debug","Path","_classCallCheck","this","_components","_componentsString","_isRelative","arguments","componentsString","Component","head","tail","push","concat","Array","relative","_createClass","key","get","length","slice","self","lastComponentIdx","i","l","isIndex","value","index","pathToAppend","p","upwardMoves","isParent","join","isRelative","set","substring","_step","_iterator","_createForOfIteratorHelper","split","s","n","done","str","test","parseInt","err","e","f","otherPath","Equals","c","_p$_components","apply","_toConsumableArray","path","asOrNull","obj","type","unsafeTypeAssertion","asOrThrows","Error","asINamedContentOrNull","hasValidName","name","nullIfUndefined","isEquatable","_typeof","parentId","indexOrName","toString","otherComp","Assert","condition","message","console","warn","trace","AssertType","variable","NullException","_Error","_inherits","_super","_createSuper","_wrapNativeSuper","throwNullException","InkObject","parent","_debugMetadata","_path","debugMetadata","root","rootContentContainer","targetContent","ContentAtPath","dm","startLineNumber","comps","child","container","Container","namedChild","unshift","content","indexOf","nearestContainer","GetComponent","contentContainer","globalPath","ownPath","minPathLength","Math","min","lastSharedPathCompIndex","ownComp","numUpwardsMoves","componentCount","newPathComps","up","ToParent","down","globalPathStr","relativePathStr","PathByAppendingPath","ConvertPathToRelative","ancestor","prop","StringBuilder","string","Append","format","_len","args","_key","replace","match","num","InkListItem","originName","itemName","nameParts","fullName","otherItem","JSON","stringify","parse","isLikeInkListItem","Null","inkListItem","item","hasOwnProperty","InkList","_Map","_this","_arguments","call","origins","_originNames","otherList","otherOriginNames","originNames","singleOriginListName","originStory","SetInitialOriginName","listDefinitions","_possibleConstructorReturn","def","TryListGetDefinition","exists","result","singleElement","Add","Key","Value","itemOrItemName","AddItem","origin","intVal","TryGetValueForItem","foundListDef","_step2","_iterator2","ContainsItemWithName","itemVal","ValueForItem","_step3","_iterator3","_slicedToArray","fromSerializedKey","has","serialized","serializedKey","delete","size","maxOriginName","maxItem","every","Count","_step4","_iterator4","initialOriginName","initialOriginNames","_step5","max","_iterator5","_step5$value","isNull","_step6","_iterator6","_step6$value","list","_step7","_iterator7","_step8","_iterator8","items","_step8$value","ContainsKey","_step9","_iterator9","_step10","_iterator10","_step10$value","_step11","union","_iterator11","_step11$value","_step12","intersection","_iterator12","_step12$value","_step13","_iterator13","listToRemove","_step14","_iterator14","what","ContainsItemNamed","_step15","_iterator15","minItem","minBound","maxBound","ordered","orderedItems","minValue","maxValue","Number","MAX_SAFE_INTEGER","isInteger","subList","SetInitialOriginNames","_step16","_iterator16","otherInkList","_step17","_iterator17","_step18","_iterator18","_step18$value","sort","x","y","localeCompare","sb","NaN","myListItem","listValue","_a","FindSingleItemListWithName","Map","StoryException","useEndLineNumber","tryGetValueFromMap","map","val","AbstractValue","ValueType","_InkObject","Create","valueObject","targetType","valueType","preferredNumberType","Int","IntValue","Float","isNaN","FloatValue","BoolValue","Boolean","StringValue","String","DivertTargetValue","ListValue","_AbstractValue","_super2","_Value","_super3","Bool","newType","BadCastException","_Value2","_super4","_Value3","_super5","_Value4","_super6","_this2","_isNewline","_isInlineWhitespace","isNewline","isInlineWhitespace","parsedInt","defaultValue","tryParseInt","parsedFloat","parseFloat","tryParseFloat","_Value5","_super7","targetPath","DivertTarget","VariablePointerValue","_Value6","_super8","variableName","_this3","contextIndex","undefined","_contextIndex","VariablePointer","_Value7","_super9","listOrSingleItem","singleValue","_this4","List","oldValue","newValue","oldList","newList","SearchResult","approximate","searchResult","_content","namedContent","visitsShouldBeCounted","turnIndexShouldBeCounted","countingAtStartOnly","_pathToFirstLeafContent","AddContent","namedOnlyContentDict","_step$value","inkObject","named","existingNamedOnly","namedOnlyContent","AddToNamedContentOnly","flags","CountFlags","Visits","Turns","CountStartOnly","flag","internalPathToFirstLeafContent","components","contentObjOrList","contentObj","TryAddNamedContent","namedContentObj","partialPathStart","partialPathLength","currentContainer","currentObj","comp","foundObj","ContentWithPathComponent","splice","otherContainer","_this$content","component","foundContent","BuildStringOfHierarchy","indentation","pointedObj","appendIndentation","AppendFormat","AppendLine","onlyNamed","_step7$value","Glue","PushPopType","ControlCommand","commandType","CommandType","NotSet","_commandType","EvalStart","EvalOutput","EvalEnd","Duplicate","PopEvaluatedValue","PopFunction","PopTunnel","BeginString","EndString","NoOp","ChoiceCount","TurnsSince","ReadCount","Random","SeedRandom","VisitIndex","SequenceShuffleIndex","StartThread","Done","End","ListFromInt","ListRange","ListRandom","BeginTag","EndTag","Pointer","PathByAppendingComponent","Divert","stackPushType","_targetPath","_targetPointer","variableDivertName","pushesToStack","isExternal","externalArgs","isConditional","targetObj","targetPointer","Resolve","ResolvePath","lastComponent","StartOf","copy","CompactPathString","otherDivert","hasVariableTarget","targetStr","Function","targetPathString","ChoicePoint","onceOnly","_pathOnChoice","hasCondition","hasStartContent","hasChoiceOnlyContent","isInvisibleDefault","choiceTargetObj","choiceTarget","pathOnChoice","VariableReference","pathForCount","pathStringForCount","VariableAssignment","isNewDeclaration","isGlobal","Void","NativeFunctionCall","_name","_numberOfParameters","_prototype","_isPrototype","_operationFuncs","GenerateNativeFunctionsIfNecessary","numberOfParameters","_nativeFunctions","parameters","Call","hasList","CallBinaryListOperation","coercedParams","CoerceValuesToSingleType","coercedType","CallType","parametersOfSingleType","param1","valType","val1","paramCount","opForTypeObj","val2","opForType","resultVal","CallListIncrementOperation","v1","v2","op","asBooleanOrThrows","isTruthy","listIntParams","listVal","resultInkList","_step2$value","listItemKey","listItemValue","listItem","intOp","targetInt","itemOrigin","incrementedItem","TryGetItemWithValue","parametersIn","specialCaseList","parametersOut","originOfMaxItem","castedValue","Cast","functionName","t","AddIntBinaryOp","Subtract","Multiply","Divide","floor","Mod","AddIntUnaryOp","Negate","Equal","Greater","Less","GreaterThanOrEquals","LessThanOrEquals","NotEquals","Not","And","Or","Max","Min","Pow","pow","Floor","Identity","Ceiling","AddFloatBinaryOp","AddFloatUnaryOp","ceil","AddStringBinaryOp","Has","includes","Hasnt","AddListBinaryOp","Union","Without","Contains","Intersect","GreaterThan","LessThan","AddListUnaryOp","Invert","inverse","All","all","ListMin","MinAsList","ListMax","MaxAsList","ValueOfList","AddOpToNativeFunc","d1","d2","nativeFunc","AddOpFuncForType","Tag","tagText","text","Choice","threadAtGeneration","sourcePath","tags","originalThreadIndex","ListDefinition","_items","_itemNameToValues","ListDefinitionsOrigin","lists","_lists","_allUnambiguousListValueCache","listOfLists","definition","JsonSerialisation","jArray","skipLast","count","jTok","runtimeObj","JTokenToRuntimeObject","writer","dictionary","WriteObjectStart","WritePropertyStart","WriteRuntimeObject","WritePropertyEnd","WriteObjectEnd","WriteArrayStart","WriteArrayEnd","dict","_step3$value","WriteIntProperty","WriteRuntimeContainer","divert","divTypeKey","Tunnel","WriteProperty","choicePoint","pathStringOnChoice","boolVal","WriteBool","WriteInt","floatVal","WriteFloat","strVal","Write","WriteStringStart","WriteStringInner","WriteStringEnd","WriteInkList","divTargetVal","varPtrVal","controlCmd","_controlCommandNames","varRef","readCountPath","varAss","tag","choice","WriteChoice","jObject","token","firstChar","CallExistsWithName","CallWithName","isArray","propValue","varPtr","isDivert","divPushType","external","target","readCountVarRef","isVarAss","isGlobalVar","varName","isNewDecl","listContent","rawList","namesAsObjs","nameToVal","JObjectToChoice","JArrayToContainer","toJson","me","removes","space","k","v","some","r","withoutName","countFlags","hasNameProperty","hasTerminator","namedContainer","WriteNull","JArrayToRuntimeObjList","terminatingObj","namedContentItem","namedSubContainer","jObj","WritePropertyNameStart","WritePropertyNameInner","WritePropertyNameEnd","listDefJson","_step9$value","defsObj","allDefs","nameValueKey","nameValue","TOTAL_VALUES","CallStack","_threadCounter","_startOfRoot","Story","storyContext","Reset","toCopy","_threads","otherThread","Copy","callStack","elements","cs","callstack","Thread","Element","jThreadObj","thread","w","WriteObject","WriteJson","newThread","currentThread","threadIndex","forkedThread","canPopThread","elementIsEvaluateFromGame","currentElement","FunctionEvaluationFromGame","externalEvaluationStackHeight","outputStreamLengthWithPushed","element","currentPointer","evaluationStackHeightWhenPushed","functionStartInOutputStream","canPop","CanPop","pop","currentElementIndex","varValue","temporaryVariables","declareNew","contextElement","RetainListOriginsForAssignment","filtered","filter","isCurrent","pointer","inExpressionEvaluation","previousPointer","jElementObj","pushPopType","currentContainerPathStr","currentContainerPathStrToken","threadPointerResult","Warning","el","temps","JObjectToDictionaryRuntimeObjs","clear","prevContentObjPath","prevPath","PointerAtPath","WriteDictionaryRuntimeObjs","resolvedPointer","VariablesState","_VariablesStateAccess","listDefsOrigin","variableChangedEventCallbacks","patch","_batchObservingVariableChanges","_defaultGlobalVariables","_changedVariablesForBatchObs","Set","_globalVariables","_callStack","_listDefsOrigin","Proxy","_assertThisInitialized","$","callback","currentValue","variableChangedEvent","varContents","TryGetGlobal","SetGlobal","globals","namedVarKey","namedVarValue","changedVariables","add","jToken","varValKey","varValValue","loadedToken","tokenInkObject","keyValKey","keyValValue","dontSaveDefaultValues","defaultVal","RuntimeObjectsEqual","obj1","obj2","constructor","GetRawVariableWithName","varPointer","ValueAtVariablePointer","variableValue","GetTemporaryVariableWithName","GetVariableWithName","setGlobal","GlobalVariableExistsWithName","ResolveVariablePointer","existingPointer","SetTemporaryVariable","batchObservingVariableChanges","AddChangedVariable","GetContextIndexOfVariableNamed","doubleRedirectionPointer","_class","PRNG","seed","next","StatePatch","_changedVariables","_visitCounts","_turnIndices","_globals","SimpleJson","Reader","ToDictionary","ToArray","_rootObject","Writer","_currentPropertyName","_currentString","_stateStack","_collectionStack","_propertyNameStack","_jsonObject","inner","StartNewObject","newObject","state","State","Property","currentCollection","currentPropertyName","propertyName","None","StateElement","Object","innerOrContent","IncrementChildCount","childCount","PropertyName","_addToCurrentObject","error","POSITIVE_INFINITY","NEGATIVE_INFINITY","currEl","ErrorType","OutputStateChange","Flow","story","SetJsonToken","outputStream","currentChoices","jChoiceThreadsObj","LoadFlowChoiceThreads","WriteListRuntimeObjs","hasChoiceThreads","ThreadWithIndex","jChoiceThreads","foundActiveThread","jSavedChoiceThread","StoryState","kInkSaveStateVersion","kMinCompatibleLoadVersion","onDidLoadState","_currentErrors","_currentWarnings","divertedPointer","_currentTurnIndex","storySeed","previousRandom","didSafeExit","_currentText","_currentTags","_outputStreamTextDirty","_outputStreamTagsDirty","_patch","_aliveFlowNames","_namedFlows","kDefaultFlowName","_aliveFlowNamesDirty","_currentFlow","OutputStreamDirty","_evaluationStack","_variablesState","currentTurnIndex","timeSeed","Date","getTime","GoToStart","indented","ToJson","json","TextToDictionary","LoadJsonObj","pathString","visitCountOut","TryGetVisitCount","containerPathStr","count2","currCount","VisitCountForContainer","SetVisitCount","SetTurnIndex","TryGetTurnIndex","index2","depth","canContinue","hasError","currentErrors","currentWarnings","inTag","outputObj","textContent","controlCommand","CleanOutputWhitespace","currentWhitespaceStart","startOfLine","charAt","Length","txt","Clear","keys","flowName","mainContentContainer","flow","variablesState","SwitchFlow_Internal","SwitchToDefaultFlow_Internal","_copy$_currentFlow$cu","_copy$_currentFlow$ou","_copy$evaluationStack","_copy$_currentErrors","_copy$_currentWarning","_step4$value","namedFlowKey","namedFlowValue","hasWarning","evaluationStack","ApplyPatch","visitCounts","ApplyCountChanges","turnIndices","newCount","isVisit","_loop","WriteIntDictionary","inkVersionCurrent","jSaveVersion","flowsObj","flowsObjDict","_i","_flowsObjDictEntries","entries","_flowsObjDictEntries$","flowObj","currFlowName","currentDivertTargetPath","divertPath","JObjectToIntDictionary","_this$outputStream","objs","listText","TrySplittingHeadTailWhitespace","textObj","PushToOutputStreamIndividual","single","headFirstNewlineIdx","headLastNewlineIdx","tailLastNewlineIdx","tailFirstNewlineIdx","listTexts","innerStrStart","innerStrEnd","leadingSpaces","innerStrText","numSpaces","trailingSpaces","glue","includeInOutput","TrimNewlinesFromOutputStream","functionTrimIndex","glueTrimIndex","o","isNonWhitespace","RemoveExistingGlue","callStackElements","outputStreamEndsInNewline","outputStreamContainsContent","removeWhitespaceFrom","cmd","numberOfObjects","functionStartPoint","popType","TrimWhitespaceFromFunctionEnd","Pop","incrementingTurnIndex","newPointer","funcContainer","Push","PassArgumentsToEvaluationStack","PushEvaluationStack","callStackTrace","originalEvaluationStackHeight","returnedObj","poppedObj","PopEvaluationStack","PopCallStack","returnVal","isWarning","Stopwatch","startTime","nVal","isFinite","exports","inkVersionMinimumCompatible","onError","onDidContinue","onMakeChoice","onEvaluateFunction","onCompleteEvaluateFunction","onChoosePathString","_prevContainers","allowExternalFunctionFallbacks","_listDefinitions","_variableObservers","_hasValidatedExternals","_temporaryEvaluationContainer","_asyncContinueActive","_stateSnapshotAtLastNewline","_sawLookaheadUnsafeFunctionAfterNewline","_recursiveContinueCount","_asyncSaving","_profiler","_mainContentContainer","jsonString","_externals","rootObject","versionObj","formatFromFile","listDefsObj","rootToken","JTokenToListDefinitions","ResetState","choices","_state","IfAsyncWeCant","currentText","currentTags","currentFlowName","currentFlowIsDefaultFlow","aliveFlowNames","shouldReturn","ObserveVariableChange","VariableStateDidChangeEvent","bind","ResetGlobals","ResetErrors","ForceEnd","originalPointer","ChoosePath","ContinueInternal","SnapshotDefaultGlobals","RemoveFlow_Internal","ContinueAsync","millisecsLimitAsync","ValidateExternalBindings","PreContinue","isAsyncTimeLimited","ResetOutput","durationStopwatch","Start","ContinueSingleStep","AddError","ElapsedMilliseconds","Stop","RestoreStateSnapshot","generatedChoices","PostContinue","PreStep","Step","PostStep","TryFollowDefaultInvisibleChoice","PreSnapshot","inStringEvaluation","change","CalculateNewlineOutputStateChange","ExtendedBeyondNewline","NewlineRemoved","DiscardSnapshot","StateSnapshot","PostSnapshot","prevText","currText","prevTagCount","currTagCount","newlineStillExists","NoChange","Continue","pathLengthToUse","CopyAndStartPatching","RestoreAfterPatch","ApplyAnyPatch","stateToSave","shouldAddToStream","containerToEnter","VisitContainer","currentContentObj","isLogicOrFlowControl","PerformLogicAndFlowControl","ProcessChoice","contextIdx","ContextForVariableNamed","PushToOutputStream","NextContent","PushThread","atStart","IncrementVisitCountForContainer","RecordTurnIndexVisitToContainer","prevAncestor","currentChildOfContainer","currentContainerAncestor","allChildrenEnteredAtStart","enteringAtStart","choiceOnlyStrVal","PeekEvaluationStack","showChoice","conditionValue","IsTruthy","startText","choiceOnlyText","PopChoiceStringAndTags","ForkThread","reverse","divTarget","currentDivert","intContent","errorMessage","CallExternalFunction","sourceName","evalCommand","output","overrideTunnelReturnTarget","popped","TryExitFunctionEvaluationFromGame","names","expected","errorMsg","contentStackForTag","outputCountConsumed","command","PopFromOutputStream","_contentStackForTag","choiceTag","contentStackForString","contentToRetain","_i3","_contentToRetain","rescuedTag","choiceCount","extraNote","eitherCount","divertTarget","correctObj","TurnsSinceForContainer","maxInt","minInt","randomRange","resultSeed","nextRandom","chosenValue","shuffleIndex","NextSequenceShuffleIndex","PopThread","listNameVal","generatedListValue","foundItem","targetList","ListWithSubRange","listItemIndex","listEnumerator","randomItem","assignedVal","Assign","foundValue","containerForCount","func","funcParams","resetCallstack","ResetCallstack","funcDetail","activityStr","SetChosenPath","VisitChangedContainersDueToDivert","choiceIdx","choiceToChoose","KnotContainerWithName","returnTextOutput","trim","outputStreamBefore","StartFunctionEvaluationFromGame","stringOutput","textOutput","CompleteFunctionEvaluationFromGame","returned","exprContainer","startCallStackHeight","evalStackHeight","funcName","numberOfArguments","funcDef","fallbackFunctionContainer","foundExternal","lookAheadSafe","valueObj","funcResult","function","returnObj","lookaheadSafe","BindExternalFunctionGeneral","coercedArgs","TryCoerce","missingExternals","from","innerContent","observer","variableNames","observers","ObserveVariable","specificVariableName","variableObservers","newValueObj","TagsAtStartOfFlowContainerWithPathString","flowContainer","firstContent","IncrementContentPointer","didPop","successfulIncrement","nextAncestor","indexInAncestor","allChoices","invisibleChoices","numElementsIntVal","seqContainer","numElements","seqCount","loopIndex","iterationIndex","seqPathStr","sequenceHash","charCodeAt","randomSeed","random","unpickedIndices","chosen","chosenIndex","currentDebugMetadata","errorTypeStr","lineNum","endLineNumber","fileName"],"mappings":"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"}